import "./chunk-BFCEFRYA.js";

// node_modules/asciimath2tex/dist/asciimath2tex.mjs
function t(t2, e2) {
  (null == e2 || e2 > t2.length) && (e2 = t2.length);
  for (var a2 = 0, i = new Array(e2); a2 < e2; a2++) i[a2] = t2[a2];
  return i;
}
function e(e2, a2) {
  var i = "undefined" != typeof Symbol && e2[Symbol.iterator] || e2["@@iterator"];
  if (i) return (i = i.call(e2)).next.bind(i);
  if (Array.isArray(e2) || (i = function(e3, a3) {
    if (e3) {
      if ("string" == typeof e3) return t(e3, a3);
      var i2 = Object.prototype.toString.call(e3).slice(8, -1);
      return "Object" === i2 && e3.constructor && (i2 = e3.constructor.name), "Map" === i2 || "Set" === i2 ? Array.from(e3) : "Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2) ? t(e3, a3) : void 0;
    }
  }(e2)) || a2 && e2 && "number" == typeof e2.length) {
    i && (e2 = i);
    var s = 0;
    return function() {
      return s >= e2.length ? { done: true } : { done: false, value: e2[s++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var a = function() {
  function t2() {
    this.decimalsign = "\\.", this.setup_symbols(), this.sort_symbols();
  }
  var a2 = t2.prototype;
  return a2.setup_symbols = function() {
    this.greek_letters = ["alpha", "beta", "gamma", "Gamma", "delta", "Delta", "epsilon", "varepsilon", "zeta", "eta", "theta", "Theta", "vartheta", "iota", "kappa", "lambda", "Lambda", "mu", "nu", "xi", "Xi", "pi", "Pi", "rho", "sigma", "Sigma", "tau", "upsilon", "phi", "Phi", "varphi", "chi", "psi", "Psi", "omega", "Omega"], this.relations = [{ asciimath: ":=", tex: ":=" }, { asciimath: ":|:", tex: "\\mid" }, { asciimath: "=>", tex: "\\Rightarrow" }, { asciimath: "approx", tex: "\\approx" }, { asciimath: "~~", tex: "\\approx" }, { asciimath: "cong", tex: "\\cong" }, { asciimath: "~=", tex: "\\cong" }, { asciimath: "equiv", tex: "\\equiv" }, { asciimath: "-=", tex: "\\equiv" }, { asciimath: "exists", tex: "\\exists" }, { asciimath: "EE", tex: "\\exists" }, { asciimath: "forall", tex: "\\forall" }, { asciimath: "AA", tex: "\\forall" }, { asciimath: ">=", tex: "\\ge" }, { asciimath: "ge", tex: "\\ge" }, { asciimath: "gt=", tex: "\\geq" }, { asciimath: "geq", tex: "\\geq" }, { asciimath: "gt", tex: "\\gt" }, { asciimath: "in", tex: "\\in" }, { asciimath: "<=", tex: "\\le" }, { asciimath: "le", tex: "\\le" }, { asciimath: "lt=", tex: "\\leq" }, { asciimath: "leq", tex: "\\leq" }, { asciimath: "lt", tex: "\\lt" }, { asciimath: "models", tex: "\\models" }, { asciimath: "|==", tex: "\\models" }, { asciimath: "!=", tex: "\\ne" }, { asciimath: "ne", tex: "\\ne" }, { asciimath: "notin", tex: "\\notin" }, { asciimath: "!in", tex: "\\notin" }, { asciimath: "prec", tex: "\\prec" }, { asciimath: "-lt", tex: "\\prec" }, { asciimath: "-<", tex: "\\prec" }, { asciimath: "preceq", tex: "\\preceq" }, { asciimath: "-<=", tex: "\\preceq" }, { asciimath: "propto", tex: "\\propto" }, { asciimath: "prop", tex: "\\propto" }, { asciimath: "subset", tex: "\\subset" }, { asciimath: "sub", tex: "\\subset" }, { asciimath: "subseteq", tex: "\\subseteq" }, { asciimath: "sube", tex: "\\subseteq" }, { asciimath: "succ", tex: "\\succ" }, { asciimath: ">-", tex: "\\succ" }, { asciimath: "succeq", tex: "\\succeq" }, { asciimath: ">-=", tex: "\\succeq" }, { asciimath: "supset", tex: "\\supset" }, { asciimath: "sup", tex: "\\supset" }, { asciimath: "supseteq", tex: "\\supseteq" }, { asciimath: "supe", tex: "\\supseteq" }, { asciimath: "vdash", tex: "\\vdash" }, { asciimath: "|--", tex: "\\vdash" }], this.constants = [{ asciimath: "dt", tex: "dt" }, { asciimath: "dx", tex: "dx" }, { asciimath: "dy", tex: "dy" }, { asciimath: "dz", tex: "dz" }, { asciimath: "prime", tex: "'" }, { asciimath: "implies", tex: "\\implies" }, { asciimath: "epsi", tex: "\\epsilon" }, { asciimath: "leftrightarrow", tex: "\\leftrightarrow" }, { asciimath: "Leftrightarrow", tex: "\\Leftrightarrow" }, { asciimath: "rightarrow", tex: "\\rightarrow" }, { asciimath: "Rightarrow", tex: "\\Rightarrow" }, { asciimath: "backslash", tex: "\\backslash" }, { asciimath: "leftarrow", tex: "\\leftarrow" }, { asciimath: "Leftarrow", tex: "\\Leftarrow" }, { asciimath: "setminus", tex: "\\setminus" }, { asciimath: "bigwedge", tex: "\\bigwedge" }, { asciimath: "diamond", tex: "\\diamond" }, { asciimath: "bowtie", tex: "\\bowtie" }, { asciimath: "bigvee", tex: "\\bigvee" }, { asciimath: "bigcap", tex: "\\bigcap" }, { asciimath: "bigcup", tex: "\\bigcup" }, { asciimath: "square", tex: "\\square" }, { asciimath: "lamda", tex: "\\lambda" }, { asciimath: "Lamda", tex: "\\Lambda" }, { asciimath: "aleph", tex: "\\aleph" }, { asciimath: "angle", tex: "\\angle" }, { asciimath: "frown", tex: "\\frown" }, { asciimath: "qquad", tex: "\\qquad" }, { asciimath: "cdots", tex: "\\cdots" }, { asciimath: "vdots", tex: "\\vdots" }, { asciimath: "ddots", tex: "\\ddots" }, { asciimath: "cdot", tex: "\\cdot" }, { asciimath: "star", tex: "\\star" }, { asciimath: "|><|", tex: "\\bowtie" }, { asciimath: "circ", tex: "\\circ" }, { asciimath: "oint", tex: "\\oint" }, { asciimath: "grad", tex: "\\nabla" }, { asciimath: "quad", tex: "\\quad" }, { asciimath: "uarr", tex: "\\uparrow" }, { asciimath: "darr", tex: "\\downarrow" }, { asciimath: "downarrow", tex: "\\downarrow" }, { asciimath: "rarr", tex: "\\rightarrow" }, { asciimath: ">->>", tex: "\\twoheadrightarrowtail" }, { asciimath: "larr", tex: "\\leftarrow" }, { asciimath: "harr", tex: "\\leftrightarrow" }, { asciimath: "rArr", tex: "\\Rightarrow" }, { asciimath: "lArr", tex: "\\Leftarrow" }, { asciimath: "hArr", tex: "\\Leftrightarrow" }, { asciimath: "ast", tex: "\\ast" }, { asciimath: "***", tex: "\\star" }, { asciimath: "|><", tex: "\\ltimes" }, { asciimath: "><|", tex: "\\rtimes" }, { asciimath: "^^^", tex: "\\bigwedge" }, { asciimath: "vvv", tex: "\\bigvee" }, { asciimath: "cap", tex: "\\cap" }, { asciimath: "nnn", tex: "\\bigcap" }, { asciimath: "cup", tex: "\\cup" }, { asciimath: "uuu", tex: "\\bigcup" }, { asciimath: "not", tex: "\\neg" }, { asciimath: "<=>", tex: "\\Leftrightarrow" }, { asciimath: "_|_", tex: "\\bot" }, { asciimath: "bot", tex: "\\bot" }, { asciimath: "int", tex: "\\int" }, { asciimath: "del", tex: "\\partial" }, { asciimath: "...", tex: "\\ldots" }, { asciimath: "/_\\", tex: "\\triangle" }, { asciimath: "|__", tex: "\\lfloor" }, { asciimath: "__|", tex: "\\rfloor" }, { asciimath: "dim", tex: "\\dim" }, { asciimath: "mod", tex: "\\operatorname{mod}" }, { asciimath: "lub", tex: "\\operatorname{lub}" }, { asciimath: "glb", tex: "\\operatorname{glb}" }, { asciimath: ">->", tex: "\\rightarrowtail" }, { asciimath: "->>", tex: "\\twoheadrightarrow" }, { asciimath: "|->", tex: "\\mapsto" }, { asciimath: "lim", tex: "\\lim" }, { asciimath: "Lim", tex: "\\operatorname{Lim}" }, { asciimath: "and", tex: "\\quad\\text{and}\\quad" }, { asciimath: "**", tex: "\\ast" }, { asciimath: "//", tex: "/" }, { asciimath: "\\", tex: "\\," }, { asciimath: "\\\\", tex: "\\backslash" }, { asciimath: "xx", tex: "\\times" }, { asciimath: "-:", tex: "\\div" }, { asciimath: "o+", tex: "\\oplus" }, { asciimath: "ox", tex: "\\otimes" }, { asciimath: "o.", tex: "\\odot" }, { asciimath: "^", tex: "\\hat{}" }, { asciimath: "_", tex: "\\_" }, { asciimath: "^^", tex: "\\wedge" }, { asciimath: "vv", tex: "\\vee" }, { asciimath: "nn", tex: "\\cap" }, { asciimath: "uu", tex: "\\cup" }, { asciimath: "TT", tex: "\\top" }, { asciimath: "+-", tex: "\\pm" }, { asciimath: "O/", tex: "\\emptyset" }, { asciimath: "oo", tex: "\\infty" }, { asciimath: ":.", tex: "\\therefore" }, { asciimath: ":'", tex: "\\because" }, { asciimath: "/_", tex: "\\angle" }, { asciimath: "|~", tex: "\\lceil" }, { asciimath: "~|", tex: "\\rceil" }, { asciimath: "CC", tex: "\\mathbb{C}" }, { asciimath: "NN", tex: "\\mathbb{N}" }, { asciimath: "QQ", tex: "\\mathbb{Q}" }, { asciimath: "RR", tex: "\\mathbb{R}" }, { asciimath: "ZZ", tex: "\\mathbb{Z}" }, { asciimath: "->", tex: "\\to" }, { asciimath: "or", tex: "\\quad\\text{or}\\quad" }, { asciimath: "if", tex: "\\quad\\text{if}\\quad" }, { asciimath: "iff", tex: "\\iff" }, { asciimath: "*", tex: "\\cdot" }, { asciimath: "@", tex: "\\circ" }, { asciimath: "%", tex: "\\%" }, { asciimath: "boxempty", tex: "\\square" }, { asciimath: "lambda", tex: "\\lambda" }, { asciimath: "Lambda", tex: "\\Lambda" }, { asciimath: "nabla", tex: "\\nabla" }, { asciimath: "uparrow", tex: "\\uparrow" }, { asciimath: "downarrow", tex: "\\downarrow" }, { asciimath: "twoheadrightarrowtail", tex: "\\twoheadrightarrowtail" }, { asciimath: "ltimes", tex: "\\ltimes" }, { asciimath: "rtimes", tex: "\\rtimes" }, { asciimath: "neg", tex: "\\neg" }, { asciimath: "partial", tex: "\\partial" }, { asciimath: "ldots", tex: "\\ldots" }, { asciimath: "triangle", tex: "\\triangle" }, { asciimath: "lfloor", tex: "\\lfloor" }, { asciimath: "rfloor", tex: "\\rfloor" }, { asciimath: "rightarrowtail", tex: "\\rightarrowtail" }, { asciimath: "twoheadrightarrow", tex: "\\twoheadrightarrow" }, { asciimath: "mapsto", tex: "\\mapsto" }, { asciimath: "times", tex: "\\times" }, { asciimath: "div", tex: "\\div" }, { asciimath: "divide", tex: "\\div" }, { asciimath: "oplus", tex: "\\oplus" }, { asciimath: "otimes", tex: "\\otimes" }, { asciimath: "odot", tex: "\\odot" }, { asciimath: "wedge", tex: "\\wedge" }, { asciimath: "vee", tex: "\\vee" }, { asciimath: "top", tex: "\\top" }, { asciimath: "pm", tex: "\\pm" }, { asciimath: "emptyset", tex: "\\emptyset" }, { asciimath: "infty", tex: "\\infty" }, { asciimath: "therefore", tex: "\\therefore" }, { asciimath: "because", tex: "\\because" }, { asciimath: "lceil", tex: "\\lceil" }, { asciimath: "rceil", tex: "\\rceil" }, { asciimath: "to", tex: "\\to" }, { asciimath: "langle", tex: "\\langle" }, { asciimath: "lceiling", tex: "\\lceil" }, { asciimath: "rceiling", tex: "\\rceil" }, { asciimath: "max", tex: "\\max" }, { asciimath: "min", tex: "\\min" }, { asciimath: "prod", tex: "\\prod" }, { asciimath: "sum", tex: "\\sum" }], this.constants = this.constants.concat(this.relations), this.left_brackets = [{ asciimath: "langle", tex: "\\langle" }, { asciimath: "(:", tex: "\\langle" }, { asciimath: "<<", tex: "\\langle" }, { asciimath: "{:", tex: "." }, { asciimath: "(", tex: "(" }, { asciimath: "[", tex: "[" }, { asciimath: "|:", tex: "\\lvert" }, { asciimath: "{", tex: "\\lbrace" }, { asciimath: "lbrace", tex: "\\lbrace" }], this.right_brackets = [{ asciimath: "rangle", tex: "\\rangle" }, { asciimath: ":)", tex: "\\rangle" }, { asciimath: ">>", tex: "\\rangle" }, { asciimath: ":}", tex: ".", free_tex: ":\\}" }, { asciimath: ")", tex: ")" }, { asciimath: "]", tex: "]" }, { asciimath: ":|", tex: "\\rvert" }, { asciimath: "}", tex: "\\rbrace" }, { asciimath: "rbrace", tex: "\\rbrace" }], this.leftright_brackets = [{ asciimath: "|", left_tex: "\\lvert", right_tex: "\\rvert", free_tex: "|", mid_tex: "\\mid" }], this.unary_symbols = [{ asciimath: "sqrt", tex: "\\sqrt" }, { asciimath: "f", tex: "f", func: true }, { asciimath: "g", tex: "g", func: true }, { asciimath: "sin", tex: "\\sin", func: true }, { asciimath: "cos", tex: "\\cos", func: true }, { asciimath: "tan", tex: "\\tan", func: true }, { asciimath: "arcsin", tex: "\\arcsin", func: true }, { asciimath: "arccos", tex: "\\arccos", func: true }, { asciimath: "arctan", tex: "\\arctan", func: true }, { asciimath: "sinh", tex: "\\sinh", func: true }, { asciimath: "cosh", tex: "\\cosh", func: true }, { asciimath: "tanh", tex: "\\tanh", func: true }, { asciimath: "cot", tex: "\\cot", func: true }, { asciimath: "coth", tex: "\\coth", func: true }, { asciimath: "sech", tex: "\\operatorname{sech}", func: true }, { asciimath: "csch", tex: "\\operatorname{csch}", func: true }, { asciimath: "sec", tex: "\\sec", func: true }, { asciimath: "csc", tex: "\\csc", func: true }, { asciimath: "log", tex: "\\log", func: true }, { asciimath: "ln", tex: "\\ln", func: true }, { asciimath: "abs", rewriteleftright: ["|", "|"] }, { asciimath: "norm", rewriteleftright: ["\\|", "\\|"] }, { asciimath: "floor", rewriteleftright: ["\\lfloor", "\\rfloor"] }, { asciimath: "ceil", rewriteleftright: ["\\lceil", "\\rceil"] }, { asciimath: "Sin", tex: "\\Sin", func: true }, { asciimath: "Cos", tex: "\\Cos", func: true }, { asciimath: "Tan", tex: "\\Tan", func: true }, { asciimath: "Arcsin", tex: "\\Arcsin", func: true }, { asciimath: "Arccos", tex: "\\Arccos", func: true }, { asciimath: "Arctan", tex: "\\Arctan", func: true }, { asciimath: "Sinh", tex: "\\Sinh", func: true }, { asciimath: "Cosh", tex: "\\Cosh", func: true }, { asciimath: "Tanh", tex: "\\Tanh", func: true }, { asciimath: "Cot", tex: "\\Cot", func: true }, { asciimath: "Sec", tex: "\\Sec", func: true }, { asciimath: "Csc", tex: "\\Csc", func: true }, { asciimath: "Log", tex: "\\Log", func: true }, { asciimath: "Ln", tex: "\\Ln", func: true }, { asciimath: "Abs", tex: "\\Abs", rewriteleftright: ["|", "|"] }, { asciimath: "det", tex: "\\det", func: true }, { asciimath: "exp", tex: "\\exp", func: true }, { asciimath: "gcd", tex: "\\gcd", func: true }, { asciimath: "lcm", tex: "\\operatorname{lcm}", func: true }, { asciimath: "cancel", tex: "\\cancel" }, { asciimath: "Sqrt", tex: "\\Sqrt" }, { asciimath: "hat", tex: "\\hat", acc: true }, { asciimath: "bar", tex: "\\overline", acc: true }, { asciimath: "overline", tex: "\\overline", acc: true }, { asciimath: "vec", tex: "\\vec", acc: true }, { asciimath: "tilde", tex: "\\tilde", acc: true }, { asciimath: "dot", tex: "\\dot", acc: true }, { asciimath: "ddot", tex: "\\ddot", acc: true }, { asciimath: "ul", tex: "\\underline", acc: true }, { asciimath: "underline", tex: "\\underline", acc: true }, { asciimath: "ubrace", tex: "\\underbrace", acc: true }, { asciimath: "underbrace", tex: "\\underbrace", acc: true }, { asciimath: "obrace", tex: "\\overbrace", acc: true }, { asciimath: "overbrace", tex: "\\overbrace", acc: true }, { asciimath: "bb", atname: "mathvariant", atval: "bold", tex: "\\mathbf" }, { asciimath: "mathbf", atname: "mathvariant", atval: "bold", tex: "mathbf" }, { asciimath: "sf", atname: "mathvariant", atval: "sans-serif", tex: "\\mathsf" }, { asciimath: "mathsf", atname: "mathvariant", atval: "sans-serif", tex: "mathsf" }, { asciimath: "bbb", atname: "mathvariant", atval: "double-struck", tex: "\\mathbb" }, { asciimath: "mathbb", atname: "mathvariant", atval: "double-struck", tex: "\\mathbb" }, { asciimath: "cc", atname: "mathvariant", atval: "script", tex: "\\mathcal" }, { asciimath: "mathcal", atname: "mathvariant", atval: "script", tex: "\\mathcal" }, { asciimath: "tt", atname: "mathvariant", atval: "monospace", tex: "\\mathtt" }, { asciimath: "mathtt", atname: "mathvariant", atval: "monospace", tex: "\\mathtt" }, { asciimath: "fr", atname: "mathvariant", atval: "fraktur", tex: "\\mathfrak" }, { asciimath: "mathfrak", atname: "mathvariant", atval: "fraktur", tex: "\\mathfrak" }], this.binary_symbols = [{ asciimath: "root", tex: "\\sqrt", option: true }, { asciimath: "frac", tex: "\\frac" }, { asciimath: "stackrel", tex: "\\stackrel" }, { asciimath: "overset", tex: "\\overset" }, { asciimath: "underset", tex: "\\underset" }, { asciimath: "color", tex: "\\color", rawfirst: true }], this.non_constant_symbols = ["_", "^", "/"];
  }, a2.sort_symbols = function() {
    var t3 = function(t4, e2) {
      return (t4 = t4.asciimath.length) > (e2 = e2.asciimath.length) ? -1 : t4 < e2 ? 1 : 0;
    };
    this.constants.sort(t3), this.relations.sort(t3), this.left_brackets.sort(t3), this.right_brackets.sort(t3), this.leftright_brackets.sort(t3), this.unary_symbols.sort(t3), this.binary_symbols.sort(t3);
  }, a2.error = function(t3, e2) {
    var a3 = this.source(e2).slice(0, 5);
    throw new Error("Error at character " + e2 + ' near "' + a3 + '": ' + t3);
  }, a2.literal = function(t3) {
    if (t3) return { tex: t3.token, pos: t3.pos, end: t3.end, ttype: "literal" };
  }, a2.longest = function(t3) {
    return (t3 = t3.filter(function(t4) {
      return !!t4;
    })).sort(function(t4, e2) {
      return (t4 = t4.end) > (e2 = e2.end) ? -1 : t4 < e2 ? 1 : 0;
    }), t3[0];
  }, a2.escape_text = function(t3) {
    return t3.replace(/\{/g, "\\{").replace(/\}/g, "\\}");
  }, a2.input = function(t3) {
    this._source = t3, this.brackets = [];
  }, a2.source = function(t3, e2) {
    return void 0 === t3 && (t3 = 0), arguments.length > 1 ? this._source.slice(t3, e2) : this._source.slice(t3);
  }, a2.eof = function(t3) {
    return void 0 === t3 && (t3 = 0), (t3 = this.strip_space(t3)) == this._source.length;
  }, a2.unbracket = function(t3) {
    if (t3) {
      if (!t3.bracket) return t3;
      var e2 = ["(", ")", "[", "]", "{", "}"], a3 = e2.includes(t3.left.asciimath), i = e2.includes(t3.right.asciimath), s = a3 ? "" : t3.left.tex, r = i ? "" : t3.right.tex, c = t3.middle ? t3.middle.tex : "";
      return s || r ? { tex: "\\left " + (s = s || ".") + " " + c + " \\right " + (r = r || "."), pos: t3.pos, end: t3.end } : { tex: c, pos: t3.pos, end: t3.end, middle_asciimath: this.source(a3 ? t3.left.end : t3.pos, i ? t3.right.pos : t3.end) };
    }
  }, a2.parse = function(t3) {
    return this.input(t3), this.consume().tex;
  }, a2.consume = function(t3) {
    void 0 === t3 && (t3 = 0);
    for (var e2 = "", a3 = []; !this.eof(t3); ) {
      var i = this.expression_list(t3);
      if (!i) {
        var s = this.right_bracket(t3);
        s && (s.def.free_tex && (s.tex = s.def.free_tex), i = s);
        var r = this.leftright_bracket(t3);
        if (r) {
          i = r;
          var c = this.subsup(r.end);
          c && (i = { tex: "" + i.tex + c.tex, pos: t3, end: c.end, ttype: "expression" });
        }
      }
      if (i) e2 && (e2 += " "), e2 += i.tex, t3 = i.end, a3.push(i);
      else if (!this.eof(t3)) {
        var n = this.source(t3, t3 + 1);
        a3.push({ tex: n, pos: t3, ttype: "character" }), e2 += n, t3 += 1;
      }
    }
    return { tex: e2, exprs: a3 };
  }, a2.strip_space = function(t3) {
    void 0 === t3 && (t3 = 0);
    var e2 = this.source(t3), a3 = e2.replace(/^(\s|\\(?![\\ ]))*/, "");
    return t3 + e2.length - a3.length;
  }, a2.match = function(t3, e2) {
    e2 = this.strip_space(e2);
    var a3 = t3.exec(this.source(e2));
    if (a3) {
      var i = a3[0];
      return { token: i, pos: e2, match: a3, end: e2 + i.length, ttype: "regex" };
    }
  }, a2.exact = function(t3, e2) {
    if (e2 = this.strip_space(e2), this.source(e2).slice(0, t3.length) == t3) return { token: t3, pos: e2, end: e2 + t3.length, ttype: "exact" };
  }, a2.expression_list = function(t3) {
    void 0 === t3 && (t3 = 0);
    var e2 = this.expression(t3);
    if (e2) {
      for (var a3 = e2.end, i = e2.tex, s = [e2]; !this.eof(a3); ) {
        var r = this.exact(",", a3);
        if (!r) break;
        if (i += " ,", !(e2 = this.expression(a3 = r.end))) break;
        i += " " + e2.tex, s.push(e2), a3 = e2.end;
      }
      return { tex: i, pos: t3, end: a3, exprs: s, ttype: "expression_list" };
    }
  }, a2.expression = function(t3) {
    void 0 === t3 && (t3 = 0);
    var a3 = this.negative_expression(t3);
    if (a3) return a3;
    var i = this.intermediate_or_fraction(t3);
    if (i) {
      if (this.eof(i.end)) return i;
      var s = this.expression(i.end);
      return s ? { tex: i.tex + " " + s.tex, pos: i.pos, end: s.end, ttype: "expression", exprs: [i, s] } : i;
    }
    for (var r, c = e(this.non_constant_symbols); !(r = c()).done; ) {
      var n = r.value, h = this.exact(n, t3);
      if (h) return { tex: n, pos: t3, end: h.end, ttype: "constant" };
    }
  }, a2.negative_expression = function(t3) {
    void 0 === t3 && (t3 = 0);
    var e2 = this.exact("-", t3);
    if (e2 && !this.other_constant(t3)) {
      var a3 = this.expression(e2.end);
      return a3 ? { tex: "- " + a3.tex, pos: t3, end: a3.end, ttype: "negative_expression", dash: e2, expression: a3 } : { tex: "-", pos: t3, end: e2.end, ttype: "constant" };
    }
  }, a2.intermediate_or_fraction = function(t3) {
    void 0 === t3 && (t3 = 0);
    var e2 = this.intermediate(t3);
    if (e2) {
      var a3 = this.match(/^\/(?!\/)/, e2.end);
      if (a3) {
        var i = this.intermediate(a3.end);
        if (i) {
          var s = this.unbracket(e2), r = this.unbracket(i);
          return { tex: "\\frac{" + s.tex + "}{" + r.tex + "}", pos: e2.pos, end: i.end, ttype: "fraction", numerator: s, denominator: r, raw_numerator: e2, raw_denominator: i };
        }
        var c = this.unbracket(e2);
        return { tex: "\\frac{" + c.tex + "}{}", pos: e2.pos, end: a3.end, ttype: "fraction", numerator: c, denominator: null, raw_numerator: e2, raw_denominator: null };
      }
      return e2;
    }
  }, a2.intermediate = function(t3) {
    void 0 === t3 && (t3 = 0);
    var e2 = this.simple(t3);
    if (e2) {
      var a3 = this.subsup(e2.end);
      return a3 ? { tex: "" + e2.tex + a3.tex, pos: t3, end: a3.end, ttype: "intermediate", expression: e2, subsup: a3 } : e2;
    }
  }, a2.subsup = function(t3) {
    void 0 === t3 && (t3 = 0);
    var e2, a3, i = "", s = t3, r = this.exact("_", t3);
    r && ((e2 = this.unbracket(this.simple(r.end))) ? (i = i + "_{" + e2.tex + "}", s = e2.end) : (i += "_{}", s = r.end));
    var c = this.match(/^\^(?!\^)/, s);
    if (c && ((a3 = this.unbracket(this.simple(c.end))) ? (i = i + "^{" + a3.tex + "}", s = a3.end) : (i += "^{}", s = c.end)), r || c) return { tex: i, pos: t3, end: s, ttype: "subsup", sub: e2, sup: a3 };
  }, a2.simple = function(t3) {
    return void 0 === t3 && (t3 = 0), this.longest([this.matrix(t3), this.bracketed_expression(t3), this.binary(t3), this.constant(t3), this.text(t3), this.unary(t3), this.negative_simple(t3)]);
  }, a2.negative_simple = function(t3) {
    void 0 === t3 && (t3 = 0);
    var e2 = this.exact("-", t3);
    if (e2 && !this.other_constant(t3)) {
      var a3 = this.simple(e2.end);
      return a3 ? { tex: "- " + a3.tex, pos: t3, end: a3.end, ttype: "negative_simple", dash: e2, expr: a3 } : { tex: "-", pos: t3, end: e2.end, ttype: "constant" };
    }
  }, a2.matrix = function(t3) {
    void 0 === t3 && (t3 = 0);
    var e2 = this.left_bracket(t3), a3 = false;
    if (!e2) {
      if (!(e2 = this.leftright_bracket(t3, "left"))) return;
      a3 = true;
    }
    var i = this.matrix_contents(e2.end, a3);
    if (i) {
      var s = a3 ? this.leftright_bracket(i.end, "right") : this.right_bracket(i.end);
      if (s) {
        var r = i.rows.map(function(t4) {
          return t4.tex;
        }).join(" \\\\ ");
        return { tex: "\\left " + e2.tex + " " + (i.is_array ? "\\begin{array}{" + i.column_desc + "} " + r + " \\end{array}" : "\\begin{matrix} " + r + " \\end{matrix}") + " \\right " + s.tex, pos: t3, end: s.end, ttype: "matrix", rows: i.rows, left: e2, right: s };
      }
    }
  }, a2.matrix_contents = function(t3, e2) {
    void 0 === t3 && (t3 = 0), void 0 === e2 && (e2 = false);
    for (var a3 = [], i = t3, s = void 0, r = void 0, c = false; !this.eof(i) && !(e2 ? this.leftright_bracket(i) : this.right_bracket(i)); ) {
      if (a3.length) {
        var n = this.exact(",", i);
        if (!n) return;
        i = n.end;
      }
      var h = this.match(/^[(\[]/, i);
      if (!h) return;
      var o = [], m = [];
      for (i = h.end; !this.eof(i); ) {
        if (o.length) {
          var x = this.exact(",", i);
          if (!x) break;
          i = x.end;
        }
        var l = this.matrix_cell(i);
        if (!l) break;
        "column" == l.ttype ? (m.push("|"), c = true, null !== l.expr && (m.push("r"), o.push(l.expr))) : (m.push("r"), o.push(l)), i = l.end;
      }
      if (!o.length) return;
      if (void 0 === s) s = o.length;
      else if (o.length != s) return;
      var d = this.match(/^[)\]]/, i);
      if (!d) return;
      var u = m.join("");
      if (void 0 === r) r = u;
      else if (u != r) return;
      a3.push({ ttype: "row", tex: o.map(function(t4) {
        return t4.tex;
      }).join(" & "), pos: h.end, end: i, cells: o }), i = d.end;
    }
    if (!(void 0 === s || s <= 1 && a3.length <= 1)) return { rows: a3, end: i, column_desc: r, is_array: c };
  }, a2.matrix_cell = function(t3) {
    void 0 === t3 && (t3 = 0);
    var e2 = this.exact("|", t3);
    if (e2) {
      var a3 = this.expression(e2.end);
      if (!a3) return { ttype: "column", expr: null, pos: e2.pos, end: e2.end };
      var i = this.exact("|", a3.end);
      if (!i) return { ttype: "column", expr: a3, pos: e2.pos, end: a3.end };
      var s = this.expression(i.end);
      if (s) return { tex: "\\left \\lvert " + a3.tex + " \\right \\rvert " + s.text, pos: e2.pos, end: s.end, ttype: "expression", exprs: [a3, s] };
    }
    return this.expression(t3);
  }, a2.bracketed_expression = function(t3) {
    void 0 === t3 && (t3 = 0);
    var e2 = this.left_bracket(t3);
    if (e2) {
      var a3 = this.expression_list(e2.end);
      if (a3) {
        var i = this.mid_expression(e2, a3, t3);
        if (i) return i;
        var s = this.right_bracket(a3.end) || this.leftright_bracket(a3.end, "right");
        return s ? { tex: "\\left " + e2.tex + " " + a3.tex + " \\right " + s.tex, pos: t3, end: s.end, bracket: true, left: e2, right: s, middle: a3, ttype: "bracket" } : this.eof(a3.end) ? { tex: "\\left " + e2.tex + " " + a3.tex + " \\right.", pos: t3, end: a3.end, ttype: "bracket", left: e2, right: null, middle: a3 } : { tex: e2.tex + " " + a3.tex, pos: t3, end: a3.end, ttype: "expression", exprs: [e2, a3] };
      }
      var r = this.right_bracket(e2.end) || this.leftright_bracket(e2.end, "right");
      return r ? { tex: "\\left " + e2.tex + " \\right " + r.tex, pos: t3, end: r.end, bracket: true, left: e2, right: r, middle: null, ttype: "bracket" } : { tex: e2.tex, pos: t3, end: e2.end, ttype: "constant" };
    }
    if (!this.other_constant(t3)) {
      var c = this.leftright_bracket(t3, "left");
      if (c) {
        var n = this.expression_list(c.end);
        if (n) {
          var h = this.mid_expression(c, n, t3);
          if (h) return h;
          var o = this.leftright_bracket(n.end, "right") || this.right_bracket(n.end);
          if (o) return { tex: "\\left " + c.tex + " " + n.tex + " \\right " + o.tex, pos: t3, end: o.end, bracket: true, left: c, right: o, middle: n, ttype: "bracket" };
        }
      }
    }
  }, a2.mid_expression = function(t3, e2, a3) {
    if (1 == e2.exprs.length && "expression" == e2.exprs[0].ttype) {
      for (var i = [e2.exprs[0].exprs[0]], s = e2.exprs[0].exprs[1], r = e2.end; "expression" == s.ttype; ) {
        var c = s.exprs[0];
        if ("bracket" == (x = c).ttype && "leftright_bracket" == x.left.ttype) {
          s = c, r = c.end;
          break;
        }
        i.push(s.exprs[0]), s = s.exprs[1];
      }
      if ("fraction" == s.ttype && (r = (s = s.raw_numerator).end), "bracket" != s.ttype || "leftright_bracket" != s.left.ttype) return;
      var n = i.map(function(t4) {
        return t4.tex;
      }).join(" "), h = s.left, o = s.middle.exprs.map(function(t4) {
        return t4.tex;
      }).join(" "), m = s.right;
      return { tex: "\\left " + t3.tex + " " + n + " " + h.def.mid_tex + " " + o + " \\right " + m.tex, pos: a3, end: r, left: t3, right: m, middle: { tex: n + " " + h.def.mid_tex + " " + o, exprs: i.concat([h, s.middle]), pos: e2.pos, end: s.middle.end, ttype: "expression_list" } };
    }
    var x;
  }, a2.right_bracket = function(t3) {
    void 0 === t3 && (t3 = 0);
    for (var a3, i = e(this.right_brackets); !(a3 = i()).done; ) {
      var s = a3.value, r = this.exact(s.asciimath, t3);
      if (r) return { tex: s.tex, pos: t3, end: r.end, asciimath: s.asciimath, def: s, ttype: "right_bracket" };
    }
  }, a2.left_bracket = function(t3) {
    void 0 === t3 && (t3 = 0);
    for (var a3, i = e(this.left_brackets); !(a3 = i()).done; ) {
      var s = a3.value, r = this.exact(s.asciimath, t3);
      if (r) return { tex: s.tex, pos: t3, end: r.end, asciimath: s.asciimath, ttype: "left_bracket" };
    }
  }, a2.leftright_bracket = function(t3, a3) {
    void 0 === t3 && (t3 = 0);
    for (var i, s = e(this.leftright_brackets); !(i = s()).done; ) {
      var r = i.value, c = this.exact(r.asciimath, t3);
      if (c) return this.exact(",", c.end) ? { tex: r.free_tex, pos: t3, end: c.end, ttype: "binary" } : { tex: "left" == a3 ? r.left_tex : "right" == a3 ? r.right_tex : r.free_tex, pos: t3, end: c.end, ttype: "leftright_bracket", def: r };
    }
  }, a2.text = function(t3) {
    void 0 === t3 && (t3 = 0);
    var e2 = this.match(/^"([^"]*)"/, t3);
    if (e2) {
      var a3 = this.escape_text(e2.match[1]);
      return { tex: "\\text{" + a3 + "}", pos: t3, end: e2.end, ttype: "text", text: a3 };
    }
    var i = this.match(/^(?:mbox|text)\s*(\([^)]*\)?|\{[^}]*\}?|\[[^\]]*\]?)/, t3);
    if (i) {
      var s = this.escape_text(i.match[1].slice(1, i.match[1].length - 1));
      return { tex: "\\text{" + s + "}", pos: t3, end: i.end, ttype: "text", text: s };
    }
  }, a2.binary = function(t3) {
    void 0 === t3 && (t3 = 0);
    for (var a3, i = e(this.binary_symbols); !(a3 = i()).done; ) {
      var s = a3.value, r = this.exact(s.asciimath, t3), c = s.option ? ["[", "]"] : ["{", "}"], n = c[0], h = c[1];
      if (r) {
        var o = this.unbracket(this.simple(r.end));
        if (o) {
          var m = s.rawfirst ? o.middle_asciimath : o.tex, x = this.unbracket(this.simple(o.end));
          return x ? { tex: "" + s.tex + n + m + h + "{" + x.tex + "}", pos: t3, end: x.end, ttype: "binary", op: s, arg1: o, arg2: x } : { tex: "" + s.tex + n + m + h + "{}", pos: t3, end: o.end, ttype: "binary", op: s, arg1: o, arg2: null };
        }
        return { tex: "" + s.tex + n + h + "{}", pos: t3, end: r.end, ttype: "binary", op: s, arg1: null, arg2: null };
      }
    }
  }, a2.unary = function(t3) {
    void 0 === t3 && (t3 = 0);
    for (var a3, i = e(this.unary_symbols); !(a3 = i()).done; ) {
      var s = a3.value, r = this.exact(s.asciimath, t3);
      if (r) {
        var c = this.subsup(r.end), n = c ? c.tex : "", h = this.simple(c ? c.end : r.end), o = s.func ? h : this.unbracket(h), m = o && (s.raw ? o.middle_asciimath : o.tex);
        if (s.rewriteleftright) {
          var x = s.rewriteleftright, l = x[0], d = x[1];
          return o ? { tex: "\\left " + l + " " + m + " \\right " + d + " " + n, pos: t3, end: o.end, ttype: "unary", op: r, subsup: c, arg: o } : { tex: "\\left " + l + " \\right " + d + " " + n, pos: t3, end: r.end, ttype: "unary", op: r, subsup: c, arg: null };
        }
        return o ? { tex: "" + s.tex + n + "{" + m + "}", pos: t3, end: o.end, ttype: "unary", op: r, subsup: c, arg: o } : { tex: "" + s.tex + n + "{}", pos: t3, end: r.end, ttype: "unary", op: r, subsup: c, arg: null };
      }
    }
  }, a2.constant = function(t3) {
    if (void 0 === t3 && (t3 = 0), !this.right_bracket(t3)) return this.longest([this.other_constant(t3), this.greek(t3), this.name(t3), this.number(t3), this.arbitrary_constant(t3)]);
  }, a2.name = function(t3) {
    return void 0 === t3 && (t3 = 0), this.literal(this.match(/^[A-Za-z]/, t3));
  }, a2.greek = function(t3) {
    void 0 === t3 && (t3 = 0);
    var e2 = new RegExp("^(" + this.greek_letters.join("|") + ")"), a3 = this.match(e2, t3);
    if (a3) return { tex: "\\" + a3.token, pos: t3, end: a3.end, ttype: "greek" };
  }, a2.number = function(t3) {
    void 0 === t3 && (t3 = 0);
    var e2 = new RegExp("^\\d+(" + this.decimalsign + "\\d+)?");
    return this.literal(this.match(e2, t3));
  }, a2.other_constant = function(t3) {
    void 0 === t3 && (t3 = 0);
    for (var a3, i = e(this.constants); !(a3 = i()).done; ) {
      var s = a3.value, r = this.exact(s.asciimath, t3);
      if (r) return { tex: "" + s.tex, pos: r.pos, end: r.end, ttype: "other_constant" };
    }
    for (var c, n = e(this.relations); !(c = n()).done; ) {
      var h = c.value;
      if (!h.asciimath.match(/^!/)) {
        var o = this.exact("!" + h.asciimath, t3);
        if (o) return { tex: "\\not " + h.tex, pos: o.pos, end: o.end, ttype: "other_constant" };
      }
    }
  }, a2.arbitrary_constant = function(t3) {
    if (void 0 === t3 && (t3 = 0), !this.eof(t3)) {
      if (this.exact(",", t3)) return;
      for (var a3, i = e(this.non_constant_symbols.concat(this.left_brackets.map(function(t4) {
        return t4.asciimath;
      }), this.right_brackets.map(function(t4) {
        return t4.asciimath;
      }), this.leftright_brackets.map(function(t4) {
        return t4.asciimath;
      }))); !(a3 = i()).done; ) if (this.exact(a3.value, t3)) return;
      var s = this.strip_space(t3);
      return { tex: this.source(s).slice(0, 1), pos: t3, end: s + 1, ttype: "arbitrary_constant" };
    }
  }, t2;
}();
export {
  a as default
};
//# sourceMappingURL=asciimath2tex.js.map
