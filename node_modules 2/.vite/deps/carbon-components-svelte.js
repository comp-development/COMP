import "./chunk-EEV5BAJJ.js";
import {
  fade,
  slide
} from "./chunk-OUO7JNRQ.js";
import "./chunk-RIXFT5AQ.js";
import {
  esm_default
} from "./chunk-FRJD3XQL.js";
import "./chunk-TJJXFKJG.js";
import "./chunk-JKL4VOXC.js";
import {
  add_locations,
  afterUpdate,
  append_styles,
  beforeUpdate,
  bind_prop,
  bind_this,
  bind_value,
  bind_window_size,
  bubble_event,
  check_target,
  cleanup_styles,
  component,
  createEventDispatcher,
  derived as derived2,
  each,
  get as get2,
  handle_lazy_img,
  hmr,
  html,
  if_block,
  index,
  init,
  init_select,
  key_block,
  legacy_api,
  legacy_rest_props,
  log_if_contains_state,
  onMount,
  prop,
  readable,
  readonly,
  remove_input_defaults,
  sanitize_slots,
  select_option,
  set_attribute,
  set_attributes,
  set_checked,
  set_class,
  set_selected,
  set_style,
  set_value,
  setup_stores,
  slot,
  spread_props,
  store_get,
  store_set,
  toggle_class,
  transition,
  update_prop,
  validate_each_keys,
  validate_store,
  wrap_snippet,
  writable
} from "./chunk-GHWC7UCX.js";
import "./chunk-U7P2NEEE.js";
import {
  append,
  comment,
  head,
  ns_template,
  preventDefault,
  set_text,
  stopPropagation,
  template,
  text
} from "./chunk-2Y5BGJMR.js";
import {
  $window,
  FILENAME,
  HMR,
  add_owner_effect,
  child,
  deep_read_state,
  derived,
  derived_safe_equal,
  equals,
  event as event2,
  first_child,
  get,
  getContext,
  invalid_default_snippet,
  legacy_pre_effect,
  legacy_pre_effect_reset,
  mark_module_end,
  mark_module_start,
  mutable_state,
  mutate,
  next,
  pop,
  push,
  remove_textarea_child,
  replay_events,
  reset,
  set,
  setContext,
  sibling,
  strict_equals,
  template_effect,
  tick,
  update
} from "./chunk-F2AP5C63.js";
import "./chunk-NUQPLINK.js";
import "./chunk-HNWPC2PS.js";
import "./chunk-RVAV4ZRS.js";
import "./chunk-BFCEFRYA.js";

// node_modules/carbon-components-svelte/src/icons/ChevronRight.svelte
mark_module_start();
ChevronRight[FILENAME] = "node_modules/carbon-components-svelte/src/icons/ChevronRight.svelte";
var root_1 = add_locations(ns_template(`<title> </title>`), ChevronRight[FILENAME], [[24, 13]]);
var root = add_locations(ns_template(`<svg><!><path d="M22 16L12 26 10.6 24.6 19.2 16 10.6 7.4 12 6z"></path></svg>`), ChevronRight[FILENAME], [[14, 0, [[25, 2]]]]);
function ChevronRight($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, ChevronRight);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next();
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChevronRight = hmr(ChevronRight, () => ChevronRight[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronRight[HMR].source;
    set(ChevronRight[HMR].source, module.default[HMR].original);
  });
}
var ChevronRight_default = ChevronRight;
mark_module_end(ChevronRight);

// node_modules/carbon-components-svelte/src/SkeletonText/SkeletonText.svelte
mark_module_start();
SkeletonText[FILENAME] = "node_modules/carbon-components-svelte/src/SkeletonText/SkeletonText.svelte";
var root_2 = add_locations(template(`<p></p>`), SkeletonText[FILENAME], [[31, 6]]);
var root_12 = add_locations(template(`<div></div>`), SkeletonText[FILENAME], [[23, 2]]);
var root_3 = add_locations(template(`<p></p>`), SkeletonText[FILENAME], [[40, 2]]);
function SkeletonText($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["lines", "heading", "paragraph", "width"]);
  push($$props, false, SkeletonText);
  const widthNum = mutable_state();
  const widthPx = mutable_state();
  let lines = prop($$props, "lines", 8, 3);
  let heading = prop($$props, "heading", 8, false);
  let paragraph = prop($$props, "paragraph", 8, false);
  let width = prop($$props, "width", 8, "100%");
  const RANDOM = [0.973, 0.153, 0.567];
  legacy_pre_effect(() => deep_read_state(width()), () => {
    set(widthNum, parseInt(width(), 10));
  });
  legacy_pre_effect(() => deep_read_state(width()), () => {
    set(widthPx, width().includes("px"));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_12();
      let attributes;
      each(
        div,
        5,
        () => Array.from({ length: lines() }).map((_, i) => {
          const min = get(widthPx) ? get(widthNum) - 75 : 0;
          const max = get(widthPx) ? get(widthNum) : 75;
          const rand = Math.floor(RANDOM[i % 3] * (max - min + 1)) + min + "px";
          return get(widthPx) ? rand : `calc(${width()} - ${rand})`;
        }),
        index,
        ($$anchor3, width2, $$index, $$array) => {
          var p = root_2();
          toggle_class(p, "bx--skeleton__text", true);
          template_effect(() => {
            toggle_class(p, "bx--skeleton__heading", heading());
            set_style(p, "width", get(width2));
          });
          append($$anchor3, p);
        }
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps }));
      event2("click", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseover", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseenter", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseleave", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, div);
    };
    var alternate = ($$anchor2) => {
      var p_1 = root_3();
      let attributes_1;
      template_effect(() => {
        attributes_1 = set_attributes(p_1, attributes_1, { ...$$restProps });
        toggle_class(p_1, "bx--skeleton__text", true);
        toggle_class(p_1, "bx--skeleton__heading", heading());
        set_style(p_1, "width", width());
      });
      event2("click", p_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseover", p_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseenter", p_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseleave", p_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, p_1);
    };
    if_block(node, ($$render) => {
      if (paragraph()) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SkeletonText = hmr(SkeletonText, () => SkeletonText[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SkeletonText[HMR].source;
    set(SkeletonText[HMR].source, module.default[HMR].original);
  });
}
var SkeletonText_default = SkeletonText;
mark_module_end(SkeletonText);

// node_modules/carbon-components-svelte/src/Accordion/AccordionSkeleton.svelte
mark_module_start();
AccordionSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/Accordion/AccordionSkeleton.svelte";
var root_13 = add_locations(template(`<li><span><!> <!></span> <div><!> <!> <!></div></li>`), AccordionSkeleton[FILENAME], [[40, 4, [[44, 6], [48, 6]]]]);
var root_22 = add_locations(template(`<li><span><!> <!></span></li>`), AccordionSkeleton[FILENAME], [[56, 4, [[57, 6]]]]);
var root2 = add_locations(template(`<ul><!> <!></ul>`), AccordionSkeleton[FILENAME], [[26, 0]]);
function AccordionSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["count", "align", "size", "open"]);
  push($$props, false, AccordionSkeleton);
  let count = prop($$props, "count", 8, 4);
  let align = prop($$props, "align", 8, "end");
  let size = prop($$props, "size", 8, void 0);
  let open = prop($$props, "open", 8, true);
  var ul = root2();
  let attributes;
  var node = child(ul);
  {
    var consequent = ($$anchor2) => {
      var li = root_13();
      toggle_class(li, "bx--accordion__item", true);
      toggle_class(li, "bx--accordion__item--active", true);
      var span = child(li);
      toggle_class(span, "bx--accordion__heading", true);
      var node_1 = child(span);
      ChevronRight_default(node_1, { class: "bx--accordion__arrow" });
      var node_2 = sibling(node_1, 2);
      SkeletonText_default(node_2, { class: "bx--accordion__title" });
      reset(span);
      var div = sibling(span, 2);
      toggle_class(div, "bx--accordion__content", true);
      var node_3 = child(div);
      SkeletonText_default(node_3, { width: "90%" });
      var node_4 = sibling(node_3, 2);
      SkeletonText_default(node_4, { width: "80%" });
      var node_5 = sibling(node_4, 2);
      SkeletonText_default(node_5, { width: "95%" });
      reset(div);
      reset(li);
      append($$anchor2, li);
    };
    if_block(node, ($$render) => {
      if (open()) $$render(consequent);
    });
  }
  var node_6 = sibling(node, 2);
  validate_each_keys(
    () => Array.from(
      {
        length: open() ? count() - 1 : count()
      },
      (_, i) => i
    ),
    (item) => item
  );
  each(
    node_6,
    1,
    () => Array.from(
      {
        length: open() ? count() - 1 : count()
      },
      (_, i) => i
    ),
    (item) => item,
    ($$anchor2, item) => {
      var li_1 = root_22();
      toggle_class(li_1, "bx--accordion__item", true);
      var span_1 = child(li_1);
      toggle_class(span_1, "bx--accordion__heading", true);
      var node_7 = child(span_1);
      ChevronRight_default(node_7, { class: "bx--accordion__arrow" });
      var node_8 = sibling(node_7, 2);
      SkeletonText_default(node_8, { class: "bx--accordion__title" });
      reset(span_1);
      reset(li_1);
      append($$anchor2, li_1);
    }
  );
  reset(ul);
  template_effect(() => {
    attributes = set_attributes(ul, attributes, { ...$$restProps });
    toggle_class(ul, "bx--skeleton", true);
    toggle_class(ul, "bx--accordion", true);
    toggle_class(ul, "bx--accordion--start", strict_equals(align(), "start"));
    toggle_class(ul, "bx--accordion--end", strict_equals(align(), "end"));
    toggle_class(ul, "bx--accordion--sm", strict_equals(size(), "sm"));
    toggle_class(ul, "bx--accordion--xl", strict_equals(size(), "xl"));
  });
  event2("click", ul, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", ul, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", ul, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", ul, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, ul);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AccordionSkeleton = hmr(AccordionSkeleton, () => AccordionSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AccordionSkeleton[HMR].source;
    set(AccordionSkeleton[HMR].source, module.default[HMR].original);
  });
}
var AccordionSkeleton_default = AccordionSkeleton;
mark_module_end(AccordionSkeleton);

// node_modules/carbon-components-svelte/src/Accordion/Accordion.svelte
mark_module_start();
Accordion[FILENAME] = "node_modules/carbon-components-svelte/src/Accordion/Accordion.svelte";
var root_23 = add_locations(template(`<ul><!></ul>`), Accordion[FILENAME], [[46, 2]]);
function Accordion($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["align", "size", "disabled", "skeleton"]);
  push($$props, false, Accordion);
  let align = prop($$props, "align", 8, "end");
  let size = prop($$props, "size", 8, void 0);
  let disabled = prop($$props, "disabled", 8, false);
  let skeleton = prop($$props, "skeleton", 8, false);
  const disableItems = writable(disabled());
  setContext("Accordion", { disableItems });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    disableItems.set(disabled());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      AccordionSkeleton_default(node_1, spread_props(() => $$restProps, {
        get align() {
          return align();
        },
        get size() {
          return size();
        },
        $$events: {
          click($$arg) {
            bubble_event.call(this, $$props, $$arg);
          },
          mouseover($$arg) {
            bubble_event.call(this, $$props, $$arg);
          },
          mouseenter($$arg) {
            bubble_event.call(this, $$props, $$arg);
          },
          mouseleave($$arg) {
            bubble_event.call(this, $$props, $$arg);
          }
        }
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var ul = root_23();
      let attributes;
      var node_2 = child(ul);
      slot(node_2, $$props, "default", {}, null);
      reset(ul);
      template_effect(() => {
        attributes = set_attributes(ul, attributes, { ...$$restProps });
        toggle_class(ul, "bx--accordion", true);
        toggle_class(ul, "bx--accordion--start", strict_equals(align(), "start"));
        toggle_class(ul, "bx--accordion--end", strict_equals(align(), "end"));
        toggle_class(ul, "bx--accordion--sm", strict_equals(size(), "sm"));
        toggle_class(ul, "bx--accordion--xl", strict_equals(size(), "xl"));
      });
      event2("click", ul, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseover", ul, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseenter", ul, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseleave", ul, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, ul);
    };
    if_block(node, ($$render) => {
      if (skeleton()) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Accordion = hmr(Accordion, () => Accordion[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Accordion[HMR].source;
    set(Accordion[HMR].source, module.default[HMR].original);
  });
}
var Accordion_default = Accordion;
mark_module_end(Accordion);

// node_modules/carbon-components-svelte/src/Accordion/AccordionItem.svelte
mark_module_start();
AccordionItem[FILENAME] = "node_modules/carbon-components-svelte/src/Accordion/AccordionItem.svelte";
var root3 = add_locations(template(`<li><button type="button"><!> <div><!></div></button> <div><!></div></li>`), AccordionItem[FILENAME], [
  [
    38,
    0,
    [[50, 2, [[72, 4]]], [76, 2]]
  ]
]);
function AccordionItem($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "title",
    "open",
    "disabled",
    "iconDescription"
  ]);
  push($$props, false, AccordionItem);
  let title = prop($$props, "title", 8, "title");
  let open = prop($$props, "open", 12, false);
  let disabled = prop($$props, "disabled", 12, false);
  let iconDescription = prop($$props, "iconDescription", 8, "Expand/Collapse");
  let initialDisabled = disabled();
  const ctx = getContext("Accordion");
  const unsubscribe = ctx.disableItems.subscribe((value) => {
    if (!value && initialDisabled) return;
    disabled(value);
  });
  let animation = mutable_state(void 0);
  onMount(() => {
    return () => {
      unsubscribe();
    };
  });
  init();
  var li = root3();
  let attributes;
  var button = child(li);
  var node = child(button);
  ChevronRight_default(node, {
    class: "bx--accordion__arrow",
    get "aria-label"() {
      return iconDescription();
    }
  });
  var div = sibling(node, 2);
  toggle_class(div, "bx--accordion__title", true);
  var node_1 = child(div);
  slot(node_1, $$props, "title", {}, ($$anchor2) => {
    var text2 = text();
    template_effect(() => set_text(text2, title()));
    append($$anchor2, text2);
  });
  reset(div);
  reset(button);
  var div_1 = sibling(button, 2);
  toggle_class(div_1, "bx--accordion__content", true);
  var node_2 = child(div_1);
  slot(node_2, $$props, "default", {}, null);
  reset(div_1);
  reset(li);
  template_effect(() => {
    attributes = set_attributes(li, attributes, { ...$$restProps });
    toggle_class(li, "bx--accordion__item", true);
    toggle_class(li, "bx--accordion__item--active", open());
    toggle_class(li, "bx--accordion__item--disabled", disabled());
    toggle_class(li, "bx--accordion__item--expanding", strict_equals(get(animation), "expanding"));
    toggle_class(li, "bx--accordion__item--collapsing", strict_equals(get(animation), "collapsing"));
    set_attribute(button, "title", iconDescription());
    set_attribute(button, "aria-expanded", open());
    button.disabled = disabled();
    toggle_class(button, "bx--accordion__heading", true);
  });
  event2("click", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", button, () => {
    open(!open());
    set(animation, open() ? "expanding" : "collapsing");
  });
  event2("mouseover", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", button, ({ key }) => {
    if (open() && strict_equals(key, "Escape")) {
      open(false);
    }
  });
  event2("animationend", li, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("animationend", li, () => {
    set(animation, void 0);
  });
  append($$anchor, li);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AccordionItem = hmr(AccordionItem, () => AccordionItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AccordionItem[HMR].source;
    set(AccordionItem[HMR].source, module.default[HMR].original);
  });
}
var AccordionItem_default = AccordionItem;
mark_module_end(AccordionItem);

// node_modules/carbon-components-svelte/src/AspectRatio/AspectRatio.svelte
mark_module_start();
AspectRatio[FILENAME] = "node_modules/carbon-components-svelte/src/AspectRatio/AspectRatio.svelte";
var root4 = add_locations(template(`<div><div><!></div></div>`), AspectRatio[FILENAME], [[9, 0, [[22, 2]]]]);
function AspectRatio($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["ratio"]);
  push($$props, false, AspectRatio);
  let ratio = prop($$props, "ratio", 8, "2x1");
  var div = root4();
  let attributes;
  var div_1 = child(div);
  toggle_class(div_1, "bx--aspect-ratio--object", true);
  var node = child(div_1);
  slot(node, $$props, "default", {}, null);
  reset(div_1);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--aspect-ratio", true);
    toggle_class(div, "bx--aspect-ratio--2x1", strict_equals(ratio(), "2x1"));
    toggle_class(div, "bx--aspect-ratio--2x3", strict_equals(ratio(), "2x3"));
    toggle_class(div, "bx--aspect-ratio--16x9", strict_equals(ratio(), "16x9"));
    toggle_class(div, "bx--aspect-ratio--4x3", strict_equals(ratio(), "4x3"));
    toggle_class(div, "bx--aspect-ratio--1x1", strict_equals(ratio(), "1x1"));
    toggle_class(div, "bx--aspect-ratio--3x4", strict_equals(ratio(), "3x4"));
    toggle_class(div, "bx--aspect-ratio--3x2", strict_equals(ratio(), "3x2"));
    toggle_class(div, "bx--aspect-ratio--9x16", strict_equals(ratio(), "9x16"));
    toggle_class(div, "bx--aspect-ratio--1x2", strict_equals(ratio(), "1x2"));
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AspectRatio = hmr(AspectRatio, () => AspectRatio[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AspectRatio[HMR].source;
    set(AspectRatio[HMR].source, module.default[HMR].original);
  });
}
var AspectRatio_default = AspectRatio;
mark_module_end(AspectRatio);

// node_modules/carbon-components-svelte/src/Breadcrumb/BreadcrumbSkeleton.svelte
mark_module_start();
BreadcrumbSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/Breadcrumb/BreadcrumbSkeleton.svelte";
var root_14 = add_locations(template(`<div><span>&nbsp;</span></div>`), BreadcrumbSkeleton[FILENAME], [[22, 4, [[23, 6]]]]);
var root5 = add_locations(template(`<div></div>`), BreadcrumbSkeleton[FILENAME], [[11, 0]]);
function BreadcrumbSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["noTrailingSlash", "count"]);
  push($$props, false, BreadcrumbSkeleton);
  let noTrailingSlash = prop($$props, "noTrailingSlash", 8, false);
  let count = prop($$props, "count", 8, 3);
  var div = root5();
  let attributes;
  validate_each_keys(() => Array.from({ length: count() }, (_, i) => i), (item) => item);
  each(div, 5, () => Array.from({ length: count() }, (_, i) => i), (item) => item, ($$anchor2, item) => {
    var div_1 = root_14();
    toggle_class(div_1, "bx--breadcrumb-item", true);
    var span = child(div_1);
    toggle_class(span, "bx--link", true);
    reset(div_1);
    append($$anchor2, div_1);
  });
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--skeleton", true);
    toggle_class(div, "bx--breadcrumb", true);
    toggle_class(div, "bx--breadcrumb--no-trailing-slash", noTrailingSlash());
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BreadcrumbSkeleton = hmr(BreadcrumbSkeleton, () => BreadcrumbSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BreadcrumbSkeleton[HMR].source;
    set(BreadcrumbSkeleton[HMR].source, module.default[HMR].original);
  });
}
var BreadcrumbSkeleton_default = BreadcrumbSkeleton;
mark_module_end(BreadcrumbSkeleton);

// node_modules/carbon-components-svelte/src/Breadcrumb/Breadcrumb.svelte
mark_module_start();
Breadcrumb[FILENAME] = "node_modules/carbon-components-svelte/src/Breadcrumb/Breadcrumb.svelte";
var root_24 = add_locations(template(`<nav><ol><!></ol></nav>`), Breadcrumb[FILENAME], [[25, 2, [[33, 4]]]]);
function Breadcrumb($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["noTrailingSlash", "skeleton"]);
  push($$props, false, Breadcrumb);
  let noTrailingSlash = prop($$props, "noTrailingSlash", 8, false);
  let skeleton = prop($$props, "skeleton", 8, false);
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      BreadcrumbSkeleton_default(node_1, spread_props(
        {
          get noTrailingSlash() {
            return noTrailingSlash();
          }
        },
        () => $$restProps,
        {
          $$events: {
            click($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            mouseover($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            mouseenter($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            mouseleave($$arg) {
              bubble_event.call(this, $$props, $$arg);
            }
          }
        }
      ));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var nav = root_24();
      let attributes;
      var ol = child(nav);
      toggle_class(ol, "bx--breadcrumb", true);
      var node_2 = child(ol);
      slot(node_2, $$props, "default", {}, null);
      reset(ol);
      reset(nav);
      template_effect(() => {
        attributes = set_attributes(nav, attributes, { "aria-label": "Breadcrumb", ...$$restProps });
        toggle_class(ol, "bx--breadcrumb--no-trailing-slash", noTrailingSlash());
      });
      event2("click", nav, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseover", nav, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseenter", nav, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseleave", nav, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, nav);
    };
    if_block(node, ($$render) => {
      if (skeleton()) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Breadcrumb = hmr(Breadcrumb, () => Breadcrumb[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Breadcrumb[HMR].source;
    set(Breadcrumb[HMR].source, module.default[HMR].original);
  });
}
var Breadcrumb_default = Breadcrumb;
mark_module_end(Breadcrumb);

// node_modules/carbon-components-svelte/src/Link/Link.svelte
mark_module_start();
Link[FILENAME] = "node_modules/carbon-components-svelte/src/Link/Link.svelte";
var root_25 = add_locations(template(`<div><!></div>`), Link[FILENAME], [[56, 6]]);
var root_15 = add_locations(template(`<a><!> <!></a>`), Link[FILENAME], [[40, 2]]);
var root_5 = add_locations(template(`<div><!></div>`), Link[FILENAME], [[82, 6]]);
var root_4 = add_locations(template(`<a><!> <!></a>`), Link[FILENAME], [[64, 2]]);
function Link($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "size",
    "href",
    "inline",
    "icon",
    "disabled",
    "visited",
    "ref"
  ]);
  push($$props, false, Link);
  let size = prop($$props, "size", 8, void 0);
  let href = prop($$props, "href", 8, void 0);
  let inline = prop($$props, "inline", 8, false);
  let icon = prop($$props, "icon", 8, void 0);
  let disabled = prop($$props, "disabled", 8, false);
  let visited = prop($$props, "visited", 8, false);
  let ref = prop($$props, "ref", 12, null);
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var a = root_15();
      let attributes;
      var node_1 = child(a);
      slot(node_1, $$props, "default", {}, null);
      var node_2 = sibling(node_1, 2);
      {
        var consequent = ($$anchor3) => {
          var div = root_25();
          toggle_class(div, "bx--link__icon", true);
          var node_3 = child(div);
          slot(node_3, $$props, "icon", {}, ($$anchor4) => {
            var fragment_1 = comment();
            var node_4 = first_child(fragment_1);
            component(node_4, icon, ($$anchor5, $$component) => {
              $$component($$anchor5, {});
            });
            append($$anchor4, fragment_1);
          });
          reset(div);
          append($$anchor3, div);
        };
        if_block(node_2, ($$render) => {
          if (!inline() && ($$slots.icon || icon())) $$render(consequent);
        });
      }
      reset(a);
      bind_this(a, ($$value) => ref($$value), () => ref());
      template_effect(() => {
        attributes = set_attributes(a, attributes, {
          role: "link",
          "aria-disabled": "true",
          ...$$restProps
        });
        toggle_class(a, "bx--link", true);
        toggle_class(a, "bx--link--disabled", disabled());
        toggle_class(a, "bx--link--inline", inline());
        toggle_class(a, "bx--link--visited", visited());
      });
      event2("click", a, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseover", a, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseenter", a, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseleave", a, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, a);
    };
    var alternate = ($$anchor2) => {
      var a_1 = root_4();
      let attributes_1;
      var node_5 = child(a_1);
      slot(node_5, $$props, "default", {}, null);
      var node_6 = sibling(node_5, 2);
      {
        var consequent_2 = ($$anchor3) => {
          var div_1 = root_5();
          toggle_class(div_1, "bx--link__icon", true);
          var node_7 = child(div_1);
          slot(node_7, $$props, "icon", {}, ($$anchor4) => {
            var fragment_2 = comment();
            var node_8 = first_child(fragment_2);
            component(node_8, icon, ($$anchor5, $$component) => {
              $$component($$anchor5, {});
            });
            append($$anchor4, fragment_2);
          });
          reset(div_1);
          append($$anchor3, div_1);
        };
        if_block(node_6, ($$render) => {
          if (!inline() && ($$slots.icon || icon())) $$render(consequent_2);
        });
      }
      reset(a_1);
      bind_this(a_1, ($$value) => ref($$value), () => ref());
      template_effect(() => {
        attributes_1 = set_attributes(a_1, attributes_1, {
          rel: strict_equals($$restProps.target, "_blank") ? "noopener noreferrer" : void 0,
          href: href(),
          ...$$restProps
        });
        toggle_class(a_1, "bx--link", true);
        toggle_class(a_1, "bx--link--disabled", disabled());
        toggle_class(a_1, "bx--link--inline", inline());
        toggle_class(a_1, "bx--link--visited", visited());
        toggle_class(a_1, "bx--link--sm", strict_equals(size(), "sm"));
        toggle_class(a_1, "bx--link--lg", strict_equals(size(), "lg"));
      });
      event2("click", a_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseover", a_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseenter", a_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseleave", a_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, a_1);
    };
    if_block(node, ($$render) => {
      if (disabled()) $$render(consequent_1);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Link = hmr(Link, () => Link[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Link[HMR].source;
    set(Link[HMR].source, module.default[HMR].original);
  });
}
var Link_default = Link;
mark_module_end(Link);

// node_modules/carbon-components-svelte/src/Breadcrumb/BreadcrumbItem.svelte
mark_module_start();
BreadcrumbItem[FILENAME] = "node_modules/carbon-components-svelte/src/Breadcrumb/BreadcrumbItem.svelte";
var root6 = add_locations(template(`<li><!></li>`), BreadcrumbItem[FILENAME], [[24, 0]]);
function BreadcrumbItem($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["href", "isCurrentPage"]);
  push($$props, false, BreadcrumbItem);
  let href = prop($$props, "href", 8, void 0);
  let isCurrentPage = prop($$props, "isCurrentPage", 8, false);
  setContext("BreadcrumbItem", {});
  init();
  var li = root6();
  let attributes;
  var node = child(li);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      Link_default(node_1, {
        get href() {
          return href();
        },
        get "aria-current"() {
          return $$restProps["aria-current"];
        },
        children: wrap_snippet(BreadcrumbItem, ($$anchor3, $$slotProps) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          slot(node_2, $$props, "default", {}, null);
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      });
      append($$anchor2, fragment);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      slot(
        node_3,
        $$props,
        "default",
        {
          get props() {
            return {
              "aria-current": $$restProps["aria-current"],
              class: "bx--link"
            };
          }
        },
        null
      );
      append($$anchor2, fragment_2);
    };
    if_block(node, ($$render) => {
      if (href()) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  reset(li);
  template_effect(() => {
    attributes = set_attributes(li, attributes, { ...$$restProps });
    toggle_class(li, "bx--breadcrumb-item", true);
    toggle_class(li, "bx--breadcrumb-item--current", isCurrentPage() && strict_equals($$restProps["aria-current"], "page", false));
  });
  event2("click", li, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", li, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", li, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", li, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, li);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BreadcrumbItem = hmr(BreadcrumbItem, () => BreadcrumbItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BreadcrumbItem[HMR].source;
    set(BreadcrumbItem[HMR].source, module.default[HMR].original);
  });
}
var BreadcrumbItem_default = BreadcrumbItem;
mark_module_end(BreadcrumbItem);

// node_modules/carbon-components-svelte/src/Breakpoint/breakpoints.js
var breakpoints = Object.freeze({
  sm: 320,
  md: 672,
  lg: 1056,
  xlg: 1312,
  max: 1584
});
var breakpoints_default = breakpoints;

// node_modules/carbon-components-svelte/src/Breakpoint/breakpointObserver.js
function breakpointObserver() {
  const store = writable(void 0);
  onMount(() => {
    const match = {
      sm: window.matchMedia(`(max-width: ${breakpoints.md}px)`),
      md: window.matchMedia(
        `(min-width: ${breakpoints.md}px) and (max-width: ${breakpoints.lg}px)`
      ),
      lg: window.matchMedia(
        `(min-width: ${breakpoints.lg}px) and (max-width: ${breakpoints.xlg}px)`
      ),
      xlg: window.matchMedia(
        `(min-width: ${breakpoints.xlg}px) and (max-width: ${breakpoints.max}px)`
      ),
      max: window.matchMedia(`(min-width: ${breakpoints.max}px)`)
    };
    const matchers = Object.entries(match);
    const sizeByMedia = Object.fromEntries(
      matchers.map(([size2, queryList]) => [queryList.media, size2])
    );
    const size = matchers.find(([size2, queryList]) => queryList.matches)[0];
    store.set(size);
    function handleChange({ matches, media }) {
      const size2 = sizeByMedia[media];
      if (matches) store.set(size2);
    }
    matchers.forEach(
      ([size2, queryList]) => queryList.addEventListener("change", handleChange)
    );
    return () => {
      matchers.forEach(
        ([size2, queryList]) => queryList.removeEventListener("change", handleChange)
      );
    };
  });
  return {
    subscribe: store.subscribe,
    /**
     * Returns a store readable store that returns whether the current
     * breakpoint is smaller than {@link size}.
     * @param {import("./breakpoints").BreakpointSize} size Size to compare against.
     */
    smallerThan: (size) => {
      checkSizeValid(size);
      return derived2(store, ($size) => breakpoints[$size] < breakpoints[size]);
    },
    /**
     * Returns a store readable store that returns whether the current
     * breakpoint is larger than {@link size}.
     * @param {import("./breakpoints").BreakpointSize} size Size to compare against.
     */
    largerThan: (size) => {
      checkSizeValid(size);
      return derived2(store, ($size) => breakpoints[$size] > breakpoints[size]);
    }
  };
}
function checkSizeValid(size) {
  if (size in breakpoints == false)
    throw new Error(`"${size}" is not a valid breakpoint size.`);
}
var breakpointObserver_default = breakpointObserver;

// node_modules/carbon-components-svelte/src/Breakpoint/Breakpoint.svelte
mark_module_start();
Breakpoint[FILENAME] = "node_modules/carbon-components-svelte/src/Breakpoint/Breakpoint.svelte";
function Breakpoint($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Breakpoint);
  const [$$stores, $$cleanup] = setup_stores();
  const $observer = () => (validate_store(observer, "observer"), store_get(observer, "$observer", $$stores));
  let size = prop($$props, "size", 12, void 0);
  let sizes = prop($$props, "sizes", 28, () => ({
    sm: false,
    md: false,
    lg: false,
    xlg: false,
    max: false
  }));
  const dispatch = createEventDispatcher();
  const observer = breakpointObserver();
  legacy_pre_effect(() => $observer(), () => {
    size($observer());
  });
  legacy_pre_effect(() => deep_read_state(size()), () => {
    sizes({
      sm: equals(size(), "sm"),
      md: equals(size(), "md"),
      lg: equals(size(), "lg"),
      xlg: equals(size(), "xlg"),
      max: equals(size(), "max")
    });
  });
  legacy_pre_effect(
    () => (deep_read_state(size()), breakpoints),
    () => {
      if (equals(size(), void 0, false))
        dispatch("change", {
          size: size(),
          breakpointValue: breakpoints[size()]
        });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    $$props,
    "default",
    {
      get size() {
        return size();
      },
      get sizes() {
        return sizes();
      }
    },
    null
  );
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Breakpoint = hmr(Breakpoint, () => Breakpoint[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Breakpoint[HMR].source;
    set(Breakpoint[HMR].source, module.default[HMR].original);
  });
}
var Breakpoint_default = Breakpoint;
mark_module_end(Breakpoint);

// node_modules/carbon-components-svelte/src/Button/ButtonSkeleton.svelte
mark_module_start();
ButtonSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/Button/ButtonSkeleton.svelte";
var root_16 = add_locations(template(`<a></a>`), ButtonSkeleton[FILENAME], [[17, 2]]);
var root_26 = add_locations(template(`<div></div>`), ButtonSkeleton[FILENAME], [[39, 2]]);
function ButtonSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["href", "size"]);
  push($$props, false, ButtonSkeleton);
  let href = prop($$props, "href", 8, void 0);
  let size = prop($$props, "size", 8, "default");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var a = root_16();
      let attributes;
      a.textContent = ``;
      template_effect(() => {
        attributes = set_attributes(a, attributes, {
          href: href(),
          rel: strict_equals($$restProps.target, "_blank") ? "noopener noreferrer" : void 0,
          role: "button",
          ...$$restProps
        });
        toggle_class(a, "bx--skeleton", true);
        toggle_class(a, "bx--btn", true);
        toggle_class(a, "bx--btn--field", strict_equals(size(), "field"));
        toggle_class(a, "bx--btn--sm", strict_equals(size(), "small"));
        toggle_class(a, "bx--btn--lg", strict_equals(size(), "lg"));
        toggle_class(a, "bx--btn--xl", strict_equals(size(), "xl"));
      });
      event2("click", a, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("focus", a, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("blur", a, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseover", a, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseenter", a, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseleave", a, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, a);
    };
    var alternate = ($$anchor2) => {
      var div = root_26();
      let attributes_1;
      template_effect(() => {
        attributes_1 = set_attributes(div, attributes_1, { ...$$restProps });
        toggle_class(div, "bx--skeleton", true);
        toggle_class(div, "bx--btn", true);
        toggle_class(div, "bx--btn--field", strict_equals(size(), "field"));
        toggle_class(div, "bx--btn--sm", strict_equals(size(), "small"));
        toggle_class(div, "bx--btn--lg", strict_equals(size(), "lg"));
        toggle_class(div, "bx--btn--xl", strict_equals(size(), "xl"));
      });
      event2("click", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("focus", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("blur", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseover", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseenter", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseleave", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if (href()) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ButtonSkeleton = hmr(ButtonSkeleton, () => ButtonSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ButtonSkeleton[HMR].source;
    set(ButtonSkeleton[HMR].source, module.default[HMR].original);
  });
}
var ButtonSkeleton_default = ButtonSkeleton;
mark_module_end(ButtonSkeleton);

// node_modules/carbon-components-svelte/src/Button/Button.svelte
mark_module_start();
Button[FILENAME] = "node_modules/carbon-components-svelte/src/Button/Button.svelte";
var root_6 = add_locations(template(`<span> </span>`), Button[FILENAME], [[166, 6]]);
var root_52 = add_locations(template(`<a><!> <!> <!></a>`), Button[FILENAME], [[155, 2]]);
var root_11 = add_locations(template(`<span> </span>`), Button[FILENAME], [[195, 6]]);
var root_10 = add_locations(template(`<button><!> <!> <!></button>`), Button[FILENAME], [[184, 2]]);
function Button($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "kind",
    "size",
    "expressive",
    "isSelected",
    "icon",
    "iconDescription",
    "tooltipAlignment",
    "tooltipPosition",
    "as",
    "skeleton",
    "disabled",
    "href",
    "tabindex",
    "type",
    "ref"
  ]);
  push($$props, false, Button);
  const hasIconOnly = mutable_state();
  const iconProps = mutable_state();
  const buttonProps = mutable_state();
  let kind = prop($$props, "kind", 8, "primary");
  let size = prop($$props, "size", 8, "default");
  let expressive = prop($$props, "expressive", 8, false);
  let isSelected = prop($$props, "isSelected", 8, false);
  let icon = prop($$props, "icon", 8, void 0);
  let iconDescription = prop($$props, "iconDescription", 8, void 0);
  let tooltipAlignment = prop($$props, "tooltipAlignment", 8, "center");
  let tooltipPosition = prop($$props, "tooltipPosition", 8, "bottom");
  let as = prop($$props, "as", 8, false);
  let skeleton = prop($$props, "skeleton", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let href = prop($$props, "href", 8, void 0);
  let tabindex = prop($$props, "tabindex", 8, "0");
  let type = prop($$props, "type", 8, "button");
  let ref = prop($$props, "ref", 12, null);
  const ctx = getContext("ComposedModal");
  legacy_pre_effect(() => deep_read_state(ref()), () => {
    if (ctx && ref()) {
      ctx.declareRef(ref());
    }
  });
  legacy_pre_effect(() => deep_read_state(icon()), () => {
    set(hasIconOnly, (icon() || $$slots.icon) && !$$slots.default);
  });
  legacy_pre_effect(() => deep_read_state(iconDescription()), () => {
    set(iconProps, {
      "aria-hidden": "true",
      class: "bx--btn__icon",
      "aria-label": iconDescription()
    });
  });
  legacy_pre_effect(
    () => (deep_read_state(href()), deep_read_state(disabled()), deep_read_state(type()), deep_read_state(tabindex()), get(hasIconOnly), deep_read_state(kind()), deep_read_state(isSelected()), deep_read_state($$restProps), deep_read_state(expressive()), deep_read_state(size()), deep_read_state(tooltipPosition()), deep_read_state(tooltipAlignment())),
    () => {
      set(buttonProps, {
        type: href() && !disabled() ? void 0 : type(),
        tabindex: tabindex(),
        disabled: strict_equals(disabled(), true) ? true : void 0,
        href: href(),
        "aria-pressed": get(hasIconOnly) && strict_equals(kind(), "ghost") && !href() ? isSelected() : void 0,
        ...$$restProps,
        class: [
          "bx--btn",
          expressive() && "bx--btn--expressive",
          (strict_equals(size(), "small") && !expressive() || strict_equals(size(), "sm") && !expressive() || strict_equals(size(), "small") && !expressive()) && "bx--btn--sm",
          strict_equals(size(), "field") && !expressive() || strict_equals(size(), "md") && !expressive() && "bx--btn--md",
          strict_equals(size(), "field") && "bx--btn--field",
          strict_equals(size(), "small") && "bx--btn--sm",
          strict_equals(size(), "lg") && "bx--btn--lg",
          strict_equals(size(), "xl") && "bx--btn--xl",
          kind() && `bx--btn--${kind()}`,
          disabled() && "bx--btn--disabled",
          get(hasIconOnly) && "bx--btn--icon-only",
          get(hasIconOnly) && "bx--tooltip__trigger",
          get(hasIconOnly) && "bx--tooltip--a11y",
          get(hasIconOnly) && tooltipPosition() && `bx--btn--icon-only--${tooltipPosition()}`,
          get(hasIconOnly) && tooltipAlignment() && `bx--tooltip--align-${tooltipAlignment()}`,
          get(hasIconOnly) && isSelected() && strict_equals(kind(), "ghost") && "bx--btn--selected",
          $$restProps.class
        ].filter(Boolean).join(" ")
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      const expression = derived_safe_equal(() => get(hasIconOnly) && "width: 3rem;");
      ButtonSkeleton_default(node_1, spread_props(
        {
          get href() {
            return href();
          },
          get size() {
            return size();
          }
        },
        () => $$restProps,
        {
          get style() {
            return get(expression);
          },
          $$events: {
            click($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            focus($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            blur($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            mouseover($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            mouseenter($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            mouseleave($$arg) {
              bubble_event.call(this, $$props, $$arg);
            }
          }
        }
      ));
      append($$anchor2, fragment_1);
    };
    var alternate_4 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          slot(
            node_3,
            $$props,
            "default",
            {
              get props() {
                return get(buttonProps);
              }
            },
            null
          );
          append($$anchor3, fragment_3);
        };
        var alternate_3 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_4 = first_child(fragment_4);
          {
            var consequent_5 = ($$anchor4) => {
              var a = root_52();
              let attributes;
              var node_5 = child(a);
              {
                var consequent_2 = ($$anchor5) => {
                  var span = root_6();
                  toggle_class(span, "bx--assistive-text", true);
                  var text2 = child(span, true);
                  reset(span);
                  template_effect(() => set_text(text2, iconDescription()));
                  append($$anchor5, span);
                };
                if_block(node_5, ($$render) => {
                  if (get(hasIconOnly)) $$render(consequent_2);
                });
              }
              var node_6 = sibling(node_5, 2);
              slot(node_6, $$props, "default", {}, null);
              var node_7 = sibling(node_6, 2);
              {
                var consequent_3 = ($$anchor5) => {
                  var fragment_5 = comment();
                  var node_8 = first_child(fragment_5);
                  slot(
                    node_8,
                    $$props,
                    "icon",
                    spread_props(
                      {
                        get style() {
                          return get(hasIconOnly) ? "margin-left: 0" : void 0;
                        }
                      },
                      () => get(iconProps)
                    ),
                    null
                  );
                  append($$anchor5, fragment_5);
                };
                var alternate = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_9 = first_child(fragment_6);
                  {
                    var consequent_4 = ($$anchor6) => {
                      var fragment_7 = comment();
                      var node_10 = first_child(fragment_7);
                      const expression_1 = derived_safe_equal(() => get(hasIconOnly) ? "margin-left: 0" : void 0);
                      component(node_10, icon, ($$anchor7, $$component) => {
                        $$component($$anchor7, spread_props(
                          {
                            get style() {
                              return get(expression_1);
                            }
                          },
                          () => get(iconProps)
                        ));
                      });
                      append($$anchor6, fragment_7);
                    };
                    if_block(
                      node_9,
                      ($$render) => {
                        if (icon()) $$render(consequent_4);
                      },
                      true
                    );
                  }
                  append($$anchor5, fragment_6);
                };
                if_block(node_7, ($$render) => {
                  if ($$slots.icon) $$render(consequent_3);
                  else $$render(alternate, false);
                });
              }
              reset(a);
              bind_this(a, ($$value) => ref($$value), () => ref());
              template_effect(() => attributes = set_attributes(a, attributes, { ...get(buttonProps) }));
              event2("click", a, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("focus", a, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("blur", a, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("mouseover", a, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("mouseenter", a, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("mouseleave", a, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              append($$anchor4, a);
            };
            var alternate_2 = ($$anchor4) => {
              var button = root_10();
              let attributes_1;
              var node_11 = child(button);
              {
                var consequent_6 = ($$anchor5) => {
                  var span_1 = root_11();
                  toggle_class(span_1, "bx--assistive-text", true);
                  var text_1 = child(span_1, true);
                  reset(span_1);
                  template_effect(() => set_text(text_1, iconDescription()));
                  append($$anchor5, span_1);
                };
                if_block(node_11, ($$render) => {
                  if (get(hasIconOnly)) $$render(consequent_6);
                });
              }
              var node_12 = sibling(node_11, 2);
              slot(node_12, $$props, "default", {}, null);
              var node_13 = sibling(node_12, 2);
              {
                var consequent_7 = ($$anchor5) => {
                  var fragment_8 = comment();
                  var node_14 = first_child(fragment_8);
                  slot(
                    node_14,
                    $$props,
                    "icon",
                    spread_props(
                      {
                        get style() {
                          return get(hasIconOnly) ? "margin-left: 0" : void 0;
                        }
                      },
                      () => get(iconProps)
                    ),
                    null
                  );
                  append($$anchor5, fragment_8);
                };
                var alternate_1 = ($$anchor5) => {
                  var fragment_9 = comment();
                  var node_15 = first_child(fragment_9);
                  {
                    var consequent_8 = ($$anchor6) => {
                      var fragment_10 = comment();
                      var node_16 = first_child(fragment_10);
                      const expression_2 = derived_safe_equal(() => get(hasIconOnly) ? "margin-left: 0" : void 0);
                      component(node_16, icon, ($$anchor7, $$component) => {
                        $$component($$anchor7, spread_props(
                          {
                            get style() {
                              return get(expression_2);
                            }
                          },
                          () => get(iconProps)
                        ));
                      });
                      append($$anchor6, fragment_10);
                    };
                    if_block(
                      node_15,
                      ($$render) => {
                        if (icon()) $$render(consequent_8);
                      },
                      true
                    );
                  }
                  append($$anchor5, fragment_9);
                };
                if_block(node_13, ($$render) => {
                  if ($$slots.icon) $$render(consequent_7);
                  else $$render(alternate_1, false);
                });
              }
              reset(button);
              bind_this(button, ($$value) => ref($$value), () => ref());
              template_effect(() => attributes_1 = set_attributes(button, attributes_1, { ...get(buttonProps) }));
              event2("click", button, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("focus", button, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("blur", button, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("mouseover", button, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("mouseenter", button, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("mouseleave", button, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              append($$anchor4, button);
            };
            if_block(
              node_4,
              ($$render) => {
                if (href() && !disabled()) $$render(consequent_5);
                else $$render(alternate_2, false);
              },
              true
            );
          }
          append($$anchor3, fragment_4);
        };
        if_block(
          node_2,
          ($$render) => {
            if (as()) $$render(consequent_1);
            else $$render(alternate_3, false);
          },
          true
        );
      }
      append($$anchor2, fragment_2);
    };
    if_block(node, ($$render) => {
      if (skeleton()) $$render(consequent);
      else $$render(alternate_4, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Button = hmr(Button, () => Button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Button[HMR].source;
    set(Button[HMR].source, module.default[HMR].original);
  });
}
var Button_default = Button;
mark_module_end(Button);

// node_modules/carbon-components-svelte/src/Button/ButtonSet.svelte
mark_module_start();
ButtonSet[FILENAME] = "node_modules/carbon-components-svelte/src/Button/ButtonSet.svelte";
var root7 = add_locations(template(`<div><!></div>`), ButtonSet[FILENAME], [[6, 0]]);
function ButtonSet($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["stacked"]);
  push($$props, false, ButtonSet);
  let stacked = prop($$props, "stacked", 8, false);
  var div = root7();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--btn-set", true);
    toggle_class(div, "bx--btn-set--stacked", stacked());
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ButtonSet = hmr(ButtonSet, () => ButtonSet[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ButtonSet[HMR].source;
    set(ButtonSet[HMR].source, module.default[HMR].original);
  });
}
var ButtonSet_default = ButtonSet;
mark_module_end(ButtonSet);

// node_modules/carbon-components-svelte/src/Checkbox/CheckboxSkeleton.svelte
mark_module_start();
CheckboxSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/Checkbox/CheckboxSkeleton.svelte";
var root8 = add_locations(template(`<div><span></span></div>`), CheckboxSkeleton[FILENAME], [[3, 0, [[13, 2]]]]);
function CheckboxSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, CheckboxSkeleton);
  var div = root8();
  let attributes;
  var span = child(div);
  toggle_class(span, "bx--checkbox-label-text", true);
  toggle_class(span, "bx--skeleton", true);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--form-item", true);
    toggle_class(div, "bx--checkbox-wrapper", true);
    toggle_class(div, "bx--checkbox-label", true);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CheckboxSkeleton = hmr(CheckboxSkeleton, () => CheckboxSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CheckboxSkeleton[HMR].source;
    set(CheckboxSkeleton[HMR].source, module.default[HMR].original);
  });
}
var CheckboxSkeleton_default = CheckboxSkeleton;
mark_module_end(CheckboxSkeleton);

// node_modules/carbon-components-svelte/src/Checkbox/Checkbox.svelte
mark_module_start();
Checkbox[FILENAME] = "node_modules/carbon-components-svelte/src/Checkbox/Checkbox.svelte";
var root_27 = add_locations(template(`<div><input type="checkbox"> <label><span><!></span></label></div>`), Checkbox[FILENAME], [
  [
    84,
    2,
    [[93, 4], [118, 4, [[119, 6]]]]
  ]
]);
function Checkbox($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "value",
    "checked",
    "group",
    "indeterminate",
    "skeleton",
    "required",
    "readonly",
    "disabled",
    "labelText",
    "hideLabel",
    "name",
    "title",
    "id",
    "ref"
  ]);
  push($$props, false, Checkbox);
  const useGroup = mutable_state();
  const isTruncated = mutable_state();
  let value = prop($$props, "value", 8, "");
  let checked = prop($$props, "checked", 12, false);
  let group = prop($$props, "group", 12, void 0);
  let indeterminate = prop($$props, "indeterminate", 8, false);
  let skeleton = prop($$props, "skeleton", 8, false);
  let required = prop($$props, "required", 8, false);
  let readonly2 = prop($$props, "readonly", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let labelText = prop($$props, "labelText", 8, "");
  let hideLabel = prop($$props, "hideLabel", 8, false);
  let name = prop($$props, "name", 8, "");
  let title = prop($$props, "title", 12, void 0);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let ref = prop($$props, "ref", 12, null);
  const dispatch = createEventDispatcher();
  let refLabel = mutable_state(null);
  legacy_pre_effect(() => deep_read_state(group()), () => {
    set(useGroup, Array.isArray(group()));
  });
  legacy_pre_effect(
    () => (deep_read_state(checked()), get(useGroup), deep_read_state(group()), deep_read_state(value())),
    () => {
      checked(get(useGroup) ? group().includes(value()) : checked());
    }
  );
  legacy_pre_effect(() => deep_read_state(checked()), () => {
    dispatch("check", checked());
  });
  legacy_pre_effect(() => get(refLabel), () => {
    var _a, _b;
    set(isTruncated, ((_a = get(refLabel)) == null ? void 0 : _a.offsetWidth) < ((_b = get(refLabel)) == null ? void 0 : _b.scrollWidth));
  });
  legacy_pre_effect(
    () => (deep_read_state(title()), get(isTruncated), get(refLabel)),
    () => {
      var _a;
      title(!title() && get(isTruncated) ? (_a = get(refLabel)) == null ? void 0 : _a.innerText : title());
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      CheckboxSkeleton_default(node_1, spread_props(() => $$restProps, {
        $$events: {
          click($$arg) {
            bubble_event.call(this, $$props, $$arg);
          },
          mouseover($$arg) {
            bubble_event.call(this, $$props, $$arg);
          },
          mouseenter($$arg) {
            bubble_event.call(this, $$props, $$arg);
          },
          mouseleave($$arg) {
            bubble_event.call(this, $$props, $$arg);
          }
        }
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_27();
      let attributes;
      var input = child(div);
      remove_input_defaults(input);
      bind_this(input, ($$value) => ref($$value), () => ref());
      var label = sibling(input, 2);
      var span = child(label);
      toggle_class(span, "bx--checkbox-label-text", true);
      var node_2 = child(span);
      slot(node_2, $$props, "labelText", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, labelText()));
        append($$anchor3, text2);
      });
      reset(span);
      bind_this(span, ($$value) => set(refLabel, $$value), () => get(refLabel));
      reset(label);
      reset(div);
      template_effect(() => {
        attributes = set_attributes(div, attributes, { ...$$restProps });
        toggle_class(div, "bx--form-item", true);
        toggle_class(div, "bx--checkbox-wrapper", true);
        set_value(input, value());
        set_checked(input, checked());
        input.disabled = disabled();
        set_attribute(input, "id", id());
        input.indeterminate = indeterminate();
        set_attribute(input, "name", name());
        input.required = required();
        input.readOnly = readonly2();
        toggle_class(input, "bx--checkbox", true);
        set_attribute(label, "for", id());
        set_attribute(label, "title", title());
        toggle_class(label, "bx--checkbox-label", true);
        toggle_class(span, "bx--visually-hidden", hideLabel());
      });
      event2("change", input, () => {
        if (get(useGroup)) {
          group(group().includes(value()) ? group().filter((_value) => strict_equals(_value, value(), false)) : [...group(), value()]);
        } else {
          checked(!checked());
        }
      });
      event2("change", input, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("focus", input, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("blur", input, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("click", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseover", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseenter", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseleave", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if (skeleton()) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Checkbox = hmr(Checkbox, () => Checkbox[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Checkbox[HMR].source;
    set(Checkbox[HMR].source, module.default[HMR].original);
  });
}
var Checkbox_default = Checkbox;
mark_module_end(Checkbox);

// node_modules/carbon-components-svelte/src/Checkbox/InlineCheckbox.svelte
mark_module_start();
InlineCheckbox[FILENAME] = "node_modules/carbon-components-svelte/src/Checkbox/InlineCheckbox.svelte";
var root9 = add_locations(template(`<div><input> <label></label></div>`), InlineCheckbox[FILENAME], [[21, 0, [[22, 2], [35, 2]]]]);
function InlineCheckbox($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "checked",
    "indeterminate",
    "title",
    "id",
    "ref"
  ]);
  push($$props, false, InlineCheckbox);
  let checked = prop($$props, "checked", 8, false);
  let indeterminate = prop($$props, "indeterminate", 8, false);
  let title = prop($$props, "title", 8, void 0);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let ref = prop($$props, "ref", 12, null);
  init();
  var div = root9();
  toggle_class(div, "bx--checkbox--inline", true);
  var input = child(div);
  remove_input_defaults(input);
  let attributes;
  bind_this(input, ($$value) => ref($$value), () => ref());
  var label = sibling(input, 2);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(input, attributes, {
      type: "checkbox",
      checked: indeterminate() ? false : checked(),
      indeterminate: indeterminate(),
      id: id(),
      ...$$restProps,
      "aria-checked": indeterminate() ? void 0 : checked()
    });
    toggle_class(input, "bx--checkbox", true);
    set_attribute(label, "for", id());
    set_attribute(label, "title", title());
    set_attribute(label, "aria-label", $$sanitized_props["aria-label"]);
    toggle_class(label, "bx--checkbox-label", true);
  });
  event2("change", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("focus", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("blur", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InlineCheckbox = hmr(InlineCheckbox, () => InlineCheckbox[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InlineCheckbox[HMR].source;
    set(InlineCheckbox[HMR].source, module.default[HMR].original);
  });
}
var InlineCheckbox_default = InlineCheckbox;
mark_module_end(InlineCheckbox);

// node_modules/carbon-components-svelte/src/ContentSwitcher/ContentSwitcher.svelte
mark_module_start();
ContentSwitcher[FILENAME] = "node_modules/carbon-components-svelte/src/ContentSwitcher/ContentSwitcher.svelte";
var root10 = add_locations(template(`<div><!></div>`), ContentSwitcher[FILENAME], [[62, 0]]);
function ContentSwitcher($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["selectedIndex", "size"]);
  push($$props, false, ContentSwitcher);
  const currentIndex = mutable_state();
  const switches = mutable_state();
  let selectedIndex = prop($$props, "selectedIndex", 12, 0);
  let size = prop($$props, "size", 8, void 0);
  const dispatch = createEventDispatcher();
  const currentId = writable(null);
  setContext("ContentSwitcher", {
    currentId,
    add: ({ id, text: text2, selected }) => {
      if (selected) {
        selectedIndex(get(switches).length);
      }
      set(switches, [
        ...get(switches),
        { id, text: text2, selected }
      ]);
    },
    update: (id) => {
      selectedIndex(get(switches).map(({ id: id2 }) => id2).indexOf(id));
    },
    change: (direction) => {
      let index2 = get(currentIndex) + direction;
      if (index2 < 0) {
        index2 = get(switches).length - 1;
      } else if (index2 >= get(switches).length) {
        index2 = 0;
      }
      selectedIndex(index2);
    }
  });
  afterUpdate(() => {
    if (strict_equals(selectedIndex(), get(currentIndex), false)) {
      set(currentIndex, selectedIndex());
    }
  });
  legacy_pre_effect(() => {
  }, () => {
    set(currentIndex, -1);
  });
  legacy_pre_effect(() => {
  }, () => {
    set(switches, []);
  });
  legacy_pre_effect(() => (get(switches), get(currentIndex)), () => {
    if (get(switches)[get(currentIndex)]) {
      dispatch("change", get(currentIndex));
      currentId.set(get(switches)[get(currentIndex)].id);
    }
  });
  legacy_pre_effect_reset();
  init();
  var div = root10();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { role: "tablist", ...$$restProps });
    toggle_class(div, "bx--content-switcher", true);
    toggle_class(div, "bx--content-switcher--sm", strict_equals(size(), "sm"));
    toggle_class(div, "bx--content-switcher--xl", strict_equals(size(), "xl"));
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ContentSwitcher = hmr(ContentSwitcher, () => ContentSwitcher[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ContentSwitcher[HMR].source;
    set(ContentSwitcher[HMR].source, module.default[HMR].original);
  });
}
var ContentSwitcher_default = ContentSwitcher;
mark_module_end(ContentSwitcher);

// node_modules/carbon-components-svelte/src/ContentSwitcher/Switch.svelte
mark_module_start();
Switch[FILENAME] = "node_modules/carbon-components-svelte/src/ContentSwitcher/Switch.svelte";
var root11 = add_locations(template(`<button><span><!></span></button>`), Switch[FILENAME], [[42, 0, [[69, 2]]]]);
function Switch($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "text",
    "selected",
    "disabled",
    "id",
    "ref"
  ]);
  push($$props, false, Switch);
  let text2 = prop($$props, "text", 8, "Provide text");
  let selected = prop($$props, "selected", 12, false);
  let disabled = prop($$props, "disabled", 8, false);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let ref = prop($$props, "ref", 12, null);
  const ctx = getContext("ContentSwitcher");
  ctx.add({
    id: id(),
    text: text2(),
    selected: selected()
  });
  const unsubscribe = ctx.currentId.subscribe((currentId) => {
    selected(strict_equals(currentId, id()));
  });
  afterUpdate(() => {
    if (selected()) {
      ref().focus();
    }
  });
  onMount(() => {
    return () => unsubscribe();
  });
  init();
  var button = root11();
  let attributes;
  var span = child(button);
  toggle_class(span, "bx--content-switcher__label", true);
  var node = child(span);
  slot(node, $$props, "default", {}, ($$anchor2) => {
    var text_1 = text();
    template_effect(() => set_text(text_1, text2()));
    append($$anchor2, text_1);
  });
  reset(span);
  reset(button);
  bind_this(button, ($$value) => ref($$value), () => ref());
  template_effect(() => {
    attributes = set_attributes(button, attributes, {
      type: "button",
      role: "tab",
      tabindex: selected() ? "0" : "-1",
      "aria-selected": selected(),
      disabled: disabled(),
      id: id(),
      ...$$restProps
    });
    toggle_class(button, "bx--content-switcher-btn", true);
    toggle_class(button, "bx--content-switcher--selected", selected());
  });
  event2("click", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", button, preventDefault(() => {
    ctx.update(id());
  }));
  event2("mouseover", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", button, ({ key }) => {
    if (strict_equals(key, "ArrowRight")) {
      ctx.change(1);
    } else if (strict_equals(key, "ArrowLeft")) {
      ctx.change(-1);
    }
  });
  append($$anchor, button);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Switch = hmr(Switch, () => Switch[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Switch[HMR].source;
    set(Switch[HMR].source, module.default[HMR].original);
  });
}
var Switch_default = Switch;
mark_module_end(Switch);

// node_modules/carbon-components-svelte/src/ContextMenu/ContextMenu.svelte
mark_module_start();
ContextMenu[FILENAME] = "node_modules/carbon-components-svelte/src/ContextMenu/ContextMenu.svelte";
var root12 = add_locations(template(`<ul><!></ul>`), ContextMenu[FILENAME], [[158, 0]]);
function ContextMenu($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["target", "open", "x", "y", "ref"]);
  push($$props, false, ContextMenu);
  const [$$stores, $$cleanup] = setup_stores();
  const $hasPopup = () => (validate_store(hasPopup, "hasPopup"), store_get(hasPopup, "$hasPopup", $$stores));
  const level = mutable_state();
  let target = prop($$props, "target", 8, null);
  let open = prop($$props, "open", 12, false);
  let x = prop($$props, "x", 12, 0);
  let y = prop($$props, "y", 12, 0);
  let ref = prop($$props, "ref", 12, null);
  const dispatch = createEventDispatcher();
  const position = writable([x(), y()]);
  const currentIndex = writable(-1);
  const hasPopup = writable(false);
  const menuOffsetX = writable(0);
  const ctx = getContext("ContextMenu");
  let options = mutable_state([]);
  let direction = 1;
  let prevX = 0;
  let prevY = 0;
  let focusIndex = mutable_state(-1);
  let openDetail = null;
  function close() {
    open(false);
    x(0);
    y(0);
    prevX = 0;
    prevY = 0;
    set(focusIndex, -1);
  }
  function openMenu(e) {
    e.preventDefault();
    const { height, width } = ref().getBoundingClientRect();
    if (open() || strict_equals(x(), 0)) {
      if (window.innerWidth - width < e.x) {
        x(e.x - width);
      } else {
        x(e.x);
      }
    }
    if (open() || strict_equals(y(), 0)) {
      menuOffsetX.set(e.x);
      if (window.innerHeight - height < e.y) {
        y(e.y - height);
      } else {
        y(e.y);
      }
    }
    position.set([x(), y()]);
    open(true);
    openDetail = e.target;
  }
  onMount(() => {
    return () => {
      if (equals(target(), null, false)) {
        if (Array.isArray(target())) {
          target().forEach((node) => node == null ? void 0 : node.removeEventListener("contextmenu", openMenu));
        } else {
          target().removeEventListener("contextmenu", openMenu);
        }
      }
    };
  });
  setContext("ContextMenu", {
    menuOffsetX,
    currentIndex,
    position,
    close,
    setPopup: (popup) => {
      hasPopup.set(popup);
    }
  });
  afterUpdate(() => {
    if (open()) {
      set(options, [
        ...ref().querySelectorAll("li[data-nested='false']")
      ]);
      if (strict_equals(get(level), 1)) {
        if (strict_equals(prevX, x(), false) || strict_equals(prevY, y(), false)) ref().focus();
        prevX = x();
        prevY = y();
      }
      dispatch("open", openDetail);
    } else {
      dispatch("close");
    }
    if (!$hasPopup() && get(options)[get(focusIndex)]) get(options)[get(focusIndex)].focus();
  });
  legacy_pre_effect(() => deep_read_state(target()), () => {
    if (equals(target(), null, false)) {
      if (Array.isArray(target())) {
        target().forEach((node) => node == null ? void 0 : node.addEventListener("contextmenu", openMenu));
      } else {
        target().addEventListener("contextmenu", openMenu);
      }
    }
  });
  legacy_pre_effect(() => {
  }, () => {
    set(level, !ctx ? 1 : 2);
  });
  legacy_pre_effect(() => get(focusIndex), () => {
    currentIndex.set(get(focusIndex));
  });
  legacy_pre_effect_reset();
  init();
  var ul = root12();
  event2("contextmenu", $window, (e) => {
    if (equals(target(), null, false)) return;
    if (get(level) > 1) return;
    if (!ref()) return;
    openMenu(e);
  });
  event2("click", $window, (e) => {
    if (!open()) return;
    close();
  });
  event2("keydown", $window, (e) => {
    if (open() && strict_equals(e.key, "Escape")) close();
  });
  let attributes;
  var node_1 = child(ul);
  slot(node_1, $$props, "default", {}, null);
  reset(ul);
  bind_this(ul, ($$value) => ref($$value), () => ref());
  template_effect(() => {
    attributes = set_attributes(ul, attributes, {
      role: "menu",
      tabindex: "-1",
      "data-direction": direction,
      "data-level": get(level),
      ...$$restProps
    });
    toggle_class(ul, "bx--menu", true);
    toggle_class(ul, "bx--menu--open", open());
    toggle_class(ul, "bx--menu--invisible", open() && strict_equals(x(), 0) && strict_equals(y(), 0));
    toggle_class(ul, "bx--menu--root", strict_equals(get(level), 1));
    set_style(ul, "left", `${x() ?? ""}px`);
    set_style(ul, "top", `${y() ?? ""}px`);
  });
  event2("click", ul, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", ul, ({ target: target2 }) => {
    const closestOption = target2.closest("[tabindex]");
    if (closestOption && strict_equals(closestOption.getAttribute("role"), "menuitem", false)) {
      close();
    }
  });
  event2("keydown", ul, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", ul, (e) => {
    if (open()) e.preventDefault();
    if ($hasPopup()) return;
    if (strict_equals(e.key, "ArrowDown")) {
      if (get(focusIndex) < get(options).length - 1) update(focusIndex);
    } else if (strict_equals(e.key, "ArrowUp")) {
      if (strict_equals(get(focusIndex), -1)) {
        set(focusIndex, get(options).length - 1);
      } else {
        if (get(focusIndex) > 0) update(focusIndex, -1);
      }
    }
  });
  append($$anchor, ul);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  ContextMenu = hmr(ContextMenu, () => ContextMenu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ContextMenu[HMR].source;
    set(ContextMenu[HMR].source, module.default[HMR].original);
  });
}
var ContextMenu_default = ContextMenu;
mark_module_end(ContextMenu);

// node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuDivider.svelte
mark_module_start();
ContextMenuDivider[FILENAME] = "node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuDivider.svelte";
var root13 = add_locations(template(`<li role="separator"></li>`), ContextMenuDivider[FILENAME], [[1, 0]]);
function ContextMenuDivider($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, ContextMenuDivider);
  var li = root13();
  toggle_class(li, "bx--menu-divider", true);
  append($$anchor, li);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ContextMenuDivider = hmr(ContextMenuDivider, () => ContextMenuDivider[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ContextMenuDivider[HMR].source;
    set(ContextMenuDivider[HMR].source, module.default[HMR].original);
  });
}
var ContextMenuDivider_default = ContextMenuDivider;
mark_module_end(ContextMenuDivider);

// node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuGroup.svelte
mark_module_start();
ContextMenuGroup[FILENAME] = "node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuGroup.svelte";
var root14 = add_locations(template(`<li role="none"><ul role="group"><!></ul></li>`), ContextMenuGroup[FILENAME], [[32, 0, [[33, 2]]]]);
function ContextMenuGroup($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, ContextMenuGroup);
  let selectedIds = prop($$props, "selectedIds", 28, () => []);
  let labelText = prop($$props, "labelText", 8, "");
  const currentIds = writable([]);
  setContext("ContextMenuGroup", {
    currentIds,
    addOption: ({ id }) => {
      if (!selectedIds().includes(id)) {
        selectedIds([...selectedIds(), id]);
      }
    },
    toggleOption: ({ id }) => {
      if (!selectedIds().includes(id)) {
        selectedIds([...selectedIds(), id]);
      } else {
        selectedIds(selectedIds().filter((_) => strict_equals(_, id, false)));
      }
    }
  });
  legacy_pre_effect(() => deep_read_state(selectedIds()), () => {
    currentIds.set(selectedIds());
  });
  legacy_pre_effect_reset();
  init();
  var li = root14();
  var ul = child(li);
  var node = child(ul);
  slot(node, $$props, "default", {}, null);
  reset(ul);
  reset(li);
  template_effect(() => set_attribute(ul, "aria-label", labelText()));
  append($$anchor, li);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ContextMenuGroup = hmr(ContextMenuGroup, () => ContextMenuGroup[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ContextMenuGroup[HMR].source;
    set(ContextMenuGroup[HMR].source, module.default[HMR].original);
  });
}
var ContextMenuGroup_default = ContextMenuGroup;
mark_module_end(ContextMenuGroup);

// node_modules/carbon-components-svelte/src/icons/Checkmark.svelte
mark_module_start();
Checkmark[FILENAME] = "node_modules/carbon-components-svelte/src/icons/Checkmark.svelte";
var root_17 = add_locations(ns_template(`<title> </title>`), Checkmark[FILENAME], [[24, 13]]);
var root15 = add_locations(ns_template(`<svg><!><path d="M13 24L4 15 5.414 13.586 13 21.171 26.586 7.586 28 9 13 24z"></path></svg>`), Checkmark[FILENAME], [[14, 0, [[25, 2]]]]);
function Checkmark($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, Checkmark);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root15();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_17();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next();
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Checkmark = hmr(Checkmark, () => Checkmark[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Checkmark[HMR].source;
    set(Checkmark[HMR].source, module.default[HMR].original);
  });
}
var Checkmark_default = Checkmark;
mark_module_end(Checkmark);

// node_modules/carbon-components-svelte/src/icons/CaretRight.svelte
mark_module_start();
CaretRight[FILENAME] = "node_modules/carbon-components-svelte/src/icons/CaretRight.svelte";
var root_18 = add_locations(ns_template(`<title> </title>`), CaretRight[FILENAME], [[24, 13]]);
var root16 = add_locations(ns_template(`<svg><!><path d="M12 8L22 16 12 24z"></path></svg>`), CaretRight[FILENAME], [[14, 0, [[25, 2]]]]);
function CaretRight($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, CaretRight);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root16();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_18();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next();
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CaretRight = hmr(CaretRight, () => CaretRight[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretRight[HMR].source;
    set(CaretRight[HMR].source, module.default[HMR].original);
  });
}
var CaretRight_default = CaretRight;
mark_module_end(CaretRight);

// node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuOption.svelte
mark_module_start();
ContextMenuOption[FILENAME] = "node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuOption.svelte";
var root_28 = add_locations(template(`<div><!></div>`), ContextMenuOption[FILENAME], [[247, 8]]);
var root_19 = add_locations(template(`<div><!> <span><!></span> <div><!></div></div> <!>`, 1), ContextMenuOption[FILENAME], [[242, 4, [[253, 6], [256, 6]]]]);
var root_7 = add_locations(template(`<div><!></div>`), ContextMenuOption[FILENAME], [[272, 8]]);
var root_62 = add_locations(template(`<div><!> <span><!></span> <div><!></div></div>`), ContextMenuOption[FILENAME], [[267, 4, [[278, 6], [281, 6]]]]);
var root17 = add_locations(template(`<li><!></li>`), ContextMenuOption[FILENAME], [[169, 0]]);
function ContextMenuOption($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "kind",
    "disabled",
    "indented",
    "icon",
    "labelText",
    "selected",
    "selectable",
    "shortcutText",
    "id",
    "ref"
  ]);
  push($$props, false, ContextMenuOption);
  const isSelectable = mutable_state();
  const isRadio = mutable_state();
  const subOptions = mutable_state();
  let kind = prop($$props, "kind", 8, "default");
  let disabled = prop($$props, "disabled", 8, false);
  let indented = prop($$props, "indented", 12, false);
  let icon = prop($$props, "icon", 12, void 0);
  let labelText = prop($$props, "labelText", 8, "");
  let selected = prop($$props, "selected", 12, false);
  let selectable = prop($$props, "selectable", 12, false);
  let shortcutText = prop($$props, "shortcutText", 8, "");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let ref = prop($$props, "ref", 12, null);
  const dispatch = createEventDispatcher();
  const ctx = getContext("ContextMenu");
  const ctxGroup = getContext("ContextMenuGroup");
  const ctxRadioGroup = getContext("ContextMenuRadioGroup");
  const moderate01 = 150;
  let unsubCurrentIds = void 0;
  let unsubCurrentId = void 0;
  let timeoutHover = mutable_state(void 0);
  let rootMenuPosition = mutable_state([0, 0]);
  let focusIndex = mutable_state(0);
  let options = mutable_state([]);
  let role = mutable_state("menuitem");
  let submenuOpen = mutable_state(false);
  let submenuPosition = mutable_state([0, 0]);
  let menuOffsetX = mutable_state(0);
  const unsubPosition = ctx.position.subscribe((position) => {
    set(rootMenuPosition, position);
  });
  const unsubMenuOffsetX = ctx.menuOffsetX.subscribe((_menuOffsetX) => {
    set(menuOffsetX, _menuOffsetX);
  });
  function handleClick(opts = {}) {
    if (disabled()) return ctx.close();
    if (get(subOptions)) return;
    if (!!ctxGroup) {
      ctxGroup.toggleOption({ id: id() });
    } else if (!!ctxRadioGroup) {
      if (opts.fromKeyboard) {
        ctxRadioGroup.setOption({ id: opts.id });
      } else {
        ctxRadioGroup.setOption({ id: id() });
      }
    } else {
      selected(!selected());
    }
    ctx.close();
    dispatch("click");
  }
  onMount(() => {
    if (strict_equals(selected(), true)) selectable(true);
    if (ctxGroup) {
      unsubCurrentIds = ctxGroup.currentIds.subscribe((_currentIds) => {
        selected(_currentIds.includes(id()));
      });
    }
    if (ctxRadioGroup) {
      unsubCurrentId = ctxRadioGroup.currentId.subscribe((_id) => {
        selected(strict_equals(id(), _id));
      });
    }
    return () => {
      unsubPosition();
      unsubMenuOffsetX();
      if (unsubCurrentIds) unsubCurrentIds();
      if (unsubCurrentId) unsubCurrentId();
      if (strict_equals(typeof get(timeoutHover), "number")) clearTimeout(get(timeoutHover));
    };
  });
  legacy_pre_effect(() => deep_read_state(selectable()), () => {
    set(isSelectable, !!ctxGroup || selectable());
  });
  legacy_pre_effect(() => {
  }, () => {
    set(isRadio, !!ctxRadioGroup);
  });
  legacy_pre_effect(() => {
  }, () => {
    set(subOptions, $$slots.default);
  });
  legacy_pre_effect(() => get(submenuOpen), () => {
    ctx.setPopup(get(submenuOpen));
  });
  legacy_pre_effect(
    () => (get(submenuOpen), deep_read_state(ref()), get(rootMenuPosition), get(menuOffsetX)),
    () => {
      if (get(submenuOpen)) {
        const { width, y } = ref().getBoundingClientRect();
        let x = get(rootMenuPosition)[0] + width;
        if (window.innerWidth - get(menuOffsetX) < width) {
          x = get(rootMenuPosition)[0] - width;
        }
        set(submenuPosition, [x, y]);
      }
    }
  );
  legacy_pre_effect(
    () => (get(isSelectable), deep_read_state(selected()), deep_read_state(id()), Checkmark_default, get(isRadio)),
    () => {
      if (get(isSelectable)) {
        indented(true);
        set(role, "menuitemcheckbox");
        if (selected()) {
          if (ctxGroup) ctxGroup.addOption({ id: id() });
          icon(Checkmark_default);
        } else {
          icon(void 0);
        }
      }
      if (get(isRadio)) {
        indented(true);
        set(role, "menuitemradio");
        ctxRadioGroup.addOption({ id: id() });
        if (selected()) {
          if (ctxRadioGroup) ctxRadioGroup.setOption({ id: id() });
          icon(Checkmark_default);
        } else {
          icon(void 0);
        }
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var li = root17();
  let attributes;
  var node = child(li);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment = root_19();
      var div = first_child(fragment);
      toggle_class(div, "bx--menu-option__content", true);
      var node_1 = child(div);
      {
        var consequent = ($$anchor3) => {
          var div_1 = root_28();
          toggle_class(div_1, "bx--menu-option__icon", true);
          var node_2 = child(div_1);
          slot(node_2, $$props, "icon", {}, ($$anchor4) => {
            var fragment_1 = comment();
            var node_3 = first_child(fragment_1);
            component(node_3, icon, ($$anchor5, $$component) => {
              $$component($$anchor5, {});
            });
            append($$anchor4, fragment_1);
          });
          reset(div_1);
          append($$anchor3, div_1);
        };
        if_block(node_1, ($$render) => {
          if (indented()) $$render(consequent);
        });
      }
      var span = sibling(node_1, 2);
      var node_4 = child(span);
      slot(node_4, $$props, "labelText", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, labelText()));
        append($$anchor3, text2);
      });
      reset(span);
      var div_2 = sibling(span, 2);
      toggle_class(div_2, "bx--menu-option__info", true);
      var node_5 = child(div_2);
      CaretRight_default(node_5, {});
      reset(div_2);
      reset(div);
      var node_6 = sibling(div, 2);
      ContextMenu_default(node_6, {
        get open() {
          return get(submenuOpen);
        },
        get x() {
          return get(submenuPosition)[0];
        },
        get y() {
          return get(submenuPosition)[1];
        },
        children: wrap_snippet(ContextMenuOption, ($$anchor3, $$slotProps) => {
          var fragment_3 = comment();
          var node_7 = first_child(fragment_3);
          slot(node_7, $$props, "default", {}, null);
          append($$anchor3, fragment_3);
        }),
        $$slots: { default: true }
      });
      template_effect(() => {
        toggle_class(div, "bx--menu-option__content--disabled", disabled());
        set_attribute(span, "title", labelText());
        toggle_class(span, "bx--menu-option__label", true);
      });
      append($$anchor2, fragment);
    };
    var alternate = ($$anchor2) => {
      var div_3 = root_62();
      toggle_class(div_3, "bx--menu-option__content", true);
      var node_8 = child(div_3);
      {
        var consequent_2 = ($$anchor3) => {
          var div_4 = root_7();
          toggle_class(div_4, "bx--menu-option__icon", true);
          var node_9 = child(div_4);
          slot(node_9, $$props, "icon", {}, ($$anchor4) => {
            var fragment_4 = comment();
            var node_10 = first_child(fragment_4);
            component(node_10, icon, ($$anchor5, $$component) => {
              $$component($$anchor5, {});
            });
            append($$anchor4, fragment_4);
          });
          reset(div_4);
          append($$anchor3, div_4);
        };
        if_block(node_8, ($$render) => {
          if (indented()) $$render(consequent_2);
        });
      }
      var span_1 = sibling(node_8, 2);
      var node_11 = child(span_1);
      slot(node_11, $$props, "labelText", {}, ($$anchor3) => {
        var text_1 = text();
        template_effect(() => set_text(text_1, labelText()));
        append($$anchor3, text_1);
      });
      reset(span_1);
      var div_5 = sibling(span_1, 2);
      toggle_class(div_5, "bx--menu-option__info", true);
      var node_12 = child(div_5);
      slot(node_12, $$props, "shortcutText", {}, ($$anchor3) => {
        var text_2 = text();
        template_effect(() => set_text(text_2, shortcutText()));
        append($$anchor3, text_2);
      });
      reset(div_5);
      reset(div_3);
      template_effect(() => {
        toggle_class(div_3, "bx--menu-option__content--disabled", disabled());
        set_attribute(span_1, "title", labelText());
        toggle_class(span_1, "bx--menu-option__label", true);
      });
      append($$anchor2, div_3);
    };
    if_block(node, ($$render) => {
      if (get(subOptions)) $$render(consequent_1);
      else $$render(alternate, false);
    });
  }
  reset(li);
  bind_this(li, ($$value) => ref($$value), () => ref());
  template_effect(
    ($0) => {
      attributes = set_attributes(li, attributes, {
        role: get(role),
        tabindex: "-1",
        "aria-disabled": !get(subOptions) && disabled(),
        "aria-haspopup": get(subOptions) ? true : void 0,
        "aria-expanded": get(subOptions) ? get(submenuOpen) : void 0,
        indented: indented(),
        "aria-checked": get(isSelectable) || get(isRadio) ? selected() : void 0,
        "data-nested": $0,
        "data-sub": get(subOptions),
        "data-id": id(),
        ...$$restProps
      });
      toggle_class(li, "bx--menu-option", true);
      toggle_class(li, "bx--menu-option--disabled", true);
      toggle_class(li, "bx--menu-option--active", get(subOptions) && get(submenuOpen));
      toggle_class(li, "bx--menu-option--danger", !get(subOptions) && strict_equals(kind(), "danger"));
    },
    [
      () => ref() && strict_equals(ref().closest(".bx--menu").getAttribute("data-level"), "2")
    ],
    derived_safe_equal
  );
  event2("keydown", li, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", li, async ({ key, target }) => {
    if (get(subOptions) && (strict_equals(key, "ArrowRight") || strict_equals(key, " ") || strict_equals(key, "Enter"))) {
      set(submenuOpen, true);
      await tick();
      set(options, [
        ...ref().querySelectorAll("li[tabindex]")
      ]);
      if (get(options)[get(focusIndex)]) get(options)[get(focusIndex)].focus();
      return;
    }
    if (get(submenuOpen)) {
      if (strict_equals(key, "ArrowLeft")) {
        set(submenuOpen, false);
        set(focusIndex, 0);
        return;
      }
      if (strict_equals(key, "ArrowDown")) {
        if (get(focusIndex) < get(options).length - 1) update(focusIndex);
      } else if (strict_equals(key, "ArrowUp")) {
        if (strict_equals(get(focusIndex), -1)) {
          set(focusIndex, get(options).length - 1);
        } else {
          if (get(focusIndex) > 0) update(focusIndex, -1);
        }
      }
      if (get(options)[get(focusIndex)]) get(options)[get(focusIndex)].focus();
    }
    if (strict_equals(key, " ") || strict_equals(key, "Enter")) {
      handleClick({
        fromKeyboard: true,
        id: target.getAttribute("data-id")
      });
    }
  });
  event2("mouseenter", li, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", li, () => {
    if (get(subOptions)) {
      set(timeoutHover, setTimeout(
        () => {
          set(submenuOpen, true);
        },
        moderate01
      ));
    }
  });
  event2("mouseleave", li, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", li, (e) => {
    if (get(subOptions)) {
      if (strict_equals(typeof get(timeoutHover), "number")) clearTimeout(get(timeoutHover));
      set(submenuOpen, false);
    }
  });
  event2("click", li, handleClick);
  append($$anchor, li);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ContextMenuOption = hmr(ContextMenuOption, () => ContextMenuOption[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ContextMenuOption[HMR].source;
    set(ContextMenuOption[HMR].source, module.default[HMR].original);
  });
}
var ContextMenuOption_default = ContextMenuOption;
mark_module_end(ContextMenuOption);

// node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuRadioGroup.svelte
mark_module_start();
ContextMenuRadioGroup[FILENAME] = "node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuRadioGroup.svelte";
var root18 = add_locations(template(`<li role="none"><ul role="group"><!></ul></li>`), ContextMenuRadioGroup[FILENAME], [[30, 0, [[31, 2]]]]);
function ContextMenuRadioGroup($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, ContextMenuRadioGroup);
  const [$$stores, $$cleanup] = setup_stores();
  const $radioIds = () => (validate_store(radioIds, "radioIds"), store_get(radioIds, "$radioIds", $$stores));
  let selectedId = prop($$props, "selectedId", 12, "");
  let labelText = prop($$props, "labelText", 8, "");
  const currentId = writable("");
  const radioIds = writable([]);
  setContext("ContextMenuRadioGroup", {
    currentId,
    radioIds,
    addOption: ({ id }) => {
      if (!$radioIds().includes(id)) {
        radioIds.update((_) => [..._, id]);
      }
    },
    setOption: ({ id }) => {
      selectedId(id);
    }
  });
  legacy_pre_effect(() => deep_read_state(selectedId()), () => {
    currentId.set(selectedId());
  });
  legacy_pre_effect_reset();
  init();
  var li = root18();
  var ul = child(li);
  var node = child(ul);
  slot(node, $$props, "default", {}, null);
  reset(ul);
  reset(li);
  template_effect(() => set_attribute(ul, "aria-label", labelText()));
  append($$anchor, li);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  ContextMenuRadioGroup = hmr(ContextMenuRadioGroup, () => ContextMenuRadioGroup[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ContextMenuRadioGroup[HMR].source;
    set(ContextMenuRadioGroup[HMR].source, module.default[HMR].original);
  });
}
var ContextMenuRadioGroup_default = ContextMenuRadioGroup;
mark_module_end(ContextMenuRadioGroup);

// node_modules/carbon-components-svelte/src/icons/Copy.svelte
mark_module_start();
Copy[FILENAME] = "node_modules/carbon-components-svelte/src/icons/Copy.svelte";
var root_110 = add_locations(ns_template(`<title> </title>`), Copy[FILENAME], [[24, 13]]);
var root19 = add_locations(ns_template(`<svg><!><path d="M28,10V28H10V10H28m0-2H10a2,2,0,0,0-2,2V28a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V10a2,2,0,0,0-2-2Z"></path><path d="M4,18H2V4A2,2,0,0,1,4,2H18V4H4Z"></path></svg>`), Copy[FILENAME], [[14, 0, [[25, 2], [27, 10]]]]);
function Copy($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, Copy);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root19();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_110();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next(2);
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Copy = hmr(Copy, () => Copy[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Copy[HMR].source;
    set(Copy[HMR].source, module.default[HMR].original);
  });
}
var Copy_default = Copy;
mark_module_end(Copy);

// node_modules/carbon-components-svelte/src/CopyButton/CopyButton.svelte
mark_module_start();
CopyButton[FILENAME] = "node_modules/carbon-components-svelte/src/CopyButton/CopyButton.svelte";
var root20 = add_locations(template(`<button><!> <span aria-hidden="true"> </span></button>`), CopyButton[FILENAME], [[43, 0, [[75, 2]]]]);
function CopyButton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "feedback",
    "feedbackTimeout",
    "iconDescription",
    "text",
    "copy"
  ]);
  push($$props, false, CopyButton);
  let feedback = prop($$props, "feedback", 8, "Copied!");
  let feedbackTimeout = prop($$props, "feedbackTimeout", 8, 2e3);
  let iconDescription = prop($$props, "iconDescription", 8, "Copy to clipboard");
  let text2 = prop($$props, "text", 8);
  let copy = prop($$props, "copy", 8, async (text3) => {
    try {
      await navigator.clipboard.writeText(text3);
    } catch (e) {
      console.log(...log_if_contains_state("log", e));
    }
  });
  const dispatch = createEventDispatcher();
  let animation = mutable_state(void 0);
  let timeout = mutable_state(void 0);
  onMount(() => {
    return () => clearTimeout(get(timeout));
  });
  init();
  var button = root20();
  let attributes;
  var node = child(button);
  Copy_default(node, { class: "bx--snippet__icon" });
  var span = sibling(node, 2);
  toggle_class(span, "bx--assistive-text", true);
  toggle_class(span, "bx--copy-btn__feedback", true);
  var text_1 = child(span, true);
  reset(span);
  reset(button);
  template_effect(() => {
    attributes = set_attributes(button, attributes, {
      type: "button",
      "aria-live": "polite",
      "aria-label": iconDescription(),
      title: iconDescription(),
      ...$$restProps
    });
    toggle_class(button, "bx--copy-btn", true);
    toggle_class(button, "bx--copy", true);
    toggle_class(button, "bx--copy-btn--animating", get(animation));
    toggle_class(button, "bx--copy-btn--fade-in", strict_equals(get(animation), "fade-in"));
    toggle_class(button, "bx--copy-btn--fade-out", strict_equals(get(animation), "fade-out"));
    set_text(text_1, feedback());
  });
  event2("click", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", button, () => {
    if (strict_equals(text2(), void 0, false)) {
      copy()(text2());
      dispatch("copy");
    }
    if (strict_equals(get(animation), "fade-in")) return;
    set(animation, "fade-in");
    set(timeout, setTimeout(
      () => {
        set(animation, "fade-out");
      },
      feedbackTimeout()
    ));
  });
  event2("animationend", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("animationend", button, ({ animationName }) => {
    if (strict_equals(animationName, "hide-feedback")) {
      set(animation, void 0);
    }
  });
  append($$anchor, button);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CopyButton = hmr(CopyButton, () => CopyButton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CopyButton[HMR].source;
    set(CopyButton[HMR].source, module.default[HMR].original);
  });
}
var CopyButton_default = CopyButton;
mark_module_end(CopyButton);

// node_modules/carbon-components-svelte/src/icons/WarningFilled.svelte
mark_module_start();
WarningFilled[FILENAME] = "node_modules/carbon-components-svelte/src/icons/WarningFilled.svelte";
var root_111 = add_locations(ns_template(`<title> </title>`), WarningFilled[FILENAME], [[24, 13]]);
var root21 = add_locations(ns_template(`<svg><!><path d="M16,2C8.3,2,2,8.3,2,16s6.3,14,14,14s14-6.3,14-14C30,8.3,23.7,2,16,2z M14.9,8h2.2v11h-2.2V8z M16,25	c-0.8,0-1.5-0.7-1.5-1.5S15.2,22,16,22c0.8,0,1.5,0.7,1.5,1.5S16.8,25,16,25z"></path><path fill="none" d="M17.5,23.5c0,0.8-0.7,1.5-1.5,1.5c-0.8,0-1.5-0.7-1.5-1.5S15.2,22,16,22	C16.8,22,17.5,22.7,17.5,23.5z M17.1,8h-2.2v11h2.2V8z" data-icon-path="inner-path" opacity="0"></path></svg>`), WarningFilled[FILENAME], [[14, 0, [[25, 2], [27, 10]]]]);
function WarningFilled($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, WarningFilled);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root21();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_111();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next(2);
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  WarningFilled = hmr(WarningFilled, () => WarningFilled[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WarningFilled[HMR].source;
    set(WarningFilled[HMR].source, module.default[HMR].original);
  });
}
var WarningFilled_default = WarningFilled;
mark_module_end(WarningFilled);

// node_modules/carbon-components-svelte/src/icons/WarningAltFilled.svelte
mark_module_start();
WarningAltFilled[FILENAME] = "node_modules/carbon-components-svelte/src/icons/WarningAltFilled.svelte";
var root_112 = add_locations(ns_template(`<title> </title>`), WarningAltFilled[FILENAME], [[24, 13]]);
var root22 = add_locations(ns_template(`<svg><!><path fill="none" d="M16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Zm-1.125-5h2.25V12h-2.25Z" data-icon-path="inner-path"></path><path d="M16.002,6.1714h-.004L4.6487,27.9966,4.6506,28H27.3494l.0019-.0034ZM14.875,12h2.25v9h-2.25ZM16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Z"></path><path d="M29,30H3a1,1,0,0,1-.8872-1.4614l13-25a1,1,0,0,1,1.7744,0l13,25A1,1,0,0,1,29,30ZM4.6507,28H27.3493l.002-.0033L16.002,6.1714h-.004L4.6487,27.9967Z"></path></svg>`), WarningAltFilled[FILENAME], [
  [
    14,
    0,
    [[25, 2], [28, 39], [30, 10]]
  ]
]);
function WarningAltFilled($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, WarningAltFilled);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root22();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_112();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next(3);
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  WarningAltFilled = hmr(WarningAltFilled, () => WarningAltFilled[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WarningAltFilled[HMR].source;
    set(WarningAltFilled[HMR].source, module.default[HMR].original);
  });
}
var WarningAltFilled_default = WarningAltFilled;
mark_module_end(WarningAltFilled);

// node_modules/carbon-components-svelte/src/ListBox/ListBox.svelte
mark_module_start();
ListBox[FILENAME] = "node_modules/carbon-components-svelte/src/ListBox/ListBox.svelte";
var root_113 = add_locations(template(`<div> </div>`), ListBox[FILENAME], [[60, 2]]);
var root_29 = add_locations(template(`<div> </div>`), ListBox[FILENAME], [[63, 2]]);
var root23 = add_locations(template(`<div><!></div> <!> <!>`, 1), ListBox[FILENAME], [[36, 0]]);
function ListBox($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "size",
    "type",
    "open",
    "light",
    "disabled",
    "invalid",
    "invalidText",
    "warn",
    "warnText"
  ]);
  push($$props, false, ListBox);
  let size = prop($$props, "size", 8, void 0);
  let type = prop($$props, "type", 8, "default");
  let open = prop($$props, "open", 8, false);
  let light = prop($$props, "light", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let invalid = prop($$props, "invalid", 8, false);
  let invalidText = prop($$props, "invalidText", 8, "");
  let warn = prop($$props, "warn", 8, false);
  let warnText = prop($$props, "warnText", 8, "");
  var fragment = root23();
  var div = first_child(fragment);
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  var node_1 = sibling(div, 2);
  {
    var consequent = ($$anchor2) => {
      var div_1 = root_113();
      toggle_class(div_1, "bx--form-requirement", true);
      var text2 = child(div_1, true);
      reset(div_1);
      template_effect(() => set_text(text2, invalidText()));
      append($$anchor2, div_1);
    };
    if_block(node_1, ($$render) => {
      if (invalid()) $$render(consequent);
    });
  }
  var node_2 = sibling(node_1, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var div_2 = root_29();
      toggle_class(div_2, "bx--form-requirement", true);
      var text_1 = child(div_2, true);
      reset(div_2);
      template_effect(() => set_text(text_1, warnText()));
      append($$anchor2, div_2);
    };
    if_block(node_2, ($$render) => {
      if (!invalid() && warn()) $$render(consequent_1);
    });
  }
  template_effect(() => {
    attributes = set_attributes(div, attributes, {
      role: "listbox",
      tabindex: "-1",
      "data-invalid": invalid() || void 0,
      ...$$restProps
    });
    toggle_class(div, "bx--list-box", true);
    toggle_class(div, "bx--list-box--sm", strict_equals(size(), "sm"));
    toggle_class(div, "bx--list-box--xl", strict_equals(size(), "xl"));
    toggle_class(div, "bx--list-box--inline", strict_equals(type(), "inline"));
    toggle_class(div, "bx--list-box--disabled", disabled());
    toggle_class(div, "bx--list-box--expanded", open());
    toggle_class(div, "bx--list-box--light", light());
    toggle_class(div, "bx--list-box--warning", !invalid() && warn());
  });
  event2("keydown", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", div, (e) => {
    if (strict_equals(e.key, "Escape")) {
      e.stopPropagation();
    }
  });
  event2("click", div, preventDefault(function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ListBox = hmr(ListBox, () => ListBox[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ListBox[HMR].source;
    set(ListBox[HMR].source, module.default[HMR].original);
  });
}
var ListBox_default = ListBox;
mark_module_end(ListBox);

// node_modules/carbon-components-svelte/src/ListBox/ListBoxField.svelte
mark_module_start();
ListBoxField[FILENAME] = "node_modules/carbon-components-svelte/src/ListBox/ListBoxField.svelte";
var root24 = add_locations(template(`<div><!></div>`), ListBoxField[FILENAME], [[47, 0]]);
function ListBoxField($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "translationIds",
    "disabled",
    "role",
    "tabindex",
    "translateWithId",
    "id",
    "ref"
  ]);
  push($$props, false, ListBoxField);
  const ariaExpanded = mutable_state();
  const menuId = mutable_state();
  let disabled = prop($$props, "disabled", 8, false);
  let role = prop($$props, "role", 8, "combobox");
  let tabindex = prop($$props, "tabindex", 8, "-1");
  const translationIds = { close: "close", open: "open" };
  let translateWithId = prop($$props, "translateWithId", 8, (id2) => defaultTranslations[id2]);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let ref = prop($$props, "ref", 12, null);
  const defaultTranslations = {
    [translationIds.close]: "Close menu",
    [translationIds.open]: "Open menu"
  };
  const ctx = getContext("MultiSelect");
  legacy_pre_effect(() => deep_read_state(ref()), () => {
    if (ctx && ref()) {
      ctx.declareRef({ key: "field", ref: ref() });
    }
  });
  legacy_pre_effect(() => deep_read_state($$sanitized_props), () => {
    set(ariaExpanded, $$sanitized_props["aria-expanded"]);
  });
  legacy_pre_effect(() => deep_read_state(id()), () => {
    set(menuId, `menu-${id()}`);
  });
  legacy_pre_effect_reset();
  init();
  var div = root24();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  bind_this(div, ($$value) => ref($$value), () => ref());
  template_effect(
    ($0) => {
      attributes = set_attributes(div, attributes, {
        role: role(),
        "aria-expanded": get(ariaExpanded),
        "aria-owns": get(ariaExpanded) && get(menuId) || void 0,
        "aria-controls": get(ariaExpanded) && get(menuId) || void 0,
        "aria-disabled": disabled(),
        "aria-label": $0,
        tabindex: disabled() ? "-1" : tabindex(),
        ...$$restProps
      });
      toggle_class(div, "bx--list-box__field", true);
    },
    [
      () => get(ariaExpanded) ? translateWithId()("close") : translateWithId()("open")
    ],
    derived_safe_equal
  );
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", div, stopPropagation(function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  }));
  event2("focus", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("blur", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  bind_prop($$props, "translationIds", translationIds);
  return pop({
    get translationIds() {
      return translationIds;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  ListBoxField = hmr(ListBoxField, () => ListBoxField[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ListBoxField[HMR].source;
    set(ListBoxField[HMR].source, module.default[HMR].original);
  });
}
var ListBoxField_default = ListBoxField;
mark_module_end(ListBoxField);

// node_modules/carbon-components-svelte/src/ListBox/ListBoxMenu.svelte
mark_module_start();
ListBoxMenu[FILENAME] = "node_modules/carbon-components-svelte/src/ListBox/ListBoxMenu.svelte";
var root25 = add_locations(template(`<div><!></div>`), ListBoxMenu[FILENAME], [[9, 0]]);
function ListBoxMenu($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["id", "ref"]);
  push($$props, false, ListBoxMenu);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let ref = prop($$props, "ref", 12, null);
  init();
  var div = root25();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  bind_this(div, ($$value) => ref($$value), () => ref());
  template_effect(() => {
    attributes = set_attributes(div, attributes, {
      role: "listbox",
      id: `menu-${id() ?? ""}`,
      ...$$restProps
    });
    toggle_class(div, "bx--list-box__menu", true);
  });
  event2("scroll", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ListBoxMenu = hmr(ListBoxMenu, () => ListBoxMenu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ListBoxMenu[HMR].source;
    set(ListBoxMenu[HMR].source, module.default[HMR].original);
  });
}
var ListBoxMenu_default = ListBoxMenu;
mark_module_end(ListBoxMenu);

// node_modules/carbon-components-svelte/src/icons/ChevronDown.svelte
mark_module_start();
ChevronDown[FILENAME] = "node_modules/carbon-components-svelte/src/icons/ChevronDown.svelte";
var root_114 = add_locations(ns_template(`<title> </title>`), ChevronDown[FILENAME], [[24, 13]]);
var root26 = add_locations(ns_template(`<svg><!><path d="M16 22L6 12 7.4 10.6 16 19.2 24.6 10.6 26 12z"></path></svg>`), ChevronDown[FILENAME], [[14, 0, [[25, 2]]]]);
function ChevronDown($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, ChevronDown);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root26();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_114();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next();
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChevronDown = hmr(ChevronDown, () => ChevronDown[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronDown[HMR].source;
    set(ChevronDown[HMR].source, module.default[HMR].original);
  });
}
var ChevronDown_default = ChevronDown;
mark_module_end(ChevronDown);

// node_modules/carbon-components-svelte/src/ListBox/ListBoxMenuIcon.svelte
mark_module_start();
ListBoxMenuIcon[FILENAME] = "node_modules/carbon-components-svelte/src/ListBox/ListBoxMenuIcon.svelte";
var root27 = add_locations(template(`<div><!></div>`), ListBoxMenuIcon[FILENAME], [[31, 0]]);
function ListBoxMenuIcon($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["translationIds", "open", "translateWithId"]);
  push($$props, false, ListBoxMenuIcon);
  const translationId = mutable_state();
  const description = mutable_state();
  let open = prop($$props, "open", 8, false);
  const translationIds = { close: "close", open: "open" };
  let translateWithId = prop($$props, "translateWithId", 8, (id) => defaultTranslations[id]);
  const defaultTranslations = {
    [translationIds.close]: "Close menu",
    [translationIds.open]: "Open menu"
  };
  legacy_pre_effect(() => deep_read_state(open()), () => {
    set(translationId, open() ? translationIds.close : translationIds.open);
  });
  legacy_pre_effect(
    () => (deep_read_state(translateWithId()), get(translationId)),
    () => {
      var _a;
      set(description, ((_a = translateWithId()) == null ? void 0 : _a(get(translationId))) ?? defaultTranslations[get(translationId)]);
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root27();
  let attributes;
  var node = child(div);
  ChevronDown_default(node, {
    get "aria-label"() {
      return get(description);
    },
    get title() {
      return get(description);
    }
  });
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--list-box__menu-icon", true);
    toggle_class(div, "bx--list-box__menu-icon--open", open());
  });
  event2("click", div, preventDefault(function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  }));
  append($$anchor, div);
  bind_prop($$props, "translationIds", translationIds);
  return pop({
    get translationIds() {
      return translationIds;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  ListBoxMenuIcon = hmr(ListBoxMenuIcon, () => ListBoxMenuIcon[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ListBoxMenuIcon[HMR].source;
    set(ListBoxMenuIcon[HMR].source, module.default[HMR].original);
  });
}
var ListBoxMenuIcon_default = ListBoxMenuIcon;
mark_module_end(ListBoxMenuIcon);

// node_modules/carbon-components-svelte/src/ListBox/ListBoxMenuItem.svelte
mark_module_start();
ListBoxMenuItem[FILENAME] = "node_modules/carbon-components-svelte/src/ListBox/ListBoxMenuItem.svelte";
var root28 = add_locations(template(`<div><div><!></div></div>`), ListBoxMenuItem[FILENAME], [[21, 0, [[34, 2]]]]);
function ListBoxMenuItem($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["active", "highlighted", "disabled"]);
  push($$props, false, ListBoxMenuItem);
  const isTruncated = mutable_state();
  const title = mutable_state();
  let active = prop($$props, "active", 8, false);
  let highlighted = prop($$props, "highlighted", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let ref = mutable_state(null);
  legacy_pre_effect(() => get(ref), () => {
    var _a, _b;
    set(isTruncated, ((_a = get(ref)) == null ? void 0 : _a.offsetWidth) < ((_b = get(ref)) == null ? void 0 : _b.scrollWidth));
  });
  legacy_pre_effect(() => (get(isTruncated), get(ref)), () => {
    var _a;
    set(title, get(isTruncated) ? (_a = get(ref)) == null ? void 0 : _a.innerText : void 0);
  });
  legacy_pre_effect(
    () => (deep_read_state(highlighted()), get(ref)),
    () => {
      if (highlighted() && get(ref) && !get(ref).matches(":hover")) {
        get(ref).scrollIntoView({ block: "nearest" });
      }
    }
  );
  legacy_pre_effect_reset();
  var div = root28();
  let attributes;
  var div_1 = child(div);
  var node = child(div_1);
  slot(node, $$props, "default", {}, null);
  reset(div_1);
  bind_this(div_1, ($$value) => set(ref, $$value), () => get(ref));
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, {
      role: "option",
      tabindex: "-1",
      "aria-selected": active(),
      disabled: disabled() ? true : void 0,
      ...$$restProps
    });
    toggle_class(div, "bx--list-box__menu-item", true);
    toggle_class(div, "bx--list-box__menu-item--active", active());
    toggle_class(div, "bx--list-box__menu-item--highlighted", highlighted() || active());
    set_attribute(div_1, "title", get(title));
    toggle_class(div_1, "bx--list-box__menu-item__option", true);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ListBoxMenuItem = hmr(ListBoxMenuItem, () => ListBoxMenuItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ListBoxMenuItem[HMR].source;
    set(ListBoxMenuItem[HMR].source, module.default[HMR].original);
  });
}
var ListBoxMenuItem_default = ListBoxMenuItem;
mark_module_end(ListBoxMenuItem);

// node_modules/carbon-components-svelte/src/icons/Close.svelte
mark_module_start();
Close[FILENAME] = "node_modules/carbon-components-svelte/src/icons/Close.svelte";
var root_115 = add_locations(ns_template(`<title> </title>`), Close[FILENAME], [[24, 13]]);
var root29 = add_locations(ns_template(`<svg><!><path d="M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"></path></svg>`), Close[FILENAME], [[14, 0, [[25, 2]]]]);
function Close($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, Close);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root29();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_115();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next();
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Close = hmr(Close, () => Close[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Close[HMR].source;
    set(Close[HMR].source, module.default[HMR].original);
  });
}
var Close_default = Close;
mark_module_end(Close);

// node_modules/carbon-components-svelte/src/ListBox/ListBoxSelection.svelte
mark_module_start();
ListBoxSelection[FILENAME] = "node_modules/carbon-components-svelte/src/ListBox/ListBoxSelection.svelte";
var root_116 = add_locations(template(`<div><span> </span> <div role="button"><!></div></div>`), ListBoxSelection[FILENAME], [[57, 2, [[63, 4], [66, 4]]]]);
var root_210 = add_locations(template(`<div><!> <!></div>`), ListBoxSelection[FILENAME], [[89, 2]]);
function ListBoxSelection($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "translationIds",
    "selectionCount",
    "disabled",
    "translateWithId",
    "ref"
  ]);
  push($$props, false, ListBoxSelection);
  const translationId = mutable_state();
  const description = mutable_state();
  let selectionCount = prop($$props, "selectionCount", 8, void 0);
  let disabled = prop($$props, "disabled", 8, false);
  const translationIds = {
    clearAll: "clearAll",
    clearSelection: "clearSelection"
  };
  let translateWithId = prop($$props, "translateWithId", 8, (id) => defaultTranslations[id]);
  let ref = prop($$props, "ref", 12, null);
  const defaultTranslations = {
    [translationIds.clearAll]: "Clear all selected items",
    [translationIds.clearSelection]: "Clear selected item"
  };
  const dispatch = createEventDispatcher();
  const ctx = getContext("MultiSelect");
  legacy_pre_effect(() => deep_read_state(ref()), () => {
    if (ctx && ref()) {
      ctx.declareRef({ key: "selection", ref: ref() });
    }
  });
  legacy_pre_effect(() => deep_read_state(selectionCount()), () => {
    set(translationId, selectionCount() ? translationIds.clearAll : translationIds.clearSelection);
  });
  legacy_pre_effect(
    () => (deep_read_state(translateWithId()), get(translationId)),
    () => {
      var _a;
      set(description, ((_a = translateWithId()) == null ? void 0 : _a(get(translationId))) ?? defaultTranslations[get(translationId)]);
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_116();
      toggle_class(div, "bx--tag", true);
      toggle_class(div, "bx--tag--filter", true);
      toggle_class(div, "bx--tag--high-contrast", true);
      var span = child(div);
      var text2 = child(span, true);
      reset(span);
      var div_1 = sibling(span, 2);
      var node_1 = child(div_1);
      Close_default(node_1, {});
      reset(div_1);
      bind_this(div_1, ($$value) => ref($$value), () => ref());
      reset(div);
      template_effect(() => {
        toggle_class(div, "bx--tag--disabled", disabled());
        set_attribute(span, "title", selectionCount());
        toggle_class(span, "bx--tag__label", true);
        set_text(text2, selectionCount());
        set_attribute(div_1, "tabindex", disabled() ? -1 : 0);
        div_1.disabled = disabled();
        set_attribute(div_1, "aria-label", translationIds.clearAll);
        set_attribute(div_1, "title", get(description));
        toggle_class(div_1, "bx--tag__close-icon", true);
      });
      event2("click", div_1, preventDefault(stopPropagation((e) => {
        if (!disabled()) {
          dispatch("clear", e);
        }
      })));
      event2("keydown", div_1, stopPropagation((e) => {
        if (!disabled() && strict_equals(e.key, "Enter")) {
          dispatch("clear", e);
        }
      }));
      append($$anchor2, div);
    };
    var alternate = ($$anchor2) => {
      var div_2 = root_210();
      let attributes;
      var node_2 = child(div_2);
      {
        var consequent_1 = ($$anchor3) => {
          var text_1 = text();
          template_effect(() => set_text(text_1, selectionCount()));
          append($$anchor3, text_1);
        };
        if_block(node_2, ($$render) => {
          if (strict_equals(selectionCount(), void 0, false)) $$render(consequent_1);
        });
      }
      var node_3 = sibling(node_2, 2);
      Close_default(node_3, {});
      reset(div_2);
      bind_this(div_2, ($$value) => ref($$value), () => ref());
      template_effect(() => {
        attributes = set_attributes(div_2, attributes, {
          role: "button",
          "aria-label": get(description),
          title: get(description),
          tabindex: disabled() ? "-1" : "0",
          ...$$restProps
        });
        toggle_class(div_2, "bx--list-box__selection", true);
        toggle_class(div_2, "bx--tag--filter", selectionCount());
        toggle_class(div_2, "bx--list-box__selection--multi", selectionCount());
      });
      event2("click", div_2, preventDefault(stopPropagation((e) => {
        if (!disabled()) {
          dispatch("clear", e);
        }
      })));
      event2("keydown", div_2, stopPropagation((e) => {
        if (!disabled() && strict_equals(e.key, "Enter")) {
          dispatch("clear", e);
        }
      }));
      append($$anchor2, div_2);
    };
    if_block(node, ($$render) => {
      if (strict_equals(selectionCount(), void 0, false)) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  bind_prop($$props, "translationIds", translationIds);
  return pop({
    get translationIds() {
      return translationIds;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  ListBoxSelection = hmr(ListBoxSelection, () => ListBoxSelection[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ListBoxSelection[HMR].source;
    set(ListBoxSelection[HMR].source, module.default[HMR].original);
  });
}
var ListBoxSelection_default = ListBoxSelection;
mark_module_end(ListBoxSelection);

// node_modules/carbon-components-svelte/src/ComboBox/ComboBox.svelte
mark_module_start();
ComboBox[FILENAME] = "node_modules/carbon-components-svelte/src/ComboBox/ComboBox.svelte";
var root_117 = add_locations(template(`<label><!></label>`), ComboBox[FILENAME], [[223, 4]]);
var root_42 = add_locations(template(`<input> <!> <!> <!> <!>`, 1), ComboBox[FILENAME], [[260, 6]]);
var root_118 = add_locations(template(`<!> <!>`, 1), ComboBox[FILENAME], []);
var root_32 = add_locations(template(`<!> <!>`, 1), ComboBox[FILENAME], []);
var root_142 = add_locations(template(`<div> </div>`), ComboBox[FILENAME], [[419, 4]]);
var root30 = add_locations(template(`<div><!> <!> <!></div>`), ComboBox[FILENAME], [[221, 0]]);
function ComboBox($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "clear",
    "items",
    "itemToString",
    "selectedId",
    "value",
    "direction",
    "size",
    "disabled",
    "titleText",
    "placeholder",
    "helperText",
    "invalidText",
    "invalid",
    "warn",
    "warnText",
    "light",
    "open",
    "shouldFilterItem",
    "translateWithId",
    "translateWithIdSelection",
    "id",
    "name",
    "ref",
    "listRef"
  ]);
  push($$props, false, ComboBox);
  const ariaLabel = mutable_state();
  const menuId = mutable_state();
  const comboId = mutable_state();
  const highlightedId = mutable_state();
  const filteredItems = mutable_state();
  let items = prop($$props, "items", 24, () => []);
  let itemToString = prop($$props, "itemToString", 8, (item) => item.text || item.id);
  let selectedId = prop($$props, "selectedId", 12, void 0);
  let value = prop($$props, "value", 12, "");
  let direction = prop($$props, "direction", 8, "bottom");
  let size = prop($$props, "size", 8, void 0);
  let disabled = prop($$props, "disabled", 8, false);
  let titleText = prop($$props, "titleText", 8, "");
  let placeholder = prop($$props, "placeholder", 8, "");
  let helperText = prop($$props, "helperText", 8, "");
  let invalidText = prop($$props, "invalidText", 8, "");
  let invalid = prop($$props, "invalid", 8, false);
  let warn = prop($$props, "warn", 8, false);
  let warnText = prop($$props, "warnText", 8, "");
  let light = prop($$props, "light", 8, false);
  let open = prop($$props, "open", 12, false);
  let shouldFilterItem = prop($$props, "shouldFilterItem", 8, () => true);
  let translateWithId = prop($$props, "translateWithId", 8, void 0);
  let translateWithIdSelection = prop($$props, "translateWithIdSelection", 8, void 0);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let name = prop($$props, "name", 8, void 0);
  let ref = prop($$props, "ref", 12, null);
  let listRef = prop($$props, "listRef", 12, null);
  const dispatch = createEventDispatcher();
  let selectedItem = mutable_state(void 0);
  let prevSelectedId = mutable_state(null);
  let highlightedIndex = mutable_state(-1);
  function change(dir) {
    var _a;
    let index2 = get(highlightedIndex) + dir;
    let _items = !((_a = get(filteredItems)) == null ? void 0 : _a.length) ? items() : get(filteredItems);
    if (strict_equals(_items.length, 0)) return;
    if (index2 < 0) {
      index2 = _items.length - 1;
    } else if (index2 >= _items.length) {
      index2 = 0;
    }
    let disabled2 = items()[index2].disabled;
    while (disabled2) {
      index2 = index2 + dir;
      if (index2 < 0) {
        index2 = items().length - 1;
      } else if (index2 >= items().length) {
        index2 = 0;
      }
      disabled2 = items()[index2].disabled;
    }
    set(highlightedIndex, index2);
  }
  function clear(options = {}) {
    var _a;
    set(prevSelectedId, null);
    set(highlightedIndex, -1);
    set(highlightedId, void 0);
    selectedId(void 0);
    set(selectedItem, void 0);
    open(false);
    value("");
    if (strict_equals(options == null ? void 0 : options.focus, false, false)) (_a = ref()) == null ? void 0 : _a.focus();
  }
  afterUpdate(() => {
    if (open()) {
      ref().focus();
      set(filteredItems, items().filter((item) => shouldFilterItem()(item, value())));
    } else {
      set(highlightedIndex, -1);
      set(filteredItems, []);
      if (!get(selectedItem)) {
        selectedId(void 0);
        value("");
        set(highlightedIndex, -1);
        set(highlightedId, void 0);
      } else {
        value(itemToString()(get(selectedItem)));
      }
    }
  });
  legacy_pre_effect(
    () => (deep_read_state(items()), deep_read_state(shouldFilterItem()), deep_read_state(value())),
    () => {
      set(filteredItems, items().filter((item) => shouldFilterItem()(item, value())));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(selectedId()), get(prevSelectedId), get(filteredItems), deep_read_state(open()), get(selectedItem), deep_read_state(items())),
    () => {
      var _a;
      if (strict_equals(selectedId(), void 0, false)) {
        if (strict_equals(get(prevSelectedId), selectedId(), false)) {
          set(prevSelectedId, selectedId());
          if (strict_equals((_a = get(filteredItems)) == null ? void 0 : _a.length, 1) && open()) {
            selectedId(get(filteredItems)[0].id);
            set(selectedItem, get(filteredItems)[0]);
            set(highlightedIndex, -1);
            set(highlightedId, void 0);
          } else {
            set(selectedItem, items().find((item) => strict_equals(item.id, selectedId())));
          }
          dispatch("select", {
            selectedId: selectedId(),
            selectedItem: get(selectedItem)
          });
        }
      } else {
        set(prevSelectedId, selectedId());
        set(selectedItem, void 0);
      }
    }
  );
  legacy_pre_effect(() => deep_read_state($$sanitized_props), () => {
    set(ariaLabel, $$sanitized_props["aria-label"] || "Choose an item");
  });
  legacy_pre_effect(() => deep_read_state(id()), () => {
    set(menuId, `menu-${id()}`);
  });
  legacy_pre_effect(() => deep_read_state(id()), () => {
    set(comboId, `combo-${id()}`);
  });
  legacy_pre_effect(
    () => (deep_read_state(items()), get(highlightedIndex)),
    () => {
      set(highlightedId, items()[get(highlightedIndex)] ? items()[get(highlightedIndex)].id : 0);
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root30();
  event2("click", $window, ({ target }) => {
    if (open() && ref() && !ref().contains(target)) {
      open(false);
    }
  });
  toggle_class(div, "bx--list-box__wrapper", true);
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var label = root_117();
      var node_1 = child(label);
      slot(node_1, $$props, "titleText", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, titleText()));
        append($$anchor3, text2);
      });
      reset(label);
      template_effect(() => {
        set_attribute(label, "for", id());
        toggle_class(label, "bx--label", true);
        toggle_class(label, "bx--label--disabled", disabled());
      });
      append($$anchor2, label);
    };
    if_block(node, ($$render) => {
      if (titleText() || $$slots.titleText) $$render(consequent);
    });
  }
  var node_2 = sibling(node, 2);
  const expression = derived_safe_equal(() => strict_equals(direction(), "top") && "bx--list-box--up");
  const expression_1 = derived_safe_equal(() => !invalid() && warn() && "bx--combo-box--warning");
  ListBox_default(node_2, {
    get class() {
      return `bx--combo-box ${get(expression) ?? ""} ${get(expression_1) ?? ""}`;
    },
    get id() {
      return get(comboId);
    },
    get "aria-label"() {
      return get(ariaLabel);
    },
    get disabled() {
      return disabled();
    },
    get invalid() {
      return invalid();
    },
    get invalidText() {
      return invalidText();
    },
    get open() {
      return open();
    },
    get light() {
      return light();
    },
    get size() {
      return size();
    },
    get warn() {
      return warn();
    },
    get warnText() {
      return warnText();
    },
    children: wrap_snippet(ComboBox, ($$anchor2, $$slotProps) => {
      var fragment_1 = root_32();
      var node_3 = first_child(fragment_1);
      ListBoxField_default(node_3, {
        role: "button",
        get "aria-expanded"() {
          return open();
        },
        get id() {
          return id();
        },
        get disabled() {
          return disabled();
        },
        get translateWithId() {
          return translateWithId();
        },
        $$events: {
          click: async () => {
            if (disabled()) return;
            open(true);
            await tick();
            ref().focus();
          }
        },
        children: wrap_snippet(ComboBox, ($$anchor3, $$slotProps2) => {
          var fragment_2 = root_42();
          var input = first_child(fragment_2);
          remove_input_defaults(input);
          let attributes;
          bind_this(input, ($$value) => ref($$value), () => ref());
          var node_4 = sibling(input, 2);
          {
            var consequent_1 = ($$anchor4) => {
              var fragment_3 = comment();
              var node_5 = first_child(fragment_3);
              WarningFilled_default(node_5, { class: "bx--list-box__invalid-icon" });
              append($$anchor4, fragment_3);
            };
            if_block(node_4, ($$render) => {
              if (invalid()) $$render(consequent_1);
            });
          }
          var node_6 = sibling(node_4, 2);
          {
            var consequent_2 = ($$anchor4) => {
              var fragment_4 = comment();
              var node_7 = first_child(fragment_4);
              WarningAltFilled_default(node_7, {
                class: "bx--list-box__invalid-icon bx--list-box__invalid-icon--warning"
              });
              append($$anchor4, fragment_4);
            };
            if_block(node_6, ($$render) => {
              if (!invalid() && warn()) $$render(consequent_2);
            });
          }
          var node_8 = sibling(node_6, 2);
          {
            var consequent_3 = ($$anchor4) => {
              var fragment_5 = comment();
              var node_9 = first_child(fragment_5);
              ListBoxSelection_default(node_9, {
                get translateWithId() {
                  return translateWithIdSelection();
                },
                get disabled() {
                  return disabled();
                },
                get open() {
                  return open();
                },
                $$events: {
                  clear: [
                    function($$arg) {
                      bubble_event.call(this, $$props, $$arg);
                    },
                    clear
                  ]
                }
              });
              append($$anchor4, fragment_5);
            };
            if_block(node_8, ($$render) => {
              if (value()) $$render(consequent_3);
            });
          }
          var node_10 = sibling(node_8, 2);
          ListBoxMenuIcon_default(node_10, {
            get translateWithId() {
              return translateWithId();
            },
            get open() {
              return open();
            },
            $$events: {
              click: (e) => {
                if (disabled()) return;
                e.stopPropagation();
                open(!open());
              }
            }
          });
          template_effect(() => {
            attributes = set_attributes(input, attributes, {
              tabindex: "0",
              autocomplete: "off",
              "aria-autocomplete": "list",
              "aria-expanded": open(),
              "aria-activedescendant": get(highlightedId),
              "aria-labelledby": get(comboId),
              "aria-disabled": disabled(),
              "aria-controls": open() ? get(menuId) : void 0,
              "aria-owns": open() ? get(menuId) : void 0,
              disabled: disabled(),
              placeholder: placeholder(),
              id: id(),
              name: name(),
              ...$$restProps
            });
            toggle_class(input, "bx--text-input", true);
            toggle_class(input, "bx--text-input--light", light());
            toggle_class(input, "bx--text-input--empty", strict_equals(value(), ""));
          });
          bind_value(input, value);
          event2("input", input, ({ target }) => {
            if (!open() && target.value.length > 0) {
              open(true);
            }
            if (!value().length) {
              clear();
              open(true);
            }
          });
          event2("keydown", input, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event2("keydown", input, stopPropagation((e) => {
            var _a;
            const { key } = e;
            if (["Enter", "ArrowDown", "ArrowUp"].includes(key)) {
              e.preventDefault();
            }
            if (strict_equals(key, "Enter")) {
              open(!open());
              if (get(highlightedIndex) > -1 && strict_equals((_a = get(filteredItems)[get(highlightedIndex)]) == null ? void 0 : _a.id, selectedId(), false)) {
                open(false);
                if (get(filteredItems)[get(highlightedIndex)]) {
                  value(itemToString()(get(filteredItems)[get(highlightedIndex)]));
                  set(selectedItem, get(filteredItems)[get(highlightedIndex)]);
                  selectedId(get(filteredItems)[get(highlightedIndex)].id);
                }
              } else {
                const matchedItem = get(filteredItems).find((e2) => {
                  var _a2;
                  return strict_equals(e2.text.toLowerCase(), (_a2 = value()) == null ? void 0 : _a2.toLowerCase()) && !e2.disabled;
                }) ?? get(filteredItems).find((e2) => !e2.disabled);
                if (matchedItem) {
                  open(false);
                  set(selectedItem, matchedItem);
                  value(itemToString()(get(selectedItem)));
                  selectedId(get(selectedItem).id);
                }
              }
              set(highlightedIndex, -1);
            } else if (strict_equals(key, "Tab")) {
              open(false);
            } else if (strict_equals(key, "ArrowDown")) {
              change(1);
            } else if (strict_equals(key, "ArrowUp")) {
              change(-1);
            } else if (strict_equals(key, "Escape")) {
              open(false);
            }
          }));
          event2("keyup", input, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event2("focus", input, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event2("blur", input, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event2("blur", input, ({ relatedTarget }) => {
            if (!open() || !relatedTarget) return;
            if (relatedTarget && !["INPUT", "SELECT", "TEXTAREA"].includes(relatedTarget.tagName) && strict_equals(relatedTarget.getAttribute("role"), "button", false) && strict_equals(relatedTarget.getAttribute("role"), "searchbox", false)) {
              ref().focus();
            }
          });
          event2("paste", input, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          append($$anchor3, fragment_2);
        }),
        $$slots: { default: true }
      });
      var node_11 = sibling(node_3, 2);
      {
        var consequent_5 = ($$anchor3) => {
          var fragment_6 = comment();
          var node_12 = first_child(fragment_6);
          {
            add_owner_effect(listRef, ListBoxMenu_default);
            ListBoxMenu_default(node_12, {
              get "aria-label"() {
                return get(ariaLabel);
              },
              get id() {
                return id();
              },
              get ref() {
                return listRef();
              },
              set ref($$value) {
                listRef($$value);
              },
              $$events: {
                scroll($$arg) {
                  bubble_event.call(this, $$props, $$arg);
                }
              },
              children: wrap_snippet(ComboBox, ($$anchor4, $$slotProps2) => {
                var fragment_7 = comment();
                var node_13 = first_child(fragment_7);
                validate_each_keys(() => get(filteredItems), (item) => item.id);
                each(node_13, 3, () => get(filteredItems), (item) => item.id, ($$anchor5, item, i) => {
                  var fragment_8 = comment();
                  var node_14 = first_child(fragment_8);
                  const expression_2 = derived_safe_equal(() => strict_equals(selectedId(), get(item).id));
                  const expression_3 = derived_safe_equal(() => strict_equals(get(highlightedIndex), get(i)));
                  ListBoxMenuItem_default(node_14, {
                    get id() {
                      return get(item).id;
                    },
                    get active() {
                      return get(expression_2);
                    },
                    get highlighted() {
                      return get(expression_3);
                    },
                    get disabled() {
                      return get(item).disabled;
                    },
                    $$events: {
                      click: (e) => {
                        if (get(item).disabled) {
                          e.stopPropagation();
                          return;
                        }
                        selectedId(get(item).id);
                        open(false);
                        if (get(filteredItems)[get(i)]) {
                          value(itemToString()(get(filteredItems)[get(i)]));
                        }
                      },
                      mouseenter: () => {
                        if (get(item).disabled) return;
                        set(highlightedIndex, get(i));
                      }
                    },
                    children: wrap_snippet(ComboBox, ($$anchor6, $$slotProps3) => {
                      var fragment_9 = root_118();
                      var node_15 = first_child(fragment_9);
                      slot(
                        node_15,
                        $$props,
                        "default",
                        {
                          get item() {
                            return get(item);
                          },
                          get index() {
                            return get(i);
                          }
                        },
                        ($$anchor7) => {
                          var text_1 = text();
                          template_effect(($0) => set_text(text_1, $0), [() => itemToString()(get(item))], derived_safe_equal);
                          append($$anchor7, text_1);
                        }
                      );
                      var node_16 = sibling(node_15, 2);
                      {
                        var consequent_4 = ($$anchor7) => {
                          var fragment_11 = comment();
                          var node_17 = first_child(fragment_11);
                          Checkmark_default(node_17, {
                            class: "bx--list-box__menu-item__selected-icon"
                          });
                          append($$anchor7, fragment_11);
                        };
                        if_block(node_16, ($$render) => {
                          if (get(selectedItem) && strict_equals(get(selectedItem).id, get(item).id)) $$render(consequent_4);
                        });
                      }
                      append($$anchor6, fragment_9);
                    }),
                    $$slots: { default: true }
                  });
                  append($$anchor5, fragment_8);
                });
                append($$anchor4, fragment_7);
              }),
              $$slots: { default: true },
              $$legacy: true
            });
          }
          append($$anchor3, fragment_6);
        };
        if_block(node_11, ($$render) => {
          if (open()) $$render(consequent_5);
        });
      }
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  var node_18 = sibling(node_2, 2);
  {
    var consequent_6 = ($$anchor2) => {
      var div_1 = root_142();
      toggle_class(div_1, "bx--form__helper-text", true);
      var text_2 = child(div_1, true);
      reset(div_1);
      template_effect(() => {
        toggle_class(div_1, "bx--form__helper-text--disabled", disabled());
        set_text(text_2, helperText());
      });
      append($$anchor2, div_1);
    };
    if_block(node_18, ($$render) => {
      if (!invalid() && helperText() && !warn()) $$render(consequent_6);
    });
  }
  reset(div);
  append($$anchor, div);
  bind_prop($$props, "clear", clear);
  return pop({
    get clear() {
      return clear;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  ComboBox = hmr(ComboBox, () => ComboBox[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ComboBox[HMR].source;
    set(ComboBox[HMR].source, module.default[HMR].original);
  });
}
var ComboBox_default = ComboBox;
mark_module_end(ComboBox);

// node_modules/carbon-components-svelte/src/Modal/modalStore.js
var stores = /* @__PURE__ */ new Set();
var modalsOpen = writable(0);
var updateModalsOpen = () => modalsOpen.set([...stores].filter((open) => get2(open)).length);
var trackModal = (openStore) => onMount(() => {
  stores.add(openStore);
  const unsubscribe = openStore.subscribe(updateModalsOpen);
  return () => {
    unsubscribe();
    stores.delete(openStore);
    updateModalsOpen();
  };
});
modalsOpen.subscribe((openCount) => {
  if (typeof document !== "undefined")
    document.body.classList.toggle("bx--body--with-modal-open", openCount > 0);
});

// node_modules/carbon-components-svelte/src/ComposedModal/ComposedModal.svelte
mark_module_start();
ComposedModal[FILENAME] = "node_modules/carbon-components-svelte/src/ComposedModal/ComposedModal.svelte";
var root31 = add_locations(template(`<div><div role="dialog" aria-modal="true"><!></div></div>`), ComposedModal[FILENAME], [[100, 0, [[155, 2]]]]);
function ComposedModal($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "size",
    "open",
    "danger",
    "preventCloseOnClickOutside",
    "containerClass",
    "selectorPrimaryFocus",
    "ref"
  ]);
  push($$props, false, ComposedModal);
  const [$$stores, $$cleanup] = setup_stores();
  const $openStore = () => (validate_store(openStore, "openStore"), store_get(openStore, "$openStore", $$stores));
  const $label = () => (validate_store(label, "label"), store_get(label, "$label", $$stores));
  const didOpen = mutable_state();
  let size = prop($$props, "size", 8, void 0);
  let open = prop($$props, "open", 12, false);
  let danger = prop($$props, "danger", 8, false);
  let preventCloseOnClickOutside = prop($$props, "preventCloseOnClickOutside", 8, false);
  let containerClass = prop($$props, "containerClass", 8, "");
  let selectorPrimaryFocus = prop($$props, "selectorPrimaryFocus", 8, "[data-modal-primary-focus]");
  let ref = prop($$props, "ref", 12, null);
  const dispatch = createEventDispatcher();
  const label = writable(void 0);
  let buttonRef = null;
  let innerModal = mutable_state(null);
  let didClickInnerModal = mutable_state(false);
  setContext("ComposedModal", {
    closeModal: () => {
      open(false);
    },
    submit: () => {
      dispatch("submit");
      dispatch("click:button--primary");
    },
    declareRef: (ref2) => {
      buttonRef = ref2;
    },
    updateLabel: (value) => {
      label.set(value);
    }
  });
  function focus(element) {
    var _a;
    if (equals(selectorPrimaryFocus(), null)) return;
    const node = ((_a = element || get(innerModal)) == null ? void 0 : _a.querySelector(selectorPrimaryFocus())) || buttonRef;
    if (equals(node, null, false)) node.focus();
  }
  let opened = false;
  const openStore = writable(open());
  trackModal(openStore);
  onMount(() => {
    tick().then(() => {
      focus();
    });
  });
  afterUpdate(() => {
    if (opened) {
      if (!open()) {
        opened = false;
        dispatch("close");
      }
    } else if (open()) {
      opened = true;
      dispatch("open");
    }
  });
  legacy_pre_effect(() => deep_read_state(open()), () => {
    set(didOpen, open());
  });
  legacy_pre_effect(() => deep_read_state(open()), () => {
    store_set(openStore, open());
  });
  legacy_pre_effect_reset();
  init();
  var div = root31();
  let attributes;
  var div_1 = child(div);
  var node_1 = child(div_1);
  slot(node_1, $$props, "default", {}, null);
  reset(div_1);
  bind_this(div_1, ($$value) => set(innerModal, $$value), () => get(innerModal));
  reset(div);
  bind_this(div, ($$value) => ref($$value), () => ref());
  template_effect(() => {
    attributes = set_attributes(div, attributes, { role: "presentation", ...$$restProps });
    toggle_class(div, "bx--modal", true);
    toggle_class(div, "is-visible", open());
    toggle_class(div, "bx--modal--danger", danger());
    set_attribute(div_1, "aria-label", $$sanitized_props["aria-label"] || $label() || void 0);
    set_class(div_1, containerClass());
    toggle_class(div_1, "bx--modal-container", true);
    toggle_class(div_1, "bx--modal-container--xs", strict_equals(size(), "xs"));
    toggle_class(div_1, "bx--modal-container--sm", strict_equals(size(), "sm"));
    toggle_class(div_1, "bx--modal-container--lg", strict_equals(size(), "lg"));
  });
  event2("click", div_1, () => {
    set(didClickInnerModal, true);
  });
  event2("keydown", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", div, (e) => {
    if (open()) {
      if (strict_equals(e.key, "Escape")) {
        open(false);
      } else if (strict_equals(e.key, "Tab")) {
        const selectorTabbable = `
  a[href], area[href], input:not([disabled]):not([tabindex='-1']),
  button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),
  textarea:not([disabled]):not([tabindex='-1']),
  iframe, object, embed, *[tabindex]:not([tabindex='-1']):not([disabled]), *[contenteditable=true]
`;
        const tabbable = Array.from(ref().querySelectorAll(selectorTabbable));
        let index2 = tabbable.indexOf(document.activeElement);
        if (strict_equals(index2, -1) && e.shiftKey) index2 = 0;
        index2 += tabbable.length + (e.shiftKey ? -1 : 1);
        index2 %= tabbable.length;
        tabbable[index2].focus();
        e.preventDefault();
      }
    }
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", div, () => {
    if (!get(didClickInnerModal) && !preventCloseOnClickOutside()) open(false);
    set(didClickInnerModal, false);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("transitionend", div, ({ propertyName, currentTarget }) => {
    if (strict_equals(propertyName, "transform")) {
      dispatch("transitionend", { open: open() });
    }
    if (get(didOpen)) {
      focus(currentTarget);
      set(didOpen, false);
    }
  });
  append($$anchor, div);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  ComposedModal = hmr(ComposedModal, () => ComposedModal[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ComposedModal[HMR].source;
    set(ComposedModal[HMR].source, module.default[HMR].original);
  });
}
var ComposedModal_default = ComposedModal;
mark_module_end(ComposedModal);

// node_modules/carbon-components-svelte/src/ComposedModal/ModalHeader.svelte
mark_module_start();
ModalHeader[FILENAME] = "node_modules/carbon-components-svelte/src/ComposedModal/ModalHeader.svelte";
var root_119 = add_locations(template(`<h2> </h2>`), ModalHeader[FILENAME], [[33, 4]]);
var root_211 = add_locations(template(`<h3> </h3>`), ModalHeader[FILENAME], [[42, 4]]);
var root32 = add_locations(template(`<div><!> <!> <!> <button type="button"><!></button></div>`), ModalHeader[FILENAME], [[31, 0, [[51, 2]]]]);
function ModalHeader($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "title",
    "label",
    "labelClass",
    "titleClass",
    "closeClass",
    "closeIconClass",
    "iconDescription"
  ]);
  push($$props, false, ModalHeader);
  let title = prop($$props, "title", 8, "");
  let label = prop($$props, "label", 8, "");
  let labelClass = prop($$props, "labelClass", 8, "");
  let titleClass = prop($$props, "titleClass", 8, "");
  let closeClass = prop($$props, "closeClass", 8, "");
  let closeIconClass = prop($$props, "closeIconClass", 8, "");
  let iconDescription = prop($$props, "iconDescription", 8, "Close");
  const { closeModal, updateLabel } = getContext("ComposedModal");
  legacy_pre_effect(() => deep_read_state(label()), () => {
    updateLabel(label());
  });
  legacy_pre_effect_reset();
  init();
  var div = root32();
  let attributes;
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var h2 = root_119();
      var text2 = child(h2, true);
      reset(h2);
      template_effect(() => {
        set_class(h2, labelClass());
        toggle_class(h2, "bx--modal-header__label", true);
        toggle_class(h2, "bx--type-delta", true);
        set_text(text2, label());
      });
      append($$anchor2, h2);
    };
    if_block(node, ($$render) => {
      if (label()) $$render(consequent);
    });
  }
  var node_1 = sibling(node, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var h3 = root_211();
      var text_1 = child(h3, true);
      reset(h3);
      template_effect(() => {
        set_class(h3, titleClass());
        toggle_class(h3, "bx--modal-header__heading", true);
        toggle_class(h3, "bx--type-beta", true);
        set_text(text_1, title());
      });
      append($$anchor2, h3);
    };
    if_block(node_1, ($$render) => {
      if (title()) $$render(consequent_1);
    });
  }
  var node_2 = sibling(node_1, 2);
  slot(node_2, $$props, "default", {}, null);
  var button = sibling(node_2, 2);
  var node_3 = child(button);
  Close_default(node_3, {
    size: 20,
    get class() {
      return `bx--modal-close__icon ${closeIconClass() ?? ""}`;
    },
    "aria-hidden": "true"
  });
  reset(button);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--modal-header", true);
    set_attribute(button, "aria-label", iconDescription());
    set_class(button, closeClass());
    toggle_class(button, "bx--modal-close", true);
  });
  event2("click", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", button, closeModal);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ModalHeader = hmr(ModalHeader, () => ModalHeader[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ModalHeader[HMR].source;
    set(ModalHeader[HMR].source, module.default[HMR].original);
  });
}
var ModalHeader_default = ModalHeader;
mark_module_end(ModalHeader);

// node_modules/carbon-components-svelte/src/ComposedModal/ModalBody.svelte
mark_module_start();
ModalBody[FILENAME] = "node_modules/carbon-components-svelte/src/ComposedModal/ModalBody.svelte";
var root_120 = add_locations(template(`<div></div>`), ModalBody[FILENAME], [[21, 2]]);
var root33 = add_locations(template(`<div><!></div> <!>`, 1), ModalBody[FILENAME], [[10, 0]]);
function ModalBody($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["hasForm", "hasScrollingContent"]);
  push($$props, false, ModalBody);
  let hasForm = prop($$props, "hasForm", 8, false);
  let hasScrollingContent = prop($$props, "hasScrollingContent", 8, false);
  var fragment = root33();
  var div = first_child(fragment);
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  var node_1 = sibling(div, 2);
  {
    var consequent = ($$anchor2) => {
      var div_1 = root_120();
      toggle_class(div_1, "bx--modal-content--overflow-indicator", true);
      append($$anchor2, div_1);
    };
    if_block(node_1, ($$render) => {
      if (hasScrollingContent()) $$render(consequent);
    });
  }
  template_effect(() => {
    attributes = set_attributes(div, attributes, {
      tabindex: hasScrollingContent() ? "0" : void 0,
      role: hasScrollingContent() ? "region" : void 0,
      ...$$restProps
    });
    toggle_class(div, "bx--modal-content", true);
    toggle_class(div, "bx--modal-content--with-form", hasForm());
    toggle_class(div, "bx--modal-scroll-content", hasScrollingContent());
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ModalBody = hmr(ModalBody, () => ModalBody[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ModalBody[HMR].source;
    set(ModalBody[HMR].source, module.default[HMR].original);
  });
}
var ModalBody_default = ModalBody;
mark_module_end(ModalBody);

// node_modules/carbon-components-svelte/src/ComposedModal/ModalFooter.svelte
mark_module_start();
ModalFooter[FILENAME] = "node_modules/carbon-components-svelte/src/ComposedModal/ModalFooter.svelte";
var root34 = add_locations(template(`<div><!> <!> <!></div>`), ModalFooter[FILENAME], [[50, 0]]);
function ModalFooter($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "primaryButtonText",
    "primaryButtonIcon",
    "primaryButtonDisabled",
    "primaryClass",
    "secondaryButtonText",
    "secondaryButtons",
    "secondaryClass",
    "danger"
  ]);
  push($$props, false, ModalFooter);
  let primaryButtonText = prop($$props, "primaryButtonText", 8, "");
  let primaryButtonIcon = prop($$props, "primaryButtonIcon", 8, void 0);
  let primaryButtonDisabled = prop($$props, "primaryButtonDisabled", 8, false);
  let primaryClass = prop($$props, "primaryClass", 8, void 0);
  let secondaryButtonText = prop($$props, "secondaryButtonText", 8, "");
  let secondaryButtons = prop($$props, "secondaryButtons", 24, () => []);
  let secondaryClass = prop($$props, "secondaryClass", 8, void 0);
  let danger = prop($$props, "danger", 8, false);
  const dispatch = createEventDispatcher();
  const { closeModal, submit } = getContext("ComposedModal");
  init();
  var div = root34();
  let attributes;
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      each(node_1, 1, secondaryButtons, index, ($$anchor3, button) => {
        var fragment_1 = comment();
        var node_2 = first_child(fragment_1);
        Button_default(node_2, {
          kind: "secondary",
          $$events: {
            click: () => {
              dispatch("click:button--secondary", { text: get(button).text });
            }
          },
          children: wrap_snippet(ModalFooter, ($$anchor4, $$slotProps) => {
            next();
            var text2 = text();
            template_effect(() => set_text(text2, get(button).text));
            append($$anchor4, text2);
          }),
          $$slots: { default: true }
        });
        append($$anchor3, fragment_1);
      });
      append($$anchor2, fragment);
    };
    var alternate = ($$anchor2) => {
      var fragment_3 = comment();
      var node_3 = first_child(fragment_3);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_4 = first_child(fragment_4);
          Button_default(node_4, {
            kind: "secondary",
            get class() {
              return secondaryClass();
            },
            $$events: {
              click: () => {
                closeModal();
                dispatch("click:button--secondary", { text: secondaryButtonText() });
              }
            },
            children: wrap_snippet(ModalFooter, ($$anchor4, $$slotProps) => {
              next();
              var text_1 = text();
              template_effect(() => set_text(text_1, secondaryButtonText()));
              append($$anchor4, text_1);
            }),
            $$slots: { default: true }
          });
          append($$anchor3, fragment_4);
        };
        if_block(
          node_3,
          ($$render) => {
            if (secondaryButtonText()) $$render(consequent_1);
          },
          true
        );
      }
      append($$anchor2, fragment_3);
    };
    if_block(node, ($$render) => {
      if (secondaryButtons().length > 0) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_5 = sibling(node, 2);
  {
    var consequent_2 = ($$anchor2) => {
      var fragment_6 = comment();
      var node_6 = first_child(fragment_6);
      const expression = derived_safe_equal(() => danger() ? "danger" : "primary");
      Button_default(node_6, {
        get kind() {
          return get(expression);
        },
        get disabled() {
          return primaryButtonDisabled();
        },
        get class() {
          return primaryClass();
        },
        get icon() {
          return primaryButtonIcon();
        },
        $$events: { click: submit },
        children: wrap_snippet(ModalFooter, ($$anchor3, $$slotProps) => {
          next();
          var text_2 = text();
          template_effect(() => set_text(text_2, primaryButtonText()));
          append($$anchor3, text_2);
        }),
        $$slots: { default: true }
      });
      append($$anchor2, fragment_6);
    };
    if_block(node_5, ($$render) => {
      if (primaryButtonText()) $$render(consequent_2);
    });
  }
  var node_7 = sibling(node_5, 2);
  slot(node_7, $$props, "default", {}, null);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--modal-footer", true);
    toggle_class(div, "bx--modal-footer--three-button", strict_equals(secondaryButtons().length, 2));
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ModalFooter = hmr(ModalFooter, () => ModalFooter[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ModalFooter[HMR].source;
    set(ModalFooter[HMR].source, module.default[HMR].original);
  });
}
var ModalFooter_default = ModalFooter;
mark_module_end(ModalFooter);

// node_modules/carbon-components-svelte/src/CodeSnippet/CodeSnippetSkeleton.svelte
mark_module_start();
CodeSnippetSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/CodeSnippet/CodeSnippetSkeleton.svelte";
var root_121 = add_locations(template(`<span></span>`), CodeSnippetSkeleton[FILENAME], [[24, 6]]);
var root_33 = add_locations(template(`<span></span> <span></span> <span></span>`, 1), CodeSnippetSkeleton[FILENAME], [[25, 31], [25, 45], [25, 59]]);
var root35 = add_locations(template(`<div><div><!></div></div>`), CodeSnippetSkeleton[FILENAME], [[11, 0, [[22, 2]]]]);
function CodeSnippetSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["type"]);
  push($$props, false, CodeSnippetSkeleton);
  let type = prop($$props, "type", 8, "single");
  var div = root35();
  let attributes;
  var div_1 = child(div);
  toggle_class(div_1, "bx--snippet-container", true);
  var node = child(div_1);
  {
    var consequent = ($$anchor2) => {
      var span = root_121();
      append($$anchor2, span);
    };
    var alternate = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_1 = root_33();
          next(4);
          append($$anchor3, fragment_1);
        };
        if_block(
          node_1,
          ($$render) => {
            if (strict_equals(type(), "multi")) $$render(consequent_1);
          },
          true
        );
      }
      append($$anchor2, fragment);
    };
    if_block(node, ($$render) => {
      if (strict_equals(type(), "single")) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  reset(div_1);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--skeleton", true);
    toggle_class(div, "bx--snippet", true);
    toggle_class(div, "bx--snippet--single", strict_equals(type(), "single"));
    toggle_class(div, "bx--snippet--multi", strict_equals(type(), "multi"));
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CodeSnippetSkeleton = hmr(CodeSnippetSkeleton, () => CodeSnippetSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodeSnippetSkeleton[HMR].source;
    set(CodeSnippetSkeleton[HMR].source, module.default[HMR].original);
  });
}
var CodeSnippetSkeleton_default = CodeSnippetSkeleton;
mark_module_end(CodeSnippetSkeleton);

// node_modules/carbon-components-svelte/src/CodeSnippet/CodeSnippet.svelte
mark_module_start();
CodeSnippet[FILENAME] = "node_modules/carbon-components-svelte/src/CodeSnippet/CodeSnippet.svelte";
var root_43 = add_locations(template(`<span><code><!></code></span>`), CodeSnippet[FILENAME], [[158, 4, [[169, 6]]]]);
var root_63 = add_locations(template(`<button><code><!></code> <span aria-hidden="true"> </span></button>`), CodeSnippet[FILENAME], [[174, 4, [[208, 6], [211, 6]]]]);
var root_122 = add_locations(template(`<span> </span> <!>`, 1), CodeSnippet[FILENAME], [[272, 8]]);
var root_8 = add_locations(template(`<div><div><pre><code><!></code></pre></div> <!> <!></div>`), CodeSnippet[FILENAME], [
  [
    222,
    2,
    [
      [
        238,
        4,
        [[247, 6, [[247, 29]]]]
      ]
    ]
  ]
]);
function CodeSnippet($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "type",
    "code",
    "copy",
    "expanded",
    "hideCopyButton",
    "disabled",
    "wrapText",
    "light",
    "skeleton",
    "copyButtonDescription",
    "copyLabel",
    "feedback",
    "feedbackTimeout",
    "showLessText",
    "showMoreText",
    "showMoreLess",
    "id",
    "ref"
  ]);
  push($$props, false, CodeSnippet);
  const expandText = mutable_state();
  const minHeight = mutable_state();
  const maxHeight = mutable_state();
  let type = prop($$props, "type", 8, "single");
  let code = prop($$props, "code", 8, void 0);
  let copy = prop($$props, "copy", 8, async (code2) => {
    try {
      await navigator.clipboard.writeText(code2);
    } catch (e) {
      console.log(...log_if_contains_state("log", e));
    }
  });
  let expanded = prop($$props, "expanded", 12, false);
  let hideCopyButton = prop($$props, "hideCopyButton", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let wrapText = prop($$props, "wrapText", 8, false);
  let light = prop($$props, "light", 8, false);
  let skeleton = prop($$props, "skeleton", 8, false);
  let copyButtonDescription = prop($$props, "copyButtonDescription", 8, void 0);
  let copyLabel = prop($$props, "copyLabel", 8, void 0);
  let feedback = prop($$props, "feedback", 8, "Copied!");
  let feedbackTimeout = prop($$props, "feedbackTimeout", 8, 2e3);
  let showLessText = prop($$props, "showLessText", 8, "Show less");
  let showMoreText = prop($$props, "showMoreText", 8, "Show more");
  let showMoreLess = prop($$props, "showMoreLess", 12, true);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let ref = prop($$props, "ref", 12, null);
  const dispatch = createEventDispatcher();
  let animation = mutable_state(void 0);
  let timeout = mutable_state(void 0);
  function setShowMoreLess() {
    const { height } = ref().getBoundingClientRect();
    if (height > 0) showMoreLess(ref().getBoundingClientRect().height > 255);
  }
  onMount(() => {
    return () => clearTimeout(get(timeout));
  });
  legacy_pre_effect(
    () => (deep_read_state(expanded()), deep_read_state(showLessText()), deep_read_state(showMoreText())),
    () => {
      set(expandText, expanded() ? showLessText() : showMoreText());
    }
  );
  legacy_pre_effect(() => deep_read_state(expanded()), () => {
    set(minHeight, expanded() ? 16 * 15 : 48);
  });
  legacy_pre_effect(() => deep_read_state(expanded()), () => {
    set(maxHeight, expanded() ? "none" : 16 * 15 + "px");
  });
  legacy_pre_effect(() => deep_read_state(type()), () => {
    if (strict_equals(type(), "multi", false)) showMoreLess(false);
  });
  legacy_pre_effect(
    () => (deep_read_state(type()), deep_read_state(ref()), deep_read_state(showMoreLess()), deep_read_state(code()), tick),
    () => {
      if (strict_equals(type(), "multi") && ref()) {
        if (showMoreLess()) {
          if (strict_equals(code(), void 0)) setShowMoreLess();
          if (code()) tick().then(setShowMoreLess);
        }
      }
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(type()), deep_read_state(expanded())),
    () => {
      if (strict_equals(type(), "multi")) dispatch(expanded() ? "expand" : "collapse");
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      CodeSnippetSkeleton_default(node_1, spread_props(
        {
          get type() {
            return type();
          }
        },
        () => $$restProps,
        {
          $$events: {
            click($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            mouseover($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            mouseenter($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            mouseleave($$arg) {
              bubble_event.call(this, $$props, $$arg);
            }
          }
        }
      ));
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      {
        var consequent_2 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          {
            var consequent_1 = ($$anchor4) => {
              var span = root_43();
              let attributes;
              var code_1 = child(span);
              var node_4 = child(code_1);
              slot(node_4, $$props, "default", {}, ($$anchor5) => {
                var text2 = text();
                template_effect(() => set_text(text2, code()));
                append($$anchor5, text2);
              });
              reset(code_1);
              reset(span);
              template_effect(() => {
                attributes = set_attributes(span, attributes, { ...$$restProps });
                toggle_class(span, "bx--snippet", true);
                toggle_class(span, "bx--snippet--expand", expanded());
                toggle_class(span, "bx--snippet--light", light());
                toggle_class(span, "bx--snippet--no-copy", hideCopyButton());
                toggle_class(span, "bx--snippet--wraptext", wrapText());
                toggle_class(span, "bx--snippet--single", strict_equals(type(), "single"));
                toggle_class(span, "bx--snippet--inline", strict_equals(type(), "inline"));
                toggle_class(span, "bx--snippet--multi", strict_equals(type(), "multi"));
                set_attribute(code_1, "id", id());
              });
              append($$anchor4, span);
            };
            var alternate = ($$anchor4) => {
              var button = root_63();
              let attributes_1;
              var code_2 = child(button);
              var node_5 = child(code_2);
              slot(node_5, $$props, "default", {}, ($$anchor5) => {
                var text_1 = text();
                template_effect(() => set_text(text_1, code()));
                append($$anchor5, text_1);
              });
              reset(code_2);
              var span_1 = sibling(code_2, 2);
              toggle_class(span_1, "bx--assistive-text", true);
              toggle_class(span_1, "bx--copy-btn__feedback", true);
              var text_2 = child(span_1, true);
              reset(span_1);
              reset(button);
              template_effect(() => {
                attributes_1 = set_attributes(button, attributes_1, {
                  type: "button",
                  "aria-live": "polite",
                  "aria-label": copyLabel(),
                  ...$$restProps
                });
                toggle_class(button, "bx--copy", true);
                toggle_class(button, "bx--btn--copy", true);
                toggle_class(button, "bx--copy-btn--animating", get(animation));
                toggle_class(button, "bx--copy-btn--fade-in", strict_equals(get(animation), "fade-in"));
                toggle_class(button, "bx--copy-btn--fade-out", strict_equals(get(animation), "fade-out"));
                toggle_class(button, "bx--snippet", true);
                toggle_class(button, "bx--snippet--inline", strict_equals(type(), "inline"));
                toggle_class(button, "bx--snippet--expand", expanded());
                toggle_class(button, "bx--snippet--light", light());
                toggle_class(button, "bx--snippet--wraptext", wrapText());
                set_attribute(code_2, "id", id());
                set_text(text_2, feedback());
              });
              event2("click", button, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("click", button, () => {
                copy()(code());
                dispatch("copy");
                if (strict_equals(get(animation), "fade-in")) return;
                set(animation, "fade-in");
                set(timeout, setTimeout(
                  () => {
                    set(animation, "fade-out");
                  },
                  feedbackTimeout()
                ));
              });
              event2("animationend", button, ({ animationName }) => {
                if (strict_equals(animationName, "hide-feedback")) {
                  set(animation, void 0);
                }
              });
              event2("mouseover", button, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("mouseenter", button, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("mouseleave", button, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              append($$anchor4, button);
            };
            if_block(node_3, ($$render) => {
              if (hideCopyButton()) $$render(consequent_1);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_3);
        };
        var alternate_1 = ($$anchor3) => {
          var div = root_8();
          let attributes_2;
          var div_1 = child(div);
          var pre = child(div_1);
          var code_3 = child(pre);
          var node_6 = child(code_3);
          slot(node_6, $$props, "default", {}, ($$anchor4) => {
            var text_3 = text();
            template_effect(() => set_text(text_3, code()));
            append($$anchor4, text_3);
          });
          reset(code_3);
          reset(pre);
          bind_this(pre, ($$value) => ref($$value), () => ref());
          reset(div_1);
          var node_7 = sibling(div_1, 2);
          {
            var consequent_3 = ($$anchor4) => {
              var fragment_7 = comment();
              var node_8 = first_child(fragment_7);
              CopyButton_default(node_8, {
                get text() {
                  return code();
                },
                get copy() {
                  return copy();
                },
                get disabled() {
                  return disabled();
                },
                get feedback() {
                  return feedback();
                },
                get feedbackTimeout() {
                  return feedbackTimeout();
                },
                get iconDescription() {
                  return copyButtonDescription();
                },
                $$events: {
                  click($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  },
                  copy($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  },
                  animationend($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  }
                }
              });
              append($$anchor4, fragment_7);
            };
            if_block(node_7, ($$render) => {
              if (!hideCopyButton()) $$render(consequent_3);
            });
          }
          var node_9 = sibling(node_7, 2);
          {
            var consequent_4 = ($$anchor4) => {
              var fragment_8 = comment();
              var node_10 = first_child(fragment_8);
              Button_default(node_10, {
                kind: "ghost",
                size: "small",
                class: "bx--snippet-btn--expand",
                get disabled() {
                  return disabled();
                },
                $$events: {
                  click: () => {
                    expanded(!expanded());
                  }
                },
                children: wrap_snippet(CodeSnippet, ($$anchor5, $$slotProps) => {
                  var fragment_9 = root_122();
                  var span_2 = first_child(fragment_9);
                  toggle_class(span_2, "bx--snippet-btn--text", true);
                  var text_4 = child(span_2, true);
                  reset(span_2);
                  var node_11 = sibling(span_2, 2);
                  ChevronDown_default(node_11, {
                    class: "bx--icon-chevron--down bx--snippet__icon",
                    get "aria-label"() {
                      return get(expandText);
                    }
                  });
                  template_effect(() => set_text(text_4, get(expandText)));
                  append($$anchor5, fragment_9);
                }),
                $$slots: { default: true }
              });
              append($$anchor4, fragment_8);
            };
            if_block(node_9, ($$render) => {
              if (showMoreLess()) $$render(consequent_4);
            });
          }
          reset(div);
          template_effect(() => {
            attributes_2 = set_attributes(div, attributes_2, { ...$$restProps });
            toggle_class(div, "bx--snippet", true);
            toggle_class(div, "bx--snippet--expand", expanded());
            toggle_class(div, "bx--snippet--light", light());
            toggle_class(div, "bx--snippet--no-copy", hideCopyButton());
            toggle_class(div, "bx--snippet--wraptext", wrapText());
            toggle_class(div, "bx--snippet--single", strict_equals(type(), "single"));
            toggle_class(div, "bx--snippet--inline", strict_equals(type(), "inline"));
            toggle_class(div, "bx--snippet--multi", strict_equals(type(), "multi"));
            toggle_class(div, "bx--snippet--disabled", strict_equals(type(), "inline", false) && disabled());
            set_attribute(div_1, "role", strict_equals(type(), "single") ? "textbox" : void 0);
            set_attribute(div_1, "tabindex", strict_equals(type(), "single") && !disabled() ? "0" : void 0);
            set_attribute(div_1, "aria-label", $$restProps["aria-label"] || copyLabel() || "code-snippet");
            toggle_class(div_1, "bx--snippet-container", true);
            set_style(div_1, "width", "100%");
            set_style(div_1, "min-height", `${get(minHeight) ?? ""}px`);
            set_style(div_1, "max-height", get(maxHeight));
          });
          event2("mouseover", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event2("mouseenter", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event2("mouseleave", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          append($$anchor3, div);
        };
        if_block(
          node_2,
          ($$render) => {
            if (strict_equals(type(), "inline")) $$render(consequent_2);
            else $$render(alternate_1, false);
          },
          true
        );
      }
      append($$anchor2, fragment_2);
    };
    if_block(node, ($$render) => {
      if (skeleton()) $$render(consequent);
      else $$render(alternate_2, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CodeSnippet = hmr(CodeSnippet, () => CodeSnippet[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodeSnippet[HMR].source;
    set(CodeSnippet[HMR].source, module.default[HMR].original);
  });
}
var CodeSnippet_default = CodeSnippet;
mark_module_end(CodeSnippet);

// node_modules/carbon-components-svelte/src/RadioButton/RadioButton.svelte
mark_module_start();
RadioButton[FILENAME] = "node_modules/carbon-components-svelte/src/RadioButton/RadioButton.svelte";
var root_123 = add_locations(template(`<span><!></span>`), RadioButton[FILENAME], [[84, 6]]);
var root36 = add_locations(template(`<div><input type="radio"> <label><span></span> <!></label></div>`), RadioButton[FILENAME], [
  [
    59,
    0,
    [[64, 2], [81, 2, [[82, 4]]]]
  ]
]);
function RadioButton($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "value",
    "checked",
    "disabled",
    "required",
    "labelPosition",
    "labelText",
    "hideLabel",
    "id",
    "name",
    "ref"
  ]);
  push($$props, false, RadioButton);
  const [$$stores, $$cleanup] = setup_stores();
  const $selectedValue = () => (validate_store(selectedValue, "selectedValue"), store_get(selectedValue, "$selectedValue", $$stores));
  const $groupName = () => (validate_store(groupName, "groupName"), store_get(groupName, "$groupName", $$stores));
  const $groupRequired = () => (validate_store(groupRequired, "groupRequired"), store_get(groupRequired, "$groupRequired", $$stores));
  let value = prop($$props, "value", 8, "");
  let checked = prop($$props, "checked", 12, false);
  let disabled = prop($$props, "disabled", 8, false);
  let required = prop($$props, "required", 8, false);
  let labelPosition = prop($$props, "labelPosition", 8, "right");
  let labelText = prop($$props, "labelText", 8, "");
  let hideLabel = prop($$props, "hideLabel", 8, false);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let name = prop($$props, "name", 8, void 0);
  let ref = prop($$props, "ref", 12, null);
  const {
    add,
    update: update2,
    selectedValue,
    groupName,
    groupRequired
  } = getContext("RadioButtonGroup") ?? {
    groupName: readable(void 0),
    groupRequired: readable(void 0),
    selectedValue: readable(checked() ? value() : void 0)
  };
  if (add) {
    add({
      id: id(),
      checked: checked(),
      disabled: disabled(),
      value: value()
    });
  }
  legacy_pre_effect(
    () => ($selectedValue(), deep_read_state(value())),
    () => {
      checked(strict_equals($selectedValue(), value()));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root36();
  let attributes;
  var input = child(div);
  remove_input_defaults(input);
  bind_this(input, ($$value) => ref($$value), () => ref());
  var label = sibling(input, 2);
  var span = child(label);
  toggle_class(span, "bx--radio-button__appearance", true);
  var node = sibling(span, 2);
  {
    var consequent = ($$anchor2) => {
      var span_1 = root_123();
      var node_1 = child(span_1);
      slot(node_1, $$props, "labelText", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, labelText()));
        append($$anchor3, text2);
      });
      reset(span_1);
      template_effect(() => toggle_class(span_1, "bx--visually-hidden", hideLabel()));
      append($$anchor2, span_1);
    };
    if_block(node, ($$render) => {
      if (labelText() || $$slots.labelText) $$render(consequent);
    });
  }
  reset(label);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--radio-button-wrapper", true);
    toggle_class(div, "bx--radio-button-wrapper--label-left", strict_equals(labelPosition(), "left"));
    set_attribute(input, "id", id());
    set_attribute(input, "name", $groupName() ?? name());
    set_checked(input, checked());
    input.disabled = disabled();
    input.required = $groupRequired() ?? required();
    set_value(input, value());
    toggle_class(input, "bx--radio-button", true);
    set_attribute(label, "for", id());
    toggle_class(label, "bx--radio-button__label", true);
  });
  event2("change", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("change", input, () => {
    if (update2) {
      update2(value());
    }
  });
  append($$anchor, div);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  RadioButton = hmr(RadioButton, () => RadioButton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RadioButton[HMR].source;
    set(RadioButton[HMR].source, module.default[HMR].original);
  });
}
var RadioButton_default = RadioButton;
mark_module_end(RadioButton);

// node_modules/carbon-components-svelte/src/DataTable/Table.svelte
mark_module_start();
Table[FILENAME] = "node_modules/carbon-components-svelte/src/DataTable/Table.svelte";
var root_124 = add_locations(template(`<section><table><!></table></section>`), Table[FILENAME], [[28, 2, [[29, 4]]]]);
var root_212 = add_locations(template(`<table><!></table>`), Table[FILENAME], [[45, 2]]);
function Table($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "size",
    "zebra",
    "useStaticWidth",
    "sortable",
    "stickyHeader",
    "tableStyle"
  ]);
  push($$props, false, Table);
  let size = prop($$props, "size", 8, void 0);
  let zebra = prop($$props, "zebra", 8, false);
  let useStaticWidth = prop($$props, "useStaticWidth", 8, false);
  let sortable = prop($$props, "sortable", 8, false);
  let stickyHeader = prop($$props, "stickyHeader", 8, false);
  let tableStyle = prop($$props, "tableStyle", 8, void 0);
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var section = root_124();
      let attributes;
      var table = child(section);
      var node_1 = child(table);
      slot(node_1, $$props, "default", {}, null);
      reset(table);
      reset(section);
      template_effect(() => {
        attributes = set_attributes(section, attributes, { ...$$restProps });
        toggle_class(section, "bx--data-table_inner-container", true);
        set_attribute(table, "style", tableStyle());
        toggle_class(table, "bx--data-table", true);
        toggle_class(table, "bx--data-table--compact", strict_equals(size(), "compact"));
        toggle_class(table, "bx--data-table--short", strict_equals(size(), "short"));
        toggle_class(table, "bx--data-table--tall", strict_equals(size(), "tall"));
        toggle_class(table, "bx--data-table--md", strict_equals(size(), "medium"));
        toggle_class(table, "bx--data-table--sort", sortable());
        toggle_class(table, "bx--data-table--zebra", zebra());
        toggle_class(table, "bx--data-table--static", useStaticWidth());
        toggle_class(table, "bx--data-table--sticky-header", stickyHeader());
      });
      append($$anchor2, section);
    };
    var alternate = ($$anchor2) => {
      var table_1 = root_212();
      let attributes_1;
      var node_2 = child(table_1);
      slot(node_2, $$props, "default", {}, null);
      reset(table_1);
      template_effect(() => {
        attributes_1 = set_attributes(table_1, attributes_1, { ...$$restProps, style: tableStyle() });
        toggle_class(table_1, "bx--data-table", true);
        toggle_class(table_1, "bx--data-table--compact", strict_equals(size(), "compact"));
        toggle_class(table_1, "bx--data-table--short", strict_equals(size(), "short"));
        toggle_class(table_1, "bx--data-table--tall", strict_equals(size(), "tall"));
        toggle_class(table_1, "bx--data-table--md", strict_equals(size(), "medium"));
        toggle_class(table_1, "bx--data-table--sort", sortable());
        toggle_class(table_1, "bx--data-table--zebra", zebra());
        toggle_class(table_1, "bx--data-table--static", useStaticWidth());
        toggle_class(table_1, "bx--data-table--sticky-header", stickyHeader());
      });
      append($$anchor2, table_1);
    };
    if_block(node, ($$render) => {
      if (stickyHeader()) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Table = hmr(Table, () => Table[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Table[HMR].source;
    set(Table[HMR].source, module.default[HMR].original);
  });
}
var Table_default = Table;
mark_module_end(Table);

// node_modules/carbon-components-svelte/src/DataTable/TableBody.svelte
mark_module_start();
TableBody[FILENAME] = "node_modules/carbon-components-svelte/src/DataTable/TableBody.svelte";
var root37 = add_locations(template(`<tbody><!></tbody>`), TableBody[FILENAME], [[1, 0]]);
function TableBody($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, TableBody);
  var tbody = root37();
  let attributes;
  var node = child(tbody);
  slot(node, $$props, "default", {}, null);
  reset(tbody);
  template_effect(() => attributes = set_attributes(tbody, attributes, { "aria-live": "polite", ...$$restProps }));
  append($$anchor, tbody);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TableBody = hmr(TableBody, () => TableBody[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TableBody[HMR].source;
    set(TableBody[HMR].source, module.default[HMR].original);
  });
}
var TableBody_default = TableBody;
mark_module_end(TableBody);

// node_modules/carbon-components-svelte/src/DataTable/TableCell.svelte
mark_module_start();
TableCell[FILENAME] = "node_modules/carbon-components-svelte/src/DataTable/TableCell.svelte";
var root38 = add_locations(template(`<td><!></td>`), TableCell[FILENAME], [[2, 0]]);
function TableCell($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, TableCell);
  var td = root38();
  let attributes;
  var node = child(td);
  slot(node, $$props, "default", {}, null);
  reset(td);
  template_effect(() => attributes = set_attributes(td, attributes, { ...$$restProps }));
  event2("click", td, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", td, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", td, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", td, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, td);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TableCell = hmr(TableCell, () => TableCell[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TableCell[HMR].source;
    set(TableCell[HMR].source, module.default[HMR].original);
  });
}
var TableCell_default = TableCell;
mark_module_end(TableCell);

// node_modules/carbon-components-svelte/src/DataTable/TableContainer.svelte
mark_module_start();
TableContainer[FILENAME] = "node_modules/carbon-components-svelte/src/DataTable/TableContainer.svelte";
var root_125 = add_locations(template(`<div><h4> </h4> <p> </p></div>`), TableContainer[FILENAME], [[22, 4, [[23, 6], [24, 6]]]]);
var root39 = add_locations(template(`<div><!> <!></div>`), TableContainer[FILENAME], [[15, 0]]);
function TableContainer($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "title",
    "description",
    "stickyHeader",
    "useStaticWidth"
  ]);
  push($$props, false, TableContainer);
  let title = prop($$props, "title", 8, "");
  let description = prop($$props, "description", 8, "");
  let stickyHeader = prop($$props, "stickyHeader", 8, false);
  let useStaticWidth = prop($$props, "useStaticWidth", 8, false);
  var div = root39();
  let attributes;
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var div_1 = root_125();
      toggle_class(div_1, "bx--data-table-header", true);
      var h4 = child(div_1);
      toggle_class(h4, "bx--data-table-header__title", true);
      var text2 = child(h4, true);
      reset(h4);
      var p = sibling(h4, 2);
      toggle_class(p, "bx--data-table-header__description", true);
      var text_1 = child(p, true);
      reset(p);
      reset(div_1);
      template_effect(() => {
        set_text(text2, title());
        set_text(text_1, description());
      });
      append($$anchor2, div_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  var node_1 = sibling(node, 2);
  slot(node_1, $$props, "default", {}, null);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--data-table-container", true);
    toggle_class(div, "bx--data-table-container--static", useStaticWidth());
    toggle_class(div, "bx--data-table--max-width", stickyHeader());
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TableContainer = hmr(TableContainer, () => TableContainer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TableContainer[HMR].source;
    set(TableContainer[HMR].source, module.default[HMR].original);
  });
}
var TableContainer_default = TableContainer;
mark_module_end(TableContainer);

// node_modules/carbon-components-svelte/src/DataTable/TableHead.svelte
mark_module_start();
TableHead[FILENAME] = "node_modules/carbon-components-svelte/src/DataTable/TableHead.svelte";
var root40 = add_locations(template(`<thead><!></thead>`), TableHead[FILENAME], [[3, 0]]);
function TableHead($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, TableHead);
  var thead = root40();
  let attributes;
  var node = child(thead);
  slot(node, $$props, "default", {}, null);
  reset(thead);
  template_effect(() => attributes = set_attributes(thead, attributes, { ...$$restProps }));
  event2("click", thead, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", thead, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", thead, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", thead, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, thead);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TableHead = hmr(TableHead, () => TableHead[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TableHead[HMR].source;
    set(TableHead[HMR].source, module.default[HMR].original);
  });
}
var TableHead_default = TableHead;
mark_module_end(TableHead);

// node_modules/carbon-components-svelte/src/icons/ArrowUp.svelte
mark_module_start();
ArrowUp[FILENAME] = "node_modules/carbon-components-svelte/src/icons/ArrowUp.svelte";
var root_126 = add_locations(ns_template(`<title> </title>`), ArrowUp[FILENAME], [[24, 13]]);
var root41 = add_locations(ns_template(`<svg><!><path d="M16 4L6 14 7.41 15.41 15 7.83 15 28 17 28 17 7.83 24.59 15.41 26 14 16 4z"></path></svg>`), ArrowUp[FILENAME], [[14, 0, [[25, 2]]]]);
function ArrowUp($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, ArrowUp);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root41();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_126();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next();
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArrowUp = hmr(ArrowUp, () => ArrowUp[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowUp[HMR].source;
    set(ArrowUp[HMR].source, module.default[HMR].original);
  });
}
var ArrowUp_default = ArrowUp;
mark_module_end(ArrowUp);

// node_modules/carbon-components-svelte/src/icons/ArrowsVertical.svelte
mark_module_start();
ArrowsVertical[FILENAME] = "node_modules/carbon-components-svelte/src/icons/ArrowsVertical.svelte";
var root_127 = add_locations(ns_template(`<title> </title>`), ArrowsVertical[FILENAME], [[24, 13]]);
var root42 = add_locations(ns_template(`<svg><!><path d="M27.6 20.6L24 24.2 24 4 22 4 22 24.2 18.4 20.6 17 22 23 28 29 22zM9 4L3 10 4.4 11.4 8 7.8 8 28 10 28 10 7.8 13.6 11.4 15 10z"></path></svg>`), ArrowsVertical[FILENAME], [[14, 0, [[25, 2]]]]);
function ArrowsVertical($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, ArrowsVertical);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root42();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_127();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next();
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArrowsVertical = hmr(ArrowsVertical, () => ArrowsVertical[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowsVertical[HMR].source;
    set(ArrowsVertical[HMR].source, module.default[HMR].original);
  });
}
var ArrowsVertical_default = ArrowsVertical;
mark_module_end(ArrowsVertical);

// node_modules/carbon-components-svelte/src/DataTable/TableHeader.svelte
mark_module_start();
TableHeader[FILENAME] = "node_modules/carbon-components-svelte/src/DataTable/TableHeader.svelte";
var root_128 = add_locations(template(`<th><button type="button"><div><!></div> <!> <!></button></th>`), TableHeader[FILENAME], [
  [35, 2, [[44, 4, [[52, 6]]]]]
]);
var root_213 = add_locations(template(`<th><div><!></div></th>`), TableHeader[FILENAME], [[68, 2, [[77, 4]]]]);
function TableHeader($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "sortable",
    "sortDirection",
    "active",
    "scope",
    "translateWithId",
    "id"
  ]);
  push($$props, false, TableHeader);
  const ariaLabel = mutable_state();
  let sortable = prop($$props, "sortable", 8, false);
  let sortDirection = prop($$props, "sortDirection", 8, "none");
  let active = prop($$props, "active", 8, false);
  let scope = prop($$props, "scope", 8, "col");
  let translateWithId = prop($$props, "translateWithId", 8, () => "");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  legacy_pre_effect(() => deep_read_state(translateWithId()), () => {
    set(ariaLabel, translateWithId()());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var th = root_128();
      let attributes;
      var button = child(th);
      toggle_class(button, "bx--table-sort", true);
      var div = child(button);
      toggle_class(div, "bx--table-header-label", true);
      var node_1 = child(div);
      slot(node_1, $$props, "default", {}, null);
      reset(div);
      var node_2 = sibling(div, 2);
      ArrowUp_default(node_2, {
        size: 20,
        get "aria-label"() {
          return get(ariaLabel);
        },
        class: "bx--table-sort__icon"
      });
      var node_3 = sibling(node_2, 2);
      ArrowsVertical_default(node_3, {
        size: 20,
        get "aria-label"() {
          return get(ariaLabel);
        },
        class: "bx--table-sort__icon-unsorted"
      });
      reset(button);
      reset(th);
      template_effect(() => {
        attributes = set_attributes(th, attributes, {
          "aria-sort": active() ? sortDirection() : "none",
          scope: scope(),
          "data-header": id(),
          ...$$restProps
        });
        toggle_class(button, "bx--table-sort--active", active());
        toggle_class(button, "bx--table-sort--ascending", active() && strict_equals(sortDirection(), "descending"));
      });
      event2("click", button, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseover", th, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseenter", th, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseleave", th, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, th);
    };
    var alternate = ($$anchor2) => {
      var th_1 = root_213();
      let attributes_1;
      var div_1 = child(th_1);
      toggle_class(div_1, "bx--table-header-label", true);
      var node_4 = child(div_1);
      slot(node_4, $$props, "default", {}, null);
      reset(div_1);
      reset(th_1);
      template_effect(() => attributes_1 = set_attributes(th_1, attributes_1, {
        scope: scope(),
        "data-header": id(),
        ...$$restProps
      }));
      event2("click", th_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseover", th_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseenter", th_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseleave", th_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, th_1);
    };
    if_block(node, ($$render) => {
      if (sortable()) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TableHeader = hmr(TableHeader, () => TableHeader[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TableHeader[HMR].source;
    set(TableHeader[HMR].source, module.default[HMR].original);
  });
}
var TableHeader_default = TableHeader;
mark_module_end(TableHeader);

// node_modules/carbon-components-svelte/src/DataTable/TableRow.svelte
mark_module_start();
TableRow[FILENAME] = "node_modules/carbon-components-svelte/src/DataTable/TableRow.svelte";
var root43 = add_locations(template(`<tr><!></tr>`), TableRow[FILENAME], [[2, 0]]);
function TableRow($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, TableRow);
  var tr = root43();
  let attributes;
  var node = child(tr);
  slot(node, $$props, "default", {}, null);
  reset(tr);
  template_effect(() => attributes = set_attributes(tr, attributes, { ...$$restProps }));
  event2("click", tr, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", tr, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", tr, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", tr, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, tr);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TableRow = hmr(TableRow, () => TableRow[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TableRow[HMR].source;
    set(TableRow[HMR].source, module.default[HMR].original);
  });
}
var TableRow_default = TableRow;
mark_module_end(TableRow);

// node_modules/carbon-components-svelte/src/DataTable/DataTable.svelte
mark_module_start();
DataTable[FILENAME] = "node_modules/carbon-components-svelte/src/DataTable/DataTable.svelte";
var root_34 = add_locations(template(`<h4><!></h4>`), DataTable[FILENAME], [[265, 8]]);
var root_53 = add_locations(template(`<p><!></p>`), DataTable[FILENAME], [[270, 8]]);
var root_214 = add_locations(template(`<div><!> <!></div>`), DataTable[FILENAME], [[263, 4]]);
var root_1110 = add_locations(template(`<button type="button"><!></button>`), DataTable[FILENAME], [[294, 14]]);
var root_102 = add_locations(template(`<th scope="col"><!></th>`), DataTable[FILENAME], [[288, 10]]);
var root_129 = add_locations(template(`<th scope="col"></th>`), DataTable[FILENAME], [[310, 10]]);
var root_132 = add_locations(template(`<th scope="col"><!></th>`), DataTable[FILENAME], [[313, 10]]);
var root_152 = add_locations(template(`<th scope="col"></th>`), DataTable[FILENAME], [[343, 12]]);
var root_9 = add_locations(template(`<!> <!> <!> <!>`, 1), DataTable[FILENAME], []);
var root_242 = add_locations(template(`<button type="button"><!></button>`), DataTable[FILENAME], [[414, 16]]);
var root_252 = add_locations(template(`<td><!></td>`), DataTable[FILENAME], [[439, 12]]);
var root_30 = add_locations(template(`<td><!></td>`), DataTable[FILENAME], [[475, 14]]);
var root_21 = add_locations(template(`<!> <!> <!>`, 1), DataTable[FILENAME], []);
var root_37 = add_locations(template(`<div><!></div>`), DataTable[FILENAME], [[524, 16]]);
var root_35 = add_locations(template(`<tr data-child-row=""><!></tr>`), DataTable[FILENAME], [[508, 10]]);
var root_20 = add_locations(template(`<!> <!>`, 1), DataTable[FILENAME], []);
var root_72 = add_locations(template(`<!> <!>`, 1), DataTable[FILENAME], []);
var root_130 = add_locations(template(`<!> <!> <!>`, 1), DataTable[FILENAME], []);
function DataTable($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "headers",
    "rows",
    "size",
    "title",
    "description",
    "zebra",
    "sortable",
    "sortKey",
    "sortDirection",
    "expandable",
    "batchExpansion",
    "expandedRowIds",
    "nonExpandableRowIds",
    "radio",
    "selectable",
    "batchSelection",
    "selectedRowIds",
    "nonSelectableRowIds",
    "stickyHeader",
    "useStaticWidth",
    "pageSize",
    "page"
  ]);
  push($$props, false, DataTable);
  const [$$stores, $$cleanup] = setup_stores();
  const $tableRows = () => (validate_store(tableRows, "tableRows"), store_get(tableRows, "$tableRows", $$stores));
  const thKeys = mutable_state();
  const expandedRows = mutable_state();
  const rowIds = mutable_state();
  const expandableRowIds = mutable_state();
  const selectableRowIds = mutable_state();
  const selectAll = mutable_state();
  const indeterminate = mutable_state();
  const headerKeys = mutable_state();
  const tableCellsByRowId = mutable_state();
  const sortedRows = mutable_state();
  const ascending = mutable_state();
  const sorting = mutable_state();
  const sortingHeader = mutable_state();
  const displayedRows = mutable_state();
  const displayedSortedRows = mutable_state();
  const hasCustomHeaderWidth = mutable_state();
  let headers = prop($$props, "headers", 24, () => []);
  let rows = prop($$props, "rows", 24, () => []);
  let size = prop($$props, "size", 8, void 0);
  let title = prop($$props, "title", 8, "");
  let description = prop($$props, "description", 8, "");
  let zebra = prop($$props, "zebra", 8, false);
  let sortable = prop($$props, "sortable", 8, false);
  let sortKey = prop($$props, "sortKey", 12, null);
  let sortDirection = prop($$props, "sortDirection", 12, "none");
  let expandable = prop($$props, "expandable", 12, false);
  let batchExpansion = prop($$props, "batchExpansion", 8, false);
  let expandedRowIds = prop($$props, "expandedRowIds", 28, () => []);
  let nonExpandableRowIds = prop($$props, "nonExpandableRowIds", 24, () => []);
  let radio = prop($$props, "radio", 8, false);
  let selectable = prop($$props, "selectable", 12, false);
  let batchSelection = prop($$props, "batchSelection", 8, false);
  let selectedRowIds = prop($$props, "selectedRowIds", 28, () => []);
  let nonSelectableRowIds = prop($$props, "nonSelectableRowIds", 24, () => []);
  let stickyHeader = prop($$props, "stickyHeader", 8, false);
  let useStaticWidth = prop($$props, "useStaticWidth", 8, false);
  let pageSize = prop($$props, "pageSize", 8, 0);
  let page = prop($$props, "page", 8, 0);
  const sortDirectionMap = {
    none: "ascending",
    ascending: "descending",
    descending: "none"
  };
  const dispatch = createEventDispatcher();
  const batchSelectedIds = writable(false);
  const tableRows = writable(rows());
  const resolvePath = (object, path) => {
    if (path in object) return object[path];
    return path.split(/[\.\[\]\'\"]/).filter((p) => p).reduce((o, p) => o && strict_equals(typeof o, "object") ? o[p] : o, object);
  };
  setContext("DataTable", {
    batchSelectedIds,
    tableRows,
    resetSelectedRowIds: () => {
      set(selectAll, false);
      selectedRowIds([]);
      if (get(refSelectAll)) mutate(refSelectAll, get(refSelectAll).checked = false);
    }
  });
  let expanded = mutable_state(false);
  let parentRowId = mutable_state(null);
  let refSelectAll = mutable_state(null);
  const getDisplayedRows = (rows2, page2, pageSize2) => page2 && pageSize2 ? rows2.slice((page2 - 1) * pageSize2, page2 * pageSize2) : rows2;
  const formatHeaderWidth = (header) => {
    const styles = [
      header.width && `width: ${header.width}`,
      header.minWidth && `min-width: ${header.minWidth}`
    ].filter(Boolean);
    if (strict_equals(styles.length, 0)) return void 0;
    return styles.join(";");
  };
  legacy_pre_effect(() => deep_read_state(headers()), () => {
    set(thKeys, headers().reduce((a, c) => ({ ...a, [c.key]: c.key }), {}));
  });
  legacy_pre_effect(() => deep_read_state(expandedRowIds()), () => {
    set(expandedRows, expandedRowIds().reduce((a, id) => ({ ...a, [id]: true }), {}));
  });
  legacy_pre_effect(() => deep_read_state(selectedRowIds()), () => {
    batchSelectedIds.set(selectedRowIds());
  });
  legacy_pre_effect(() => deep_read_state(rows()), () => {
    store_set(tableRows, rows());
  });
  legacy_pre_effect(() => $tableRows(), () => {
    set(rowIds, $tableRows().map((row) => row.id));
  });
  legacy_pre_effect(
    () => (get(rowIds), deep_read_state(nonExpandableRowIds())),
    () => {
      set(expandableRowIds, get(rowIds).filter((id) => !nonExpandableRowIds().includes(id)));
    }
  );
  legacy_pre_effect(
    () => (get(rowIds), deep_read_state(nonSelectableRowIds())),
    () => {
      set(selectableRowIds, get(rowIds).filter((id) => !nonSelectableRowIds().includes(id)));
    }
  );
  legacy_pre_effect(
    () => (get(selectableRowIds), deep_read_state(selectedRowIds())),
    () => {
      set(selectAll, get(selectableRowIds).length > 0 && strict_equals(selectedRowIds().length, get(selectableRowIds).length));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(selectedRowIds()), get(selectableRowIds)),
    () => {
      set(indeterminate, selectedRowIds().length > 0 && selectedRowIds().length < get(selectableRowIds).length);
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(batchExpansion()), deep_read_state(expandedRowIds()), get(expandableRowIds)),
    () => {
      if (batchExpansion()) {
        expandable(true);
        set(expanded, strict_equals(expandedRowIds().length, get(expandableRowIds).length));
      }
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(radio()), deep_read_state(batchSelection())),
    () => {
      if (radio() || batchSelection()) selectable(true);
    }
  );
  legacy_pre_effect(() => deep_read_state(headers()), () => {
    set(headerKeys, headers().map(({ key }) => key));
  });
  legacy_pre_effect(
    () => (deep_read_state(rows()), get(headerKeys), deep_read_state(headers())),
    () => {
      set(tableCellsByRowId, rows().reduce(
        (rows2, row) => {
          rows2[row.id] = get(headerKeys).map((key, index2) => ({
            key,
            value: resolvePath(row, key),
            display: headers()[index2].display
          }));
          return rows2;
        },
        {}
      ));
    }
  );
  legacy_pre_effect(() => $tableRows(), () => {
    set(sortedRows, [...$tableRows()]);
  });
  legacy_pre_effect(() => deep_read_state(sortDirection()), () => {
    set(ascending, strict_equals(sortDirection(), "ascending"));
  });
  legacy_pre_effect(
    () => (deep_read_state(sortable()), deep_read_state(sortKey())),
    () => {
      set(sorting, sortable() && equals(sortKey(), null, false));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(headers()), deep_read_state(sortKey())),
    () => {
      set(sortingHeader, headers().find((header) => strict_equals(header.key, sortKey())));
    }
  );
  legacy_pre_effect(
    () => (get(sorting), deep_read_state(sortDirection()), $tableRows(), get(ascending), deep_read_state(sortKey()), get(sortingHeader)),
    () => {
      if (get(sorting)) {
        if (strict_equals(sortDirection(), "none")) {
          set(sortedRows, $tableRows());
        } else {
          set(sortedRows, [...$tableRows()].sort((a, b) => {
            var _a;
            const itemA = get(ascending) ? resolvePath(a, sortKey()) : resolvePath(b, sortKey());
            const itemB = get(ascending) ? resolvePath(b, sortKey()) : resolvePath(a, sortKey());
            if ((_a = get(sortingHeader)) == null ? void 0 : _a.sort) return get(sortingHeader).sort(itemA, itemB);
            if (strict_equals(typeof itemA, "number") && strict_equals(typeof itemB, "number")) return itemA - itemB;
            if ([itemA, itemB].every((item) => !item && strict_equals(item, 0, false))) return 0;
            if (!itemA && strict_equals(itemA, 0, false)) return get(ascending) ? 1 : -1;
            if (!itemB && strict_equals(itemB, 0, false)) return get(ascending) ? -1 : 1;
            return itemA.toString().localeCompare(itemB.toString(), "en", { numeric: true });
          }));
        }
      }
    }
  );
  legacy_pre_effect(
    () => ($tableRows(), deep_read_state(page()), deep_read_state(pageSize())),
    () => {
      set(displayedRows, getDisplayedRows($tableRows(), page(), pageSize()));
    }
  );
  legacy_pre_effect(
    () => (get(sortedRows), deep_read_state(page()), deep_read_state(pageSize())),
    () => {
      set(displayedSortedRows, getDisplayedRows(get(sortedRows), page(), pageSize()));
    }
  );
  legacy_pre_effect(() => deep_read_state(headers()), () => {
    set(hasCustomHeaderWidth, headers().some((header) => header.width || header.minWidth));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  TableContainer_default(node, spread_props(
    {
      get useStaticWidth() {
        return useStaticWidth();
      }
    },
    () => $$restProps,
    {
      children: wrap_snippet(DataTable, ($$anchor2, $$slotProps) => {
        var fragment_1 = root_130();
        var node_1 = first_child(fragment_1);
        {
          var consequent_2 = ($$anchor3) => {
            var div = root_214();
            toggle_class(div, "bx--data-table-header", true);
            var node_2 = child(div);
            {
              var consequent = ($$anchor4) => {
                var h4 = root_34();
                toggle_class(h4, "bx--data-table-header__title", true);
                var node_3 = child(h4);
                slot(node_3, $$props, "title", {}, ($$anchor5) => {
                  var text2 = text();
                  template_effect(() => set_text(text2, title()));
                  append($$anchor5, text2);
                });
                reset(h4);
                append($$anchor4, h4);
              };
              if_block(node_2, ($$render) => {
                if (title() || $$slots.title) $$render(consequent);
              });
            }
            var node_4 = sibling(node_2, 2);
            {
              var consequent_1 = ($$anchor4) => {
                var p_1 = root_53();
                toggle_class(p_1, "bx--data-table-header__description", true);
                var node_5 = child(p_1);
                slot(node_5, $$props, "description", {}, ($$anchor5) => {
                  var text_1 = text();
                  template_effect(() => set_text(text_1, description()));
                  append($$anchor5, text_1);
                });
                reset(p_1);
                append($$anchor4, p_1);
              };
              if_block(node_4, ($$render) => {
                if (description() || $$slots.description) $$render(consequent_1);
              });
            }
            reset(div);
            append($$anchor3, div);
          };
          if_block(node_1, ($$render) => {
            if (title() || $$slots.title || description() || $$slots.description) $$render(consequent_2);
          });
        }
        var node_6 = sibling(node_1, 2);
        slot(node_6, $$props, "default", {}, null);
        var node_7 = sibling(node_6, 2);
        const expression = derived_safe_equal(() => get(hasCustomHeaderWidth) && "table-layout: fixed");
        Table_default(node_7, {
          get zebra() {
            return zebra();
          },
          get size() {
            return size();
          },
          get stickyHeader() {
            return stickyHeader();
          },
          get sortable() {
            return sortable();
          },
          get useStaticWidth() {
            return useStaticWidth();
          },
          get tableStyle() {
            return get(expression);
          },
          children: wrap_snippet(DataTable, ($$anchor3, $$slotProps2) => {
            var fragment_4 = root_72();
            var node_8 = first_child(fragment_4);
            TableHead_default(node_8, {
              children: wrap_snippet(DataTable, ($$anchor4, $$slotProps3) => {
                var fragment_5 = comment();
                var node_9 = first_child(fragment_5);
                TableRow_default(node_9, {
                  children: wrap_snippet(DataTable, ($$anchor5, $$slotProps4) => {
                    var fragment_6 = root_9();
                    var node_10 = first_child(fragment_6);
                    {
                      var consequent_4 = ($$anchor6) => {
                        var th = root_102();
                        var node_11 = child(th);
                        {
                          var consequent_3 = ($$anchor7) => {
                            var button = root_1110();
                            toggle_class(button, "bx--table-expand__button", true);
                            var node_12 = child(button);
                            ChevronRight_default(node_12, { class: "bx--table-expand__svg" });
                            reset(button);
                            event2("click", button, () => {
                              set(expanded, !get(expanded));
                              expandedRowIds(get(expanded) ? get(expandableRowIds) : []);
                              dispatch("click:header--expand", { expanded: get(expanded) });
                            });
                            append($$anchor7, button);
                          };
                          if_block(node_11, ($$render) => {
                            if (batchExpansion()) $$render(consequent_3);
                          });
                        }
                        reset(th);
                        template_effect(() => {
                          set_attribute(th, "data-previous-value", get(expanded) ? "collapsed" : void 0);
                          toggle_class(th, "bx--table-expand", true);
                        });
                        append($$anchor6, th);
                      };
                      if_block(node_10, ($$render) => {
                        if (expandable()) $$render(consequent_4);
                      });
                    }
                    var node_13 = sibling(node_10, 2);
                    {
                      var consequent_5 = ($$anchor6) => {
                        var th_1 = root_129();
                        append($$anchor6, th_1);
                      };
                      if_block(node_13, ($$render) => {
                        if (selectable() && !batchSelection()) $$render(consequent_5);
                      });
                    }
                    var node_14 = sibling(node_13, 2);
                    {
                      var consequent_6 = ($$anchor6) => {
                        var th_2 = root_132();
                        toggle_class(th_2, "bx--table-column-checkbox", true);
                        var node_15 = child(th_2);
                        {
                          add_owner_effect(() => get(refSelectAll), InlineCheckbox_default);
                          InlineCheckbox_default(node_15, {
                            "aria-label": "Select all rows",
                            get checked() {
                              return get(selectAll);
                            },
                            get indeterminate() {
                              return get(indeterminate);
                            },
                            get ref() {
                              return get(refSelectAll);
                            },
                            set ref($$value) {
                              set(refSelectAll, $$value);
                            },
                            $$events: {
                              change: (e) => {
                                dispatch("click:header--select", {
                                  indeterminate: get(indeterminate),
                                  selected: !get(indeterminate) && e.target.checked
                                });
                                if (get(indeterminate)) {
                                  e.target.checked = false;
                                  set(selectAll, false);
                                  selectedRowIds([]);
                                  return;
                                }
                                if (e.target.checked) {
                                  selectedRowIds(get(selectableRowIds));
                                } else {
                                  selectedRowIds([]);
                                }
                              }
                            },
                            $$legacy: true
                          });
                        }
                        reset(th_2);
                        append($$anchor6, th_2);
                      };
                      if_block(node_14, ($$render) => {
                        if (batchSelection() && !radio()) $$render(consequent_6);
                      });
                    }
                    var node_16 = sibling(node_14, 2);
                    validate_each_keys(headers, (header) => header.key);
                    each(node_16, 1, headers, (header) => header.key, ($$anchor6, header) => {
                      var fragment_7 = comment();
                      var node_17 = first_child(fragment_7);
                      {
                        var consequent_7 = ($$anchor7) => {
                          var th_3 = root_152();
                          template_effect(($0) => set_attribute(th_3, "style", $0), [() => formatHeaderWidth(get(header))], derived_safe_equal);
                          append($$anchor7, th_3);
                        };
                        var alternate = ($$anchor7) => {
                          var fragment_8 = comment();
                          var node_18 = first_child(fragment_8);
                          const expression_1 = derived_safe_equal(() => formatHeaderWidth(get(header)));
                          const expression_2 = derived_safe_equal(() => sortable() && strict_equals(get(header).sort, false, false));
                          const expression_3 = derived_safe_equal(() => strict_equals(sortKey(), get(header).key) ? sortDirection() : "none");
                          const expression_4 = derived_safe_equal(() => strict_equals(sortKey(), get(header).key));
                          TableHeader_default(node_18, {
                            get id() {
                              return get(header).key;
                            },
                            get style() {
                              return get(expression_1);
                            },
                            get sortable() {
                              return get(expression_2);
                            },
                            get sortDirection() {
                              return get(expression_3);
                            },
                            get active() {
                              return get(expression_4);
                            },
                            $$events: {
                              click: () => {
                                dispatch("click", { header: get(header) });
                                if (strict_equals(get(header).sort, false)) {
                                  dispatch("click:header", { header: get(header) });
                                } else {
                                  let currentSortDirection = strict_equals(sortKey(), get(header).key) ? sortDirection() : "none";
                                  sortDirection(sortDirectionMap[currentSortDirection]);
                                  sortKey(strict_equals(sortDirection(), "none") ? null : get(thKeys)[get(header).key]);
                                  dispatch("click:header", {
                                    header: get(header),
                                    sortDirection: sortDirection()
                                  });
                                }
                              }
                            },
                            children: wrap_snippet(DataTable, ($$anchor8, $$slotProps5) => {
                              var fragment_9 = comment();
                              var node_19 = first_child(fragment_9);
                              slot(
                                node_19,
                                $$props,
                                "cell-header",
                                {
                                  get header() {
                                    return get(header);
                                  }
                                },
                                ($$anchor9) => {
                                  var text_2 = text();
                                  template_effect(() => set_text(text_2, get(header).value));
                                  append($$anchor9, text_2);
                                }
                              );
                              append($$anchor8, fragment_9);
                            }),
                            $$slots: { default: true }
                          });
                          append($$anchor7, fragment_8);
                        };
                        if_block(node_17, ($$render) => {
                          if (get(header).empty) $$render(consequent_7);
                          else $$render(alternate, false);
                        });
                      }
                      append($$anchor6, fragment_7);
                    });
                    append($$anchor5, fragment_6);
                  }),
                  $$slots: { default: true }
                });
                append($$anchor4, fragment_5);
              }),
              $$slots: { default: true }
            });
            var node_20 = sibling(node_8, 2);
            TableBody_default(node_20, {
              children: wrap_snippet(DataTable, ($$anchor4, $$slotProps3) => {
                var fragment_11 = comment();
                var node_21 = first_child(fragment_11);
                validate_each_keys(() => get(sorting) ? get(displayedSortedRows) : get(displayedRows), (row) => row.id);
                each(node_21, 3, () => get(sorting) ? get(displayedSortedRows) : get(displayedRows), (row) => row.id, ($$anchor5, row, i) => {
                  var fragment_12 = root_20();
                  var node_22 = first_child(fragment_12);
                  const expression_5 = derived_safe_equal(() => expandable() ? true : void 0);
                  const expression_6 = derived_safe_equal(() => selectedRowIds().includes(get(row).id) ? "bx--data-table--selected" : "");
                  const expression_7 = derived_safe_equal(() => get(expandedRows)[get(row).id] ? "bx--expandable-row" : "");
                  const expression_8 = derived_safe_equal(() => expandable() ? "bx--parent-row" : "");
                  const expression_9 = derived_safe_equal(() => expandable() && strict_equals(get(parentRowId), get(row).id) ? "bx--expandable-row--hover" : "");
                  TableRow_default(node_22, {
                    get "data-row"() {
                      return get(row).id;
                    },
                    get "data-parent-row"() {
                      return get(expression_5);
                    },
                    get class() {
                      return `${get(expression_6) ?? ""} ${get(expression_7) ?? ""} ${get(expression_8) ?? ""} ${get(expression_9) ?? ""}`;
                    },
                    $$events: {
                      click: ({ target }) => {
                        if ([...target.classList].some((name) => /^bx--(overflow-menu|checkbox|radio-button)/.test(name))) {
                          return;
                        }
                        dispatch("click", { row: get(row) });
                        dispatch("click:row", get(row));
                      },
                      mouseenter: () => {
                        dispatch("mouseenter:row", get(row));
                      },
                      mouseleave: () => {
                        dispatch("mouseleave:row", get(row));
                      }
                    },
                    children: wrap_snippet(DataTable, ($$anchor6, $$slotProps4) => {
                      var fragment_13 = root_21();
                      var node_23 = first_child(fragment_13);
                      {
                        var consequent_9 = ($$anchor7) => {
                          var fragment_14 = comment();
                          var node_24 = first_child(fragment_14);
                          const expression_10 = derived_safe_equal(() => !nonExpandableRowIds().includes(get(row).id) && get(expandedRows)[get(row).id] ? "collapsed" : void 0);
                          TableCell_default(node_24, {
                            class: "bx--table-expand",
                            headers: "expand",
                            get "data-previous-value"() {
                              return get(expression_10);
                            },
                            children: wrap_snippet(DataTable, ($$anchor8, $$slotProps5) => {
                              var fragment_15 = comment();
                              var node_25 = first_child(fragment_15);
                              {
                                var consequent_8 = ($$anchor9) => {
                                  var button_1 = root_242();
                                  var node_26 = child(button_1);
                                  ChevronRight_default(node_26, { class: "bx--table-expand__svg" });
                                  reset(button_1);
                                  template_effect(() => {
                                    set_attribute(button_1, "aria-label", get(expandedRows)[get(row).id] ? "Collapse current row" : "Expand current row");
                                    toggle_class(button_1, "bx--table-expand__button", true);
                                  });
                                  event2("click", button_1, stopPropagation(() => {
                                    const rowExpanded = !!get(expandedRows)[get(row).id];
                                    expandedRowIds(rowExpanded ? expandedRowIds().filter((id) => strict_equals(id, get(row).id, false)) : [...expandedRowIds(), get(row).id]);
                                    dispatch("click:row--expand", { row: get(row), expanded: !rowExpanded });
                                  }));
                                  append($$anchor9, button_1);
                                };
                                if_block(node_25, ($$render) => {
                                  if (!nonExpandableRowIds().includes(get(row).id)) $$render(consequent_8);
                                });
                              }
                              append($$anchor8, fragment_15);
                            }),
                            $$slots: { default: true }
                          });
                          append($$anchor7, fragment_14);
                        };
                        if_block(node_23, ($$render) => {
                          if (expandable()) $$render(consequent_9);
                        });
                      }
                      var node_27 = sibling(node_23, 2);
                      {
                        var consequent_12 = ($$anchor7) => {
                          var td = root_252();
                          toggle_class(td, "bx--table-column-checkbox", true);
                          var node_28 = child(td);
                          {
                            var consequent_11 = ($$anchor8) => {
                              var fragment_16 = comment();
                              var node_29 = first_child(fragment_16);
                              {
                                var consequent_10 = ($$anchor9) => {
                                  var fragment_17 = comment();
                                  var node_30 = first_child(fragment_17);
                                  const expression_11 = derived_safe_equal(() => selectedRowIds().includes(get(row).id));
                                  RadioButton_default(node_30, {
                                    get name() {
                                      return `select-row-${get(row).id ?? ""}`;
                                    },
                                    get checked() {
                                      return get(expression_11);
                                    },
                                    $$events: {
                                      change: () => {
                                        selectedRowIds([get(row).id]);
                                        dispatch("click:row--select", { row: get(row), selected: true });
                                      }
                                    }
                                  });
                                  append($$anchor9, fragment_17);
                                };
                                var alternate_1 = ($$anchor9) => {
                                  var fragment_18 = comment();
                                  var node_31 = first_child(fragment_18);
                                  const expression_12 = derived_safe_equal(() => selectedRowIds().includes(get(row).id));
                                  InlineCheckbox_default(node_31, {
                                    get name() {
                                      return `select-row-${get(row).id ?? ""}`;
                                    },
                                    get checked() {
                                      return get(expression_12);
                                    },
                                    $$events: {
                                      change: () => {
                                        if (selectedRowIds().includes(get(row).id)) {
                                          selectedRowIds(selectedRowIds().filter((id) => strict_equals(id, get(row).id, false)));
                                          dispatch("click:row--select", { row: get(row), selected: false });
                                        } else {
                                          selectedRowIds([...selectedRowIds(), get(row).id]);
                                          dispatch("click:row--select", { row: get(row), selected: true });
                                        }
                                      }
                                    }
                                  });
                                  append($$anchor9, fragment_18);
                                };
                                if_block(node_29, ($$render) => {
                                  if (radio()) $$render(consequent_10);
                                  else $$render(alternate_1, false);
                                });
                              }
                              append($$anchor8, fragment_16);
                            };
                            if_block(node_28, ($$render) => {
                              if (!nonSelectableRowIds().includes(get(row).id)) $$render(consequent_11);
                            });
                          }
                          reset(td);
                          template_effect(() => toggle_class(td, "bx--table-column-radio", radio()));
                          append($$anchor7, td);
                        };
                        if_block(node_27, ($$render) => {
                          if (selectable()) $$render(consequent_12);
                        });
                      }
                      var node_32 = sibling(node_27, 2);
                      validate_each_keys(() => get(tableCellsByRowId)[get(row).id], (cell) => cell.key);
                      each(node_32, 3, () => get(tableCellsByRowId)[get(row).id], (cell) => cell.key, ($$anchor7, cell, j) => {
                        var fragment_19 = comment();
                        var node_33 = first_child(fragment_19);
                        {
                          var consequent_13 = ($$anchor8) => {
                            var td_1 = root_30();
                            var node_34 = child(td_1);
                            slot(
                              node_34,
                              $$props,
                              "cell",
                              {
                                get row() {
                                  return get(row);
                                },
                                get cell() {
                                  return get(cell);
                                },
                                get rowIndex() {
                                  return get(i);
                                },
                                get cellIndex() {
                                  return get(j);
                                }
                              },
                              ($$anchor9) => {
                                var text_3 = text();
                                template_effect(
                                  ($0) => set_text(text_3, $0),
                                  [
                                    () => get(cell).display ? get(cell).display(get(cell).value, get(row)) : get(cell).value
                                  ],
                                  derived_safe_equal
                                );
                                append($$anchor9, text_3);
                              }
                            );
                            reset(td_1);
                            template_effect(() => toggle_class(td_1, "bx--table-column-menu", headers()[get(j)].columnMenu));
                            append($$anchor8, td_1);
                          };
                          var alternate_2 = ($$anchor8) => {
                            var fragment_21 = comment();
                            var node_35 = first_child(fragment_21);
                            TableCell_default(node_35, {
                              $$events: {
                                click: () => {
                                  dispatch("click", { row: get(row), cell: get(cell) });
                                  dispatch("click:cell", get(cell));
                                }
                              },
                              children: wrap_snippet(DataTable, ($$anchor9, $$slotProps5) => {
                                var fragment_22 = comment();
                                var node_36 = first_child(fragment_22);
                                slot(
                                  node_36,
                                  $$props,
                                  "cell",
                                  {
                                    get row() {
                                      return get(row);
                                    },
                                    get cell() {
                                      return get(cell);
                                    },
                                    get rowIndex() {
                                      return get(i);
                                    },
                                    get cellIndex() {
                                      return get(j);
                                    }
                                  },
                                  ($$anchor10) => {
                                    var text_4 = text();
                                    template_effect(
                                      ($0) => set_text(text_4, $0),
                                      [
                                        () => get(cell).display ? get(cell).display(get(cell).value, get(row)) : get(cell).value
                                      ],
                                      derived_safe_equal
                                    );
                                    append($$anchor10, text_4);
                                  }
                                );
                                append($$anchor9, fragment_22);
                              }),
                              $$slots: { default: true }
                            });
                            append($$anchor8, fragment_21);
                          };
                          if_block(node_33, ($$render) => {
                            if (headers()[get(j)].empty) $$render(consequent_13);
                            else $$render(alternate_2, false);
                          });
                        }
                        append($$anchor7, fragment_19);
                      });
                      append($$anchor6, fragment_13);
                    }),
                    $$slots: { default: true }
                  });
                  var node_37 = sibling(node_22, 2);
                  {
                    var consequent_15 = ($$anchor6) => {
                      var tr = root_35();
                      toggle_class(tr, "bx--expandable-row", true);
                      var node_38 = child(tr);
                      {
                        var consequent_14 = ($$anchor7) => {
                          var fragment_24 = comment();
                          var node_39 = first_child(fragment_24);
                          const expression_13 = derived_safe_equal(() => selectable() ? headers().length + 2 : headers().length + 1);
                          TableCell_default(node_39, {
                            get colspan() {
                              return get(expression_13);
                            },
                            children: wrap_snippet(DataTable, ($$anchor8, $$slotProps4) => {
                              var div_1 = root_37();
                              toggle_class(div_1, "bx--child-row-inner-container", true);
                              var node_40 = child(div_1);
                              slot(
                                node_40,
                                $$props,
                                "expanded-row",
                                {
                                  get row() {
                                    return get(row);
                                  }
                                },
                                null
                              );
                              reset(div_1);
                              append($$anchor8, div_1);
                            }),
                            $$slots: { default: true }
                          });
                          append($$anchor7, fragment_24);
                        };
                        if_block(node_38, ($$render) => {
                          if (get(expandedRows)[get(row).id] && !nonExpandableRowIds().includes(get(row).id)) $$render(consequent_14);
                        });
                      }
                      reset(tr);
                      event2("mouseenter", tr, () => {
                        if (nonExpandableRowIds().includes(get(row).id)) return;
                        set(parentRowId, get(row).id);
                      });
                      event2("mouseleave", tr, () => {
                        if (nonExpandableRowIds().includes(get(row).id)) return;
                        set(parentRowId, null);
                      });
                      append($$anchor6, tr);
                    };
                    if_block(node_37, ($$render) => {
                      if (expandable()) $$render(consequent_15);
                    });
                  }
                  append($$anchor5, fragment_12);
                });
                append($$anchor4, fragment_11);
              }),
              $$slots: { default: true }
            });
            append($$anchor3, fragment_4);
          }),
          $$slots: { default: true }
        });
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }
  ));
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  DataTable = hmr(DataTable, () => DataTable[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DataTable[HMR].source;
    set(DataTable[HMR].source, module.default[HMR].original);
  });
}
var DataTable_default = DataTable;
mark_module_end(DataTable);

// node_modules/carbon-components-svelte/src/DataTable/DataTableSkeleton.svelte
mark_module_start();
DataTableSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/DataTable/DataTableSkeleton.svelte";
var root_131 = add_locations(template(`<div><div></div> <div></div></div>`), DataTableSkeleton[FILENAME], [[51, 4, [[52, 6], [53, 6]]]]);
var root_215 = add_locations(template(`<section aria-label="data table toolbar"><div><span></span></div></section>`), DataTableSkeleton[FILENAME], [
  [57, 4, [[58, 6, [[59, 8]]]]]
]);
var root_44 = add_locations(template(`<th></th>`), DataTableSkeleton[FILENAME], [[84, 12]]);
var root_54 = add_locations(template(`<th> </th>`), DataTableSkeleton[FILENAME], [[86, 12]]);
var root_73 = add_locations(template(`<td><span></span></td>`), DataTableSkeleton[FILENAME], [[95, 12, [[95, 16]]]]);
var root_64 = add_locations(template(`<tr></tr>`), DataTableSkeleton[FILENAME], [[93, 8]]);
var root44 = add_locations(template(`<div><!> <!>  <table><thead><tr></tr></thead><tbody></tbody></table></div>`), DataTableSkeleton[FILENAME], [
  [
    45,
    0,
    [
      [
        68,
        2,
        [[80, 4, [[81, 6]]], [91, 4]]
      ]
    ]
  ]
]);
function DataTableSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "columns",
    "rows",
    "size",
    "zebra",
    "showHeader",
    "headers",
    "showToolbar"
  ]);
  push($$props, false, DataTableSkeleton);
  const values = mutable_state();
  const cols = mutable_state();
  let columns = prop($$props, "columns", 8, 5);
  let rows = prop($$props, "rows", 8, 5);
  let size = prop($$props, "size", 8, void 0);
  let zebra = prop($$props, "zebra", 8, false);
  let showHeader = prop($$props, "showHeader", 8, true);
  let headers = prop($$props, "headers", 24, () => []);
  let showToolbar = prop($$props, "showToolbar", 8, true);
  legacy_pre_effect(() => deep_read_state(headers()), () => {
    set(values, headers().map((header) => strict_equals(header.value, void 0, false) ? header.value : header));
  });
  legacy_pre_effect(
    () => (deep_read_state(headers()), deep_read_state(columns())),
    () => {
      set(cols, Array.from(
        {
          length: headers().length > 0 ? headers().length : columns()
        },
        (_, i) => i
      ));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root44();
  let attributes;
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var div_1 = root_131();
      toggle_class(div_1, "bx--data-table-header", true);
      var div_2 = child(div_1);
      toggle_class(div_2, "bx--data-table-header__title", true);
      var div_3 = sibling(div_2, 2);
      toggle_class(div_3, "bx--data-table-header__description", true);
      reset(div_1);
      append($$anchor2, div_1);
    };
    if_block(node, ($$render) => {
      if (showHeader()) $$render(consequent);
    });
  }
  var node_1 = sibling(node, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var section = root_215();
      toggle_class(section, "bx--table-toolbar", true);
      var div_4 = child(section);
      toggle_class(div_4, "bx--toolbar-content", true);
      var span = child(div_4);
      toggle_class(span, "bx--skeleton", true);
      toggle_class(span, "bx--btn", true);
      toggle_class(span, "bx--btn--sm", true);
      reset(div_4);
      reset(section);
      append($$anchor2, section);
    };
    if_block(node_1, ($$render) => {
      if (showToolbar()) $$render(consequent_1);
    });
  }
  var table = sibling(node_1, 2);
  toggle_class(table, "bx--skeleton", true);
  toggle_class(table, "bx--data-table", true);
  var thead = child(table);
  var tr = child(thead);
  validate_each_keys(() => get(cols), (col) => col);
  each(tr, 5, () => get(cols), (col) => col, ($$anchor2, col) => {
    var fragment = comment();
    var node_2 = first_child(fragment);
    {
      var consequent_2 = ($$anchor3) => {
        var th = root_44();
        append($$anchor3, th);
      };
      var alternate = ($$anchor3) => {
        var th_1 = root_54();
        var text2 = child(th_1, true);
        reset(th_1);
        template_effect(() => set_text(text2, get(values)[get(col)] || ""));
        append($$anchor3, th_1);
      };
      if_block(node_2, ($$render) => {
        if (strict_equals(typeof get(values)[get(col)], "object") && strict_equals(get(values)[get(col)].empty, true)) $$render(consequent_2);
        else $$render(alternate, false);
      });
    }
    append($$anchor2, fragment);
  });
  reset(tr);
  reset(thead);
  var tbody = sibling(thead);
  validate_each_keys(() => Array.from({ length: rows() }, (_, i) => i), (row) => row);
  each(tbody, 5, () => Array.from({ length: rows() }, (_, i) => i), (row) => row, ($$anchor2, row) => {
    var tr_1 = root_64();
    validate_each_keys(() => get(cols), (col) => col);
    each(tr_1, 5, () => get(cols), (col) => col, ($$anchor3, col) => {
      var td = root_73();
      append($$anchor3, td);
    });
    reset(tr_1);
    append($$anchor2, tr_1);
  });
  reset(tbody);
  reset(table);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--skeleton", true);
    toggle_class(div, "bx--data-table-container", true);
    toggle_class(table, "bx--data-table--compact", strict_equals(size(), "compact"));
    toggle_class(table, "bx--data-table--short", strict_equals(size(), "short"));
    toggle_class(table, "bx--data-table--tall", strict_equals(size(), "tall"));
    toggle_class(table, "bx--data-table--zebra", zebra());
  });
  event2("click", table, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", table, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", table, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", table, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DataTableSkeleton = hmr(DataTableSkeleton, () => DataTableSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DataTableSkeleton[HMR].source;
    set(DataTableSkeleton[HMR].source, module.default[HMR].original);
  });
}
var DataTableSkeleton_default = DataTableSkeleton;
mark_module_end(DataTableSkeleton);

// node_modules/carbon-components-svelte/src/DataTable/Toolbar.svelte
mark_module_start();
Toolbar[FILENAME] = "node_modules/carbon-components-svelte/src/DataTable/Toolbar.svelte";
var root45 = add_locations(template(`<section><!></section>`), Toolbar[FILENAME], [[24, 0]]);
function Toolbar($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size"]);
  push($$props, false, Toolbar);
  let size = prop($$props, "size", 8, "default");
  let ref = mutable_state(null);
  const overflowVisible = writable(false);
  setContext("Toolbar", {
    overflowVisible,
    setOverflowVisible: (visible) => {
      overflowVisible.set(visible);
      if (get(ref)) mutate(ref, get(ref).style.overflow = visible ? "visible" : "inherit");
    }
  });
  init();
  var section = root45();
  let attributes;
  var node = child(section);
  slot(node, $$props, "default", {}, null);
  reset(section);
  bind_this(section, ($$value) => set(ref, $$value), () => get(ref));
  template_effect(() => {
    attributes = set_attributes(section, attributes, {
      "aria-label": "data table toolbar",
      ...$$restProps
    });
    toggle_class(section, "bx--table-toolbar", true);
    toggle_class(section, "bx--table-toolbar--small", strict_equals(size(), "sm"));
    toggle_class(section, "bx--table-toolbar--normal", strict_equals(size(), "default"));
    set_style(section, "z-index", 1);
  });
  append($$anchor, section);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toolbar = hmr(Toolbar, () => Toolbar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toolbar[HMR].source;
    set(Toolbar[HMR].source, module.default[HMR].original);
  });
}
var Toolbar_default = Toolbar;
mark_module_end(Toolbar);

// node_modules/carbon-components-svelte/src/DataTable/ToolbarContent.svelte
mark_module_start();
ToolbarContent[FILENAME] = "node_modules/carbon-components-svelte/src/DataTable/ToolbarContent.svelte";
var root46 = add_locations(template(`<div><!></div>`), ToolbarContent[FILENAME], [[1, 0]]);
function ToolbarContent($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, ToolbarContent);
  var div = root46();
  toggle_class(div, "bx--toolbar-content", true);
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ToolbarContent = hmr(ToolbarContent, () => ToolbarContent[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ToolbarContent[HMR].source;
    set(ToolbarContent[HMR].source, module.default[HMR].original);
  });
}
var ToolbarContent_default = ToolbarContent;
mark_module_end(ToolbarContent);

// node_modules/carbon-components-svelte/src/icons/IconSearch.svelte
mark_module_start();
IconSearch[FILENAME] = "node_modules/carbon-components-svelte/src/icons/IconSearch.svelte";
var root_133 = add_locations(ns_template(`<title> </title>`), IconSearch[FILENAME], [[24, 13]]);
var root47 = add_locations(ns_template(`<svg><!><path d="M29,27.5859l-7.5521-7.5521a11.0177,11.0177,0,1,0-1.4141,1.4141L27.5859,29ZM4,13a9,9,0,1,1,9,9A9.01,9.01,0,0,1,4,13Z"></path></svg>`), IconSearch[FILENAME], [[14, 0, [[25, 2]]]]);
function IconSearch($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, IconSearch);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root47();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_133();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next();
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  IconSearch = hmr(IconSearch, () => IconSearch[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = IconSearch[HMR].source;
    set(IconSearch[HMR].source, module.default[HMR].original);
  });
}
var IconSearch_default = IconSearch;
mark_module_end(IconSearch);

// node_modules/carbon-components-svelte/src/Search/SearchSkeleton.svelte
mark_module_start();
SearchSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/Search/SearchSkeleton.svelte";
var root48 = add_locations(template(`<div><span></span> <div></div></div>`), SearchSkeleton[FILENAME], [[11, 0, [[22, 2], [23, 2]]]]);
function SearchSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size"]);
  push($$props, false, SearchSkeleton);
  let size = prop($$props, "size", 8, "xl");
  var div = root48();
  let attributes;
  var span = child(div);
  toggle_class(span, "bx--label", true);
  var div_1 = sibling(span, 2);
  toggle_class(div_1, "bx--search-input", true);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--skeleton", true);
    toggle_class(div, "bx--search--sm", strict_equals(size(), "sm"));
    toggle_class(div, "bx--search--lg", strict_equals(size(), "lg"));
    toggle_class(div, "bx--search--xl", strict_equals(size(), "xl"));
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SearchSkeleton = hmr(SearchSkeleton, () => SearchSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SearchSkeleton[HMR].source;
    set(SearchSkeleton[HMR].source, module.default[HMR].original);
  });
}
var SearchSkeleton_default = SearchSkeleton;
mark_module_end(SearchSkeleton);

// node_modules/carbon-components-svelte/src/Search/Search.svelte
mark_module_start();
Search[FILENAME] = "node_modules/carbon-components-svelte/src/Search/Search.svelte";
var root_216 = add_locations(template(`<div role="search"><div><!></div> <label><!></label> <input> <button type="button"><!></button></div>`), Search[FILENAME], [
  [
    93,
    2,
    [
      [108, 4],
      [117, 4],
      [123, 4],
      [157, 4]
    ]
  ]
]);
function Search($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "value",
    "size",
    "searchClass",
    "skeleton",
    "light",
    "disabled",
    "expandable",
    "expanded",
    "placeholder",
    "autocomplete",
    "autofocus",
    "closeButtonLabelText",
    "labelText",
    "icon",
    "id",
    "ref"
  ]);
  push($$props, false, Search);
  let value = prop($$props, "value", 12, "");
  let size = prop($$props, "size", 8, "xl");
  let searchClass = prop($$props, "searchClass", 8, "");
  let skeleton = prop($$props, "skeleton", 8, false);
  let light = prop($$props, "light", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let expandable = prop($$props, "expandable", 8, false);
  let expanded = prop($$props, "expanded", 12, false);
  let placeholder = prop($$props, "placeholder", 8, "Search...");
  let autocomplete = prop($$props, "autocomplete", 8, "off");
  let autofocus = prop($$props, "autofocus", 8, false);
  let closeButtonLabelText = prop($$props, "closeButtonLabelText", 8, "Clear search input");
  let labelText = prop($$props, "labelText", 8, "");
  let icon = prop($$props, "icon", 8, IconSearch_default);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let ref = prop($$props, "ref", 12, null);
  const dispatch = createEventDispatcher();
  let searchRef = mutable_state(null);
  legacy_pre_effect(
    () => (deep_read_state(expanded()), deep_read_state(ref())),
    () => {
      if (expanded() && ref()) ref().focus();
    }
  );
  legacy_pre_effect(() => deep_read_state(expanded()), () => {
    dispatch(expanded() ? "expand" : "collapse");
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      SearchSkeleton_default(node_1, spread_props(
        {
          get size() {
            return size();
          }
        },
        () => $$restProps,
        {
          $$events: {
            click($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            mouseover($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            mouseenter($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            mouseleave($$arg) {
              bubble_event.call(this, $$props, $$arg);
            }
          }
        }
      ));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_216();
      var div_1 = child(div);
      toggle_class(div_1, "bx--search-magnifier", true);
      var node_2 = child(div_1);
      component(node_2, icon, ($$anchor3, $$component) => {
        $$component($$anchor3, { class: "bx--search-magnifier-icon" });
      });
      reset(div_1);
      bind_this(div_1, ($$value) => set(searchRef, $$value), () => get(searchRef));
      var label = sibling(div_1, 2);
      var node_3 = child(label);
      slot(node_3, $$props, "labelText", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, labelText()));
        append($$anchor3, text2);
      });
      reset(label);
      var input = sibling(label, 2);
      remove_input_defaults(input);
      let attributes;
      bind_this(input, ($$value) => ref($$value), () => ref());
      var button = sibling(input, 2);
      var node_4 = child(button);
      const expression = derived_safe_equal(() => strict_equals(size(), "xl") ? 20 : 16);
      component(node_4, () => Close_default, ($$anchor3, $$component) => {
        $$component($$anchor3, {
          get size() {
            return get(expression);
          }
        });
      });
      reset(button);
      reset(div);
      template_effect(() => {
        set_attribute(div, "aria-labelledby", `${id() ?? ""}-search`);
        set_class(div, searchClass());
        toggle_class(div, "bx--search", true);
        toggle_class(div, "bx--search--light", light());
        toggle_class(div, "bx--search--disabled", disabled());
        toggle_class(div, "bx--search--sm", strict_equals(size(), "sm"));
        toggle_class(div, "bx--search--lg", strict_equals(size(), "lg"));
        toggle_class(div, "bx--search--xl", strict_equals(size(), "xl"));
        toggle_class(div, "bx--search--expandable", expandable());
        toggle_class(div, "bx--search--expanded", expanded());
        set_attribute(label, "id", `${id() ?? ""}-search`);
        set_attribute(label, "for", id());
        toggle_class(label, "bx--label", true);
        attributes = set_attributes(input, attributes, {
          type: "text",
          role: "searchbox",
          autofocus: strict_equals(autofocus(), true) ? true : void 0,
          autocomplete: autocomplete(),
          disabled: disabled(),
          id: id(),
          placeholder: placeholder(),
          ...$$restProps
        });
        toggle_class(input, "bx--search-input", true);
        set_attribute(button, "aria-label", closeButtonLabelText());
        button.disabled = disabled();
        toggle_class(button, "bx--search-close", true);
        toggle_class(button, "bx--search-close--hidden", strict_equals(value(), "") || equals(value(), null));
      });
      event2("click", div_1, () => {
        if (expandable()) expanded(true);
      });
      bind_value(input, value);
      event2("change", input, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("input", input, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("focus", input, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("focus", input, () => {
        if (expandable()) expanded(true);
      });
      event2("blur", input, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("blur", input, () => {
        if (expanded() && (strict_equals(value(), "") || equals(value(), null))) {
          expanded(false);
        }
      });
      event2("keydown", input, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("keydown", input, ({ key }) => {
        if (strict_equals(key, "Escape")) {
          value("");
          dispatch("clear");
        }
      });
      event2("keyup", input, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("paste", input, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("click", button, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("click", button, () => {
        value("");
        ref().focus();
        dispatch("clear");
      });
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if (skeleton()) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Search = hmr(Search, () => Search[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Search[HMR].source;
    set(Search[HMR].source, module.default[HMR].original);
  });
}
var Search_default = Search;
mark_module_end(Search);

// node_modules/carbon-components-svelte/src/DataTable/ToolbarSearch.svelte
mark_module_start();
ToolbarSearch[FILENAME] = "node_modules/carbon-components-svelte/src/DataTable/ToolbarSearch.svelte";
function ToolbarSearch($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "value",
    "expanded",
    "persistent",
    "disabled",
    "shouldFilterRows",
    "filteredRowIds",
    "tabindex",
    "ref"
  ]);
  push($$props, false, ToolbarSearch);
  const [$$stores, $$cleanup] = setup_stores();
  const $tableRows = () => (validate_store(tableRows, "tableRows"), store_get(tableRows, "$tableRows", $$stores));
  const originalRows = mutable_state();
  const classes = mutable_state();
  let value = prop($$props, "value", 12, "");
  let expanded = prop($$props, "expanded", 12, false);
  let persistent = prop($$props, "persistent", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let shouldFilterRows = prop($$props, "shouldFilterRows", 8, false);
  let filteredRowIds = prop($$props, "filteredRowIds", 28, () => []);
  let tabindex = prop($$props, "tabindex", 8, "0");
  let ref = prop($$props, "ref", 12, null);
  const { tableRows } = getContext("DataTable") ?? {};
  async function expandSearch() {
    await tick();
    if (disabled() || persistent() || expanded()) return;
    expanded(true);
    await tick();
    ref().focus();
  }
  legacy_pre_effect(() => $tableRows(), () => {
    set(originalRows, tableRows ? [...$tableRows()] : []);
  });
  legacy_pre_effect(
    () => (deep_read_state(shouldFilterRows()), get(originalRows), deep_read_state(value())),
    () => {
      if (shouldFilterRows()) {
        let rows = get(originalRows);
        if (value().trim().length > 0) {
          if (strict_equals(shouldFilterRows(), true)) {
            rows = rows.filter((row) => {
              return Object.entries(row).filter(([key]) => strict_equals(key, "id", false)).some(([key, _value]) => {
                var _a;
                if (strict_equals(typeof _value, "string") || strict_equals(typeof _value, "number")) {
                  return (_a = _value + "") == null ? void 0 : _a.toLowerCase().includes(value().trim().toLowerCase());
                }
              });
            });
          } else if (strict_equals(typeof shouldFilterRows(), "function")) {
            rows = rows.filter((row) => shouldFilterRows()(row, value()) ?? false);
          }
        }
        tableRows.set(rows);
        filteredRowIds(rows.map((row) => row.id));
      }
    }
  );
  legacy_pre_effect(() => deep_read_state(value()), () => {
    expanded(!!value().length);
  });
  legacy_pre_effect(
    () => (deep_read_state(expanded()), deep_read_state(persistent()), deep_read_state(disabled())),
    () => {
      set(classes, [
        expanded() && "bx--toolbar-search-container-active",
        persistent() ? "bx--toolbar-search-container-persistent" : "bx--toolbar-search-container-expandable",
        disabled() && "bx--toolbar-search-container-disabled"
      ].filter(Boolean).join(" "));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, Search_default);
    add_owner_effect(value, Search_default);
    Search_default(node, spread_props(
      {
        get tabindex() {
          return tabindex();
        },
        get disabled() {
          return disabled();
        }
      },
      () => $$restProps,
      {
        get searchClass() {
          return `${get(classes) ?? ""} ${$$restProps.class ?? ""}`;
        },
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        },
        get value() {
          return value();
        },
        set value($$value) {
          value($$value);
        },
        $$events: {
          clear: [
            function($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            expandSearch
          ],
          change($$arg) {
            bubble_event.call(this, $$props, $$arg);
          },
          input($$arg) {
            bubble_event.call(this, $$props, $$arg);
          },
          focus: [
            function($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            expandSearch
          ],
          blur: [
            function($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            () => {
              expanded(!persistent() && !!value().length);
            }
          ],
          keyup($$arg) {
            bubble_event.call(this, $$props, $$arg);
          },
          keydown($$arg) {
            bubble_event.call(this, $$props, $$arg);
          },
          paste($$arg) {
            bubble_event.call(this, $$props, $$arg);
          }
        },
        $$legacy: true
      }
    ));
  }
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  ToolbarSearch = hmr(ToolbarSearch, () => ToolbarSearch[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ToolbarSearch[HMR].source;
    set(ToolbarSearch[HMR].source, module.default[HMR].original);
  });
}
var ToolbarSearch_default = ToolbarSearch;
mark_module_end(ToolbarSearch);

// node_modules/carbon-components-svelte/src/DataTable/ToolbarBatchActions.svelte
mark_module_start();
ToolbarBatchActions[FILENAME] = "node_modules/carbon-components-svelte/src/DataTable/ToolbarBatchActions.svelte";
var root_134 = add_locations(template(`<div><div><p><span> </span></p></div> <div><!> <!></div></div>`), ToolbarBatchActions[FILENAME], [
  [
    78,
    2,
    [
      [83, 4, [[84, 6, [[85, 8]]]]],
      [88, 4]
    ]
  ]
]);
function ToolbarBatchActions($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["formatTotalSelected", "active"]);
  push($$props, false, ToolbarBatchActions);
  const showActions = mutable_state();
  let formatTotalSelected = prop($$props, "formatTotalSelected", 8, (totalSelected) => `${totalSelected} item${strict_equals(totalSelected, 1) ? "" : "s"} selected`);
  let active = prop($$props, "active", 12, void 0);
  let batchSelectedIds = mutable_state([]);
  let prevActive = mutable_state();
  const dispatch = createEventDispatcher();
  const ctx = getContext("DataTable");
  function cancel() {
    const shouldContinue = dispatch("cancel", null, { cancelable: true });
    if (shouldContinue) {
      ctx.resetSelectedRowIds();
    }
  }
  const unsubscribe = ctx.batchSelectedIds.subscribe((value) => {
    set(batchSelectedIds, value);
  });
  let overflowVisible = mutable_state(false);
  const ctxToolbar = getContext("Toolbar");
  const unsubscribeOverflow = ctxToolbar.overflowVisible.subscribe((value) => {
    set(overflowVisible, value);
  });
  onMount(() => {
    return () => {
      unsubscribe();
      unsubscribeOverflow();
    };
  });
  afterUpdate(() => {
    if (strict_equals(active(), false) && get(showActions)) {
      active(true);
    }
  });
  legacy_pre_effect(
    () => (get(batchSelectedIds), deep_read_state(active())),
    () => {
      set(showActions, get(batchSelectedIds).length > 0 || active());
    }
  );
  legacy_pre_effect(
    () => (get(prevActive), deep_read_state(active())),
    () => {
      if (strict_equals(get(prevActive), active(), false) && strict_equals(active(), false)) {
        set(showActions, false);
      }
      set(prevActive, active());
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_134();
      let attributes;
      var div_1 = child(div);
      toggle_class(div_1, "bx--batch-summary", true);
      var p = child(div_1);
      toggle_class(p, "bx--batch-summary__para", true);
      var span = child(p);
      var text2 = child(span, true);
      reset(span);
      reset(p);
      reset(div_1);
      var div_2 = sibling(div_1, 2);
      toggle_class(div_2, "bx--action-list", true);
      var node_1 = child(div_2);
      slot(node_1, $$props, "default", {}, null);
      var node_2 = sibling(node_1, 2);
      const expression = derived_safe_equal(() => get(showActions) ? "0" : "-1");
      Button_default(node_2, {
        class: "bx--batch-summary__cancel",
        get tabindex() {
          return get(expression);
        },
        $$events: { click: cancel },
        children: wrap_snippet(ToolbarBatchActions, ($$anchor3, $$slotProps) => {
          var fragment_1 = comment();
          var node_3 = first_child(fragment_1);
          slot(node_3, $$props, "cancel", {}, ($$anchor4) => {
            var text_1 = text("Cancel");
            append($$anchor4, text_1);
          });
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      });
      reset(div_2);
      reset(div);
      template_effect(
        ($0) => {
          attributes = set_attributes(div, attributes, { ...$$restProps });
          toggle_class(div, "bx--batch-actions", true);
          toggle_class(div, "bx--batch-actions--active", get(showActions));
          set_text(text2, $0);
        },
        [
          () => formatTotalSelected()(get(batchSelectedIds).length)
        ],
        derived_safe_equal
      );
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if (!get(overflowVisible)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ToolbarBatchActions = hmr(ToolbarBatchActions, () => ToolbarBatchActions[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ToolbarBatchActions[HMR].source;
    set(ToolbarBatchActions[HMR].source, module.default[HMR].original);
  });
}
var ToolbarBatchActions_default = ToolbarBatchActions;
mark_module_end(ToolbarBatchActions);

// node_modules/carbon-components-svelte/src/icons/Settings.svelte
mark_module_start();
Settings[FILENAME] = "node_modules/carbon-components-svelte/src/icons/Settings.svelte";
var root_135 = add_locations(ns_template(`<title> </title>`), Settings[FILENAME], [[24, 13]]);
var root49 = add_locations(ns_template(`<svg><!><path d="M27,16.76c0-.25,0-.5,0-.76s0-.51,0-.77l1.92-1.68A2,2,0,0,0,29.3,11L26.94,7a2,2,0,0,0-1.73-1,2,2,0,0,0-.64.1l-2.43.82a11.35,11.35,0,0,0-1.31-.75l-.51-2.52a2,2,0,0,0-2-1.61H13.64a2,2,0,0,0-2,1.61l-.51,2.52a11.48,11.48,0,0,0-1.32.75L7.43,6.06A2,2,0,0,0,6.79,6,2,2,0,0,0,5.06,7L2.7,11a2,2,0,0,0,.41,2.51L5,15.24c0,.25,0,.5,0,.76s0,.51,0,.77L3.11,18.45A2,2,0,0,0,2.7,21L5.06,25a2,2,0,0,0,1.73,1,2,2,0,0,0,.64-.1l2.43-.82a11.35,11.35,0,0,0,1.31.75l.51,2.52a2,2,0,0,0,2,1.61h4.72a2,2,0,0,0,2-1.61l.51-2.52a11.48,11.48,0,0,0,1.32-.75l2.42.82a2,2,0,0,0,.64.1,2,2,0,0,0,1.73-1L29.3,21a2,2,0,0,0-.41-2.51ZM25.21,24l-3.43-1.16a8.86,8.86,0,0,1-2.71,1.57L18.36,28H13.64l-.71-3.55a9.36,9.36,0,0,1-2.7-1.57L6.79,24,4.43,20l2.72-2.4a8.9,8.9,0,0,1,0-3.13L4.43,12,6.79,8l3.43,1.16a8.86,8.86,0,0,1,2.71-1.57L13.64,4h4.72l.71,3.55a9.36,9.36,0,0,1,2.7,1.57L25.21,8,27.57,12l-2.72,2.4a8.9,8.9,0,0,1,0,3.13L27.57,20Z"></path><path d="M16,22a6,6,0,1,1,6-6A5.94,5.94,0,0,1,16,22Zm0-10a3.91,3.91,0,0,0-4,4,3.91,3.91,0,0,0,4,4,3.91,3.91,0,0,0,4-4A3.91,3.91,0,0,0,16,12Z"></path></svg>`), Settings[FILENAME], [[14, 0, [[25, 2], [27, 10]]]]);
function Settings($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, Settings);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root49();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_135();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next(2);
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Settings = hmr(Settings, () => Settings[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Settings[HMR].source;
    set(Settings[HMR].source, module.default[HMR].original);
  });
}
var Settings_default = Settings;
mark_module_end(Settings);

// node_modules/carbon-components-svelte/src/icons/OverflowMenuVertical.svelte
mark_module_start();
OverflowMenuVertical[FILENAME] = "node_modules/carbon-components-svelte/src/icons/OverflowMenuVertical.svelte";
var root_136 = add_locations(ns_template(`<title> </title>`), OverflowMenuVertical[FILENAME], [[24, 13]]);
var root50 = add_locations(ns_template(`<svg><!><circle cx="16" cy="8" r="2"></circle><circle cx="16" cy="16" r="2"></circle><circle cx="16" cy="24" r="2"></circle></svg>`), OverflowMenuVertical[FILENAME], [
  [
    14,
    0,
    [[25, 2], [25, 40], [26, 12]]
  ]
]);
function OverflowMenuVertical($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, OverflowMenuVertical);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root50();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_136();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next(3);
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  OverflowMenuVertical = hmr(OverflowMenuVertical, () => OverflowMenuVertical[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OverflowMenuVertical[HMR].source;
    set(OverflowMenuVertical[HMR].source, module.default[HMR].original);
  });
}
var OverflowMenuVertical_default = OverflowMenuVertical;
mark_module_end(OverflowMenuVertical);

// node_modules/carbon-components-svelte/src/icons/OverflowMenuHorizontal.svelte
mark_module_start();
OverflowMenuHorizontal[FILENAME] = "node_modules/carbon-components-svelte/src/icons/OverflowMenuHorizontal.svelte";
var root_137 = add_locations(ns_template(`<title> </title>`), OverflowMenuHorizontal[FILENAME], [[24, 13]]);
var root51 = add_locations(ns_template(`<svg><!><circle cx="8" cy="16" r="2"></circle><circle cx="16" cy="16" r="2"></circle><circle cx="24" cy="16" r="2"></circle></svg>`), OverflowMenuHorizontal[FILENAME], [
  [
    14,
    0,
    [[25, 2], [25, 40], [26, 12]]
  ]
]);
function OverflowMenuHorizontal($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, OverflowMenuHorizontal);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root51();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_137();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next(3);
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  OverflowMenuHorizontal = hmr(OverflowMenuHorizontal, () => OverflowMenuHorizontal[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OverflowMenuHorizontal[HMR].source;
    set(OverflowMenuHorizontal[HMR].source, module.default[HMR].original);
  });
}
var OverflowMenuHorizontal_default = OverflowMenuHorizontal;
mark_module_end(OverflowMenuHorizontal);

// node_modules/carbon-components-svelte/src/OverflowMenu/OverflowMenu.svelte
mark_module_start();
OverflowMenu[FILENAME] = "node_modules/carbon-components-svelte/src/OverflowMenu/OverflowMenu.svelte";
var root_36 = add_locations(template(`<ul role="menu" tabindex="-1"><!></ul>`), OverflowMenu[FILENAME], [[247, 4]]);
var root52 = add_locations(template(`<button><!> <!></button>`), OverflowMenu[FILENAME], [[192, 0]]);
function OverflowMenu($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "size",
    "direction",
    "open",
    "light",
    "flipped",
    "menuOptionsClass",
    "icon",
    "iconClass",
    "iconDescription",
    "id",
    "buttonRef",
    "menuRef"
  ]);
  push($$props, false, OverflowMenu);
  const [$$stores, $$cleanup] = setup_stores();
  const $currentIndex = () => (validate_store(currentIndex, "currentIndex"), store_get(currentIndex, "$currentIndex", $$stores));
  const $items = () => (validate_store(items, "items"), store_get(items, "$items", $$stores));
  const $currentId = () => (validate_store(currentId, "currentId"), store_get(currentId, "$currentId", $$stores));
  const ariaLabel = mutable_state();
  const styles = mutable_state();
  let size = prop($$props, "size", 8, void 0);
  let direction = prop($$props, "direction", 8, "bottom");
  let open = prop($$props, "open", 12, false);
  let light = prop($$props, "light", 8, false);
  let flipped = prop($$props, "flipped", 8, false);
  let menuOptionsClass = prop($$props, "menuOptionsClass", 8, void 0);
  let icon = prop($$props, "icon", 12, OverflowMenuVertical_default);
  let iconClass = prop($$props, "iconClass", 8, void 0);
  let iconDescription = prop($$props, "iconDescription", 8, "Open and close list of options");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let buttonRef = prop($$props, "buttonRef", 12, null);
  let menuRef = prop($$props, "menuRef", 12, null);
  const ctxBreadcrumbItem = getContext("BreadcrumbItem");
  const dispatch = createEventDispatcher();
  const items = writable([]);
  const currentId = writable(void 0);
  const focusedId = writable(void 0);
  const currentIndex = writable(-1);
  let buttonWidth = mutable_state(void 0);
  let onMountAfterUpdate = true;
  setContext("OverflowMenu", {
    focusedId,
    add: ({ id: id2, text: text2, primaryFocus, disabled }) => {
      items.update((_) => {
        if (primaryFocus) {
          currentIndex.set(_.length);
        }
        return [
          ..._,
          {
            id: id2,
            text: text2,
            primaryFocus,
            disabled,
            index: _.length
          }
        ];
      });
    },
    update: (id2) => {
      currentId.set(id2);
    },
    change: (direction2) => {
      let index2 = $currentIndex() + direction2;
      if (index2 < 0) {
        index2 = $items().length - 1;
      } else if (index2 >= $items().length) {
        index2 = 0;
      }
      let disabled = $items()[index2].disabled;
      while (disabled) {
        index2 = index2 + direction2;
        if (index2 < 0) {
          index2 = $items().length - 1;
        } else if (index2 >= $items().length) {
          index2 = 0;
        }
        disabled = $items()[index2].disabled;
      }
      currentIndex.set(index2);
    }
  });
  afterUpdate(() => {
    if ($currentId()) {
      const { index: index2, text: text2 } = $items().filter((_) => strict_equals(_.id, $currentId()))[0];
      dispatch("close", { index: index2, text: text2 });
      open(false);
    }
    if (open()) {
      const width = buttonRef().offsetWidth;
      const height = buttonRef().offsetHeight;
      set(buttonWidth, width);
      if (!onMountAfterUpdate && $currentIndex() < 0) {
        menuRef().focus();
      }
      if (flipped()) {
        menuRef(menuRef().style.left = "auto", true);
        menuRef(menuRef().style.right = 0, true);
      }
      if (strict_equals(direction(), "top")) {
        menuRef(menuRef().style.top = "auto", true);
        menuRef(menuRef().style.bottom = height + "px", true);
      } else if (strict_equals(direction(), "bottom")) {
        menuRef(menuRef().style.top = height + "px", true);
      }
      if (ctxBreadcrumbItem) {
        menuRef(menuRef().style.top = height + 10 + "px", true);
        menuRef(menuRef().style.left = "-11px", true);
      }
    }
    if (!open()) {
      items.set([]);
      currentId.set(void 0);
      currentIndex.set(0);
    }
    onMountAfterUpdate = false;
  });
  legacy_pre_effect(() => OverflowMenuHorizontal_default, () => {
    if (ctxBreadcrumbItem) {
      icon(OverflowMenuHorizontal_default);
    }
  });
  legacy_pre_effect(() => deep_read_state($$sanitized_props), () => {
    set(ariaLabel, $$sanitized_props["aria-label"] || "menu");
  });
  legacy_pre_effect(() => ($items(), $currentIndex()), () => {
    if ($items()[$currentIndex()]) {
      focusedId.set($items()[$currentIndex()].id);
    }
  });
  legacy_pre_effect(
    () => (deep_read_state(id()), get(buttonWidth)),
    () => {
      set(styles, `<style>
    #${id()} .bx--overflow-menu-options.bx--overflow-menu-options:after {
      width: ${get(buttonWidth) ? get(buttonWidth) + "px" : "2rem"};
    }
  </style>`);
    }
  );
  legacy_pre_effect_reset();
  init();
  var button = root52();
  head(($$anchor2) => {
    var fragment = comment();
    var node = first_child(fragment);
    html(node, () => get(styles), false, false);
    append($$anchor2, fragment);
  });
  event2("click", $window, ({ target }) => {
    if (buttonRef() && buttonRef().contains(target)) return;
    if (menuRef() && !menuRef().contains(target)) {
      open(false);
    }
  });
  let attributes;
  var node_1 = child(button);
  slot(node_1, $$props, "menu", {}, ($$anchor2) => {
    var fragment_1 = comment();
    var node_2 = first_child(fragment_1);
    component(node_2, icon, ($$anchor3, $$component) => {
      $$component($$anchor3, {
        get "aria-label"() {
          return iconDescription();
        },
        get title() {
          return iconDescription();
        },
        get class() {
          return `bx--overflow-menu__icon ${iconClass() ?? ""}`;
        }
      });
    });
    append($$anchor2, fragment_1);
  });
  var node_3 = sibling(node_1, 2);
  {
    var consequent = ($$anchor2) => {
      var ul = root_36();
      var node_4 = child(ul);
      slot(node_4, $$props, "default", {}, null);
      reset(ul);
      bind_this(ul, ($$value) => menuRef($$value), () => menuRef());
      template_effect(() => {
        set_attribute(ul, "aria-label", get(ariaLabel));
        set_attribute(ul, "data-floating-menu-direction", direction());
        set_class(ul, menuOptionsClass());
        toggle_class(ul, "bx--overflow-menu-options", true);
        toggle_class(ul, "bx--overflow-menu--flip", flipped());
        toggle_class(ul, "bx--overflow-menu-options--open", open());
        toggle_class(ul, "bx--overflow-menu-options--light", light());
        toggle_class(ul, "bx--overflow-menu-options--sm", strict_equals(size(), "sm"));
        toggle_class(ul, "bx--overflow-menu-options--xl", strict_equals(size(), "xl"));
        toggle_class(ul, "bx--breadcrumb-menu-options", !!ctxBreadcrumbItem);
      });
      append($$anchor2, ul);
    };
    if_block(node_3, ($$render) => {
      if (open()) $$render(consequent);
    });
  }
  reset(button);
  bind_this(button, ($$value) => buttonRef($$value), () => buttonRef());
  template_effect(() => {
    attributes = set_attributes(button, attributes, {
      type: "button",
      "aria-haspopup": "true",
      "aria-expanded": open(),
      "aria-label": get(ariaLabel),
      id: id(),
      ...$$restProps
    });
    toggle_class(button, "bx--overflow-menu", true);
    toggle_class(button, "bx--overflow-menu--open", open());
    toggle_class(button, "bx--overflow-menu--light", light());
    toggle_class(button, "bx--overflow-menu--sm", strict_equals(size(), "sm"));
    toggle_class(button, "bx--overflow-menu--xl", strict_equals(size(), "xl"));
  });
  event2("click", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", button, ({ target }) => {
    if (!(menuRef() && menuRef().contains(target))) {
      open(!open());
      if (!open()) dispatch("close");
    }
  });
  event2("mouseover", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", button, (e) => {
    if (open()) {
      if ([
        "ArrowDown",
        "ArrowLeft",
        "ArrowRight",
        "ArrowUp"
      ].includes(e.key)) {
        e.preventDefault();
      } else if (strict_equals(e.key, "Escape")) {
        e.stopPropagation();
        dispatch("close");
        open(false);
        buttonRef().focus();
      }
    }
  });
  event2("focusout", button, (e) => {
    if (open()) {
      if (!buttonRef().contains(e.relatedTarget)) {
        dispatch("close");
        open(false);
      }
    }
  });
  append($$anchor, button);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  OverflowMenu = hmr(OverflowMenu, () => OverflowMenu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OverflowMenu[HMR].source;
    set(OverflowMenu[HMR].source, module.default[HMR].original);
  });
}
var OverflowMenu_default = OverflowMenu;
mark_module_end(OverflowMenu);

// node_modules/carbon-components-svelte/src/DataTable/ToolbarMenu.svelte
mark_module_start();
ToolbarMenu[FILENAME] = "node_modules/carbon-components-svelte/src/DataTable/ToolbarMenu.svelte";
function ToolbarMenu($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, ToolbarMenu);
  const ctx = getContext("Toolbar");
  let menuRef = mutable_state(null);
  legacy_pre_effect(() => get(menuRef), () => {
    ctx.setOverflowVisible(equals(get(menuRef), null, false));
  });
  legacy_pre_effect(() => get(menuRef), () => {
    if (get(menuRef)) mutate(menuRef, get(menuRef).style.top = "100%");
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(() => get(menuRef), OverflowMenu_default);
    OverflowMenu_default(node, spread_props({ icon: Settings_default }, () => $$restProps, {
      get class() {
        return `bx--toolbar-action bx--overflow-menu ${$$restProps.class ?? ""}`;
      },
      flipped: true,
      get menuRef() {
        return get(menuRef);
      },
      set menuRef($$value) {
        set(menuRef, $$value);
      },
      children: wrap_snippet(ToolbarMenu, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        slot(node_1, $$props, "default", {}, null);
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true },
      $$legacy: true
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ToolbarMenu = hmr(ToolbarMenu, () => ToolbarMenu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ToolbarMenu[HMR].source;
    set(ToolbarMenu[HMR].source, module.default[HMR].original);
  });
}
var ToolbarMenu_default = ToolbarMenu;
mark_module_end(ToolbarMenu);

// node_modules/carbon-components-svelte/src/OverflowMenu/OverflowMenuItem.svelte
mark_module_start();
OverflowMenuItem[FILENAME] = "node_modules/carbon-components-svelte/src/OverflowMenu/OverflowMenuItem.svelte";
var root_217 = add_locations(template(`<div> </div>`), OverflowMenuItem[FILENAME], [[84, 8]]);
var root_138 = add_locations(template(`<a><!></a>`), OverflowMenuItem[FILENAME], [[67, 4]]);
var root_45 = add_locations(template(`<div> </div>`), OverflowMenuItem[FILENAME], [[107, 8]]);
var root_38 = add_locations(template(`<button><!></button>`), OverflowMenuItem[FILENAME], [[90, 4]]);
var root53 = add_locations(template(`<li><!></li>`), OverflowMenuItem[FILENAME], [[55, 0]]);
function OverflowMenuItem($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "text",
    "href",
    "primaryFocus",
    "disabled",
    "hasDivider",
    "danger",
    "requireTitle",
    "id",
    "ref"
  ]);
  push($$props, false, OverflowMenuItem);
  const [$$stores, $$cleanup] = setup_stores();
  const $focusedId = () => (validate_store(focusedId, "focusedId"), store_get(focusedId, "$focusedId", $$stores));
  const buttonProps = mutable_state();
  let text2 = prop($$props, "text", 8, "Provide text");
  let href = prop($$props, "href", 8, "");
  let primaryFocus = prop($$props, "primaryFocus", 12, false);
  let disabled = prop($$props, "disabled", 8, false);
  let hasDivider = prop($$props, "hasDivider", 8, false);
  let danger = prop($$props, "danger", 8, false);
  let requireTitle = prop($$props, "requireTitle", 8, true);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let ref = prop($$props, "ref", 12, null);
  const { focusedId, add, update: update2, change } = getContext("OverflowMenu");
  add({
    id: id(),
    text: text2(),
    primaryFocus: primaryFocus(),
    disabled: disabled()
  });
  afterUpdate(() => {
    if (ref() && primaryFocus()) {
      ref().focus();
    }
  });
  legacy_pre_effect(
    () => ($focusedId(), deep_read_state(id())),
    () => {
      primaryFocus(strict_equals($focusedId(), id()));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(href()), deep_read_state(disabled()), deep_read_state(requireTitle()), deep_read_state(text2())),
    () => {
      set(buttonProps, {
        role: "menuitem",
        tabindex: "-1",
        class: "bx--overflow-menu-options__btn",
        disabled: href() ? void 0 : disabled(),
        href: href() ? href() : void 0,
        title: requireTitle() ? $$slots.default ? void 0 : text2() : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var li = root53();
  let attributes;
  var node = child(li);
  {
    var consequent = ($$anchor2) => {
      var a = root_138();
      let attributes_1;
      var node_1 = child(a);
      slot(node_1, $$props, "default", {}, ($$anchor3) => {
        var div = root_217();
        toggle_class(div, "bx--overflow-menu-options__option-content", true);
        var text_1 = child(div, true);
        reset(div);
        template_effect(() => set_text(text_1, text2()));
        append($$anchor3, div);
      });
      reset(a);
      bind_this(a, ($$value) => ref($$value), () => ref());
      template_effect(() => attributes_1 = set_attributes(a, attributes_1, { ...get(buttonProps) }));
      event2("click", a, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("click", a, () => {
        update2(id());
      });
      event2("keydown", a, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("keydown", a, ({ key }) => {
        if (strict_equals(key, "ArrowDown")) {
          change(1);
        } else if (strict_equals(key, "ArrowUp")) {
          change(-1);
        }
      });
      append($$anchor2, a);
    };
    var alternate = ($$anchor2) => {
      var button = root_38();
      let attributes_2;
      var node_2 = child(button);
      slot(node_2, $$props, "default", {}, ($$anchor3) => {
        var div_1 = root_45();
        toggle_class(div_1, "bx--overflow-menu-options__option-content", true);
        var text_2 = child(div_1, true);
        reset(div_1);
        template_effect(() => set_text(text_2, text2()));
        append($$anchor3, div_1);
      });
      reset(button);
      bind_this(button, ($$value) => ref($$value), () => ref());
      template_effect(() => attributes_2 = set_attributes(button, attributes_2, { ...get(buttonProps) }));
      event2("click", button, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("click", button, () => {
        update2(id());
      });
      event2("keydown", button, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("keydown", button, ({ key }) => {
        if (strict_equals(key, "ArrowDown")) {
          change(1);
        } else if (strict_equals(key, "ArrowUp")) {
          change(-1);
        }
      });
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if (href()) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  reset(li);
  template_effect(() => {
    attributes = set_attributes(li, attributes, { role: "none", id: id(), ...$$restProps });
    toggle_class(li, "bx--overflow-menu-options__option", true);
    toggle_class(li, "bx--overflow-menu--divider", hasDivider());
    toggle_class(li, "bx--overflow-menu-options__option--danger", danger());
    toggle_class(li, "bx--overflow-menu-options__option--disabled", disabled());
  });
  append($$anchor, li);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  OverflowMenuItem = hmr(OverflowMenuItem, () => OverflowMenuItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OverflowMenuItem[HMR].source;
    set(OverflowMenuItem[HMR].source, module.default[HMR].original);
  });
}
var OverflowMenuItem_default = OverflowMenuItem;
mark_module_end(OverflowMenuItem);

// node_modules/carbon-components-svelte/src/DataTable/ToolbarMenuItem.svelte
mark_module_start();
ToolbarMenuItem[FILENAME] = "node_modules/carbon-components-svelte/src/DataTable/ToolbarMenuItem.svelte";
function ToolbarMenuItem($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, ToolbarMenuItem);
  var fragment = comment();
  var node = first_child(fragment);
  OverflowMenuItem_default(node, spread_props(() => $$restProps, {
    $$events: {
      click($$arg) {
        bubble_event.call(this, $$props, $$arg);
      },
      keydown($$arg) {
        bubble_event.call(this, $$props, $$arg);
      }
    },
    children: wrap_snippet(ToolbarMenuItem, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ToolbarMenuItem = hmr(ToolbarMenuItem, () => ToolbarMenuItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ToolbarMenuItem[HMR].source;
    set(ToolbarMenuItem[HMR].source, module.default[HMR].original);
  });
}
var ToolbarMenuItem_default = ToolbarMenuItem;
mark_module_end(ToolbarMenuItem);

// node_modules/carbon-components-svelte/src/DatePicker/createCalendar.js
var l10n;
function updateClasses(instance) {
  const {
    calendarContainer,
    days,
    daysContainer,
    weekdayContainer,
    selectedDates
  } = instance;
  calendarContainer.classList.add("bx--date-picker__calendar");
  calendarContainer.querySelector(".flatpickr-month").classList.add("bx--date-picker__month");
  weekdayContainer.classList.add("bx--date-picker__weekdays");
  weekdayContainer.querySelectorAll(".flatpickr-weekday").forEach((node) => {
    node.classList.add("bx--date-picker__weekday");
  });
  daysContainer.classList.add("bx--date-picker__days");
  days.querySelectorAll(".flatpickr-day").forEach((node) => {
    node.classList.add("bx--date-picker__day");
    if (node.classList.contains("today") && selectedDates.length > 0) {
      node.classList.add("no-border");
    } else if (node.classList.contains("today") && selectedDates.length === 0) {
      node.classList.remove("no-border");
    }
  });
}
function updateMonthNode(instance) {
  const monthText = instance.l10n.months.longhand[instance.currentMonth];
  const staticMonthNode = instance.monthNav.querySelector(".cur-month");
  if (staticMonthNode) {
    staticMonthNode.textContent = monthText;
  } else {
    const monthSelectNode = instance.monthsDropdownContainer;
    const span = document.createElement("span");
    span.setAttribute("class", "cur-month");
    span.textContent = monthText;
    monthSelectNode.parentNode.replaceChild(span, monthSelectNode);
  }
}
async function createCalendar({ options, base, input, dispatch }) {
  let locale = options.locale;
  if (options.locale === "en" && l10n && l10n.en) {
    l10n.en.weekdays.shorthand.forEach((_, index2) => {
      const shorthand = _.slice(0, 2);
      l10n.en.weekdays.shorthand[index2] = shorthand === "Th" ? "Th" : shorthand.charAt(0);
    });
    locale = l10n.en;
  }
  let rangePlugin;
  if (options.mode === "range") {
    const importee = await import("./flatpickr_dist_esm_plugins_rangePlugin.js");
    rangePlugin = importee.default;
  }
  return new esm_default(base, {
    allowInput: true,
    disableMobile: true,
    clickOpens: true,
    locale,
    plugins: [
      options.mode === "range" && new rangePlugin({ position: "left", input })
    ].filter(Boolean),
    nextArrow: '<svg width="16px" height="16px" viewBox="0 0 16 16"><polygon points="11,8 6,13 5.3,12.3 9.6,8 5.3,3.7 6,3 "/><rect width="16" height="16" style="fill: none" /></svg>',
    prevArrow: '<svg width="16px" height="16px" viewBox="0 0 16 16"><polygon points="5,8 10,3 10.7,3.7 6.4,8 10.7,12.3 10,13 "/><rect width="16" height="16" style="fill: none" /></svg>',
    onChange: () => {
      dispatch("change");
    },
    onClose: () => {
      dispatch("close");
    },
    onMonthChange: (s, d, instance) => {
      updateMonthNode(instance);
    },
    onOpen: (s, d, instance) => {
      dispatch("open");
      updateClasses(instance);
      updateMonthNode(instance);
    },
    ...options
  });
}

// node_modules/carbon-components-svelte/src/DatePicker/DatePicker.svelte
mark_module_start();
DatePicker[FILENAME] = "node_modules/carbon-components-svelte/src/DatePicker/DatePicker.svelte";
var root54 = add_locations(template(`<div><div><!></div></div>`), DatePicker[FILENAME], [[242, 0, [[251, 2]]]]);
function DatePicker($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "datePickerType",
    "value",
    "valueFrom",
    "valueTo",
    "dateFormat",
    "maxDate",
    "minDate",
    "locale",
    "short",
    "light",
    "id",
    "flatpickrProps"
  ]);
  push($$props, false, DatePicker);
  const [$$stores, $$cleanup] = setup_stores();
  const $inputIds = () => (validate_store(inputIds, "inputIds"), store_get(inputIds, "$inputIds", $$stores));
  const $inputValue = () => (validate_store(inputValue, "inputValue"), store_get(inputValue, "$inputValue", $$stores));
  const $mode = () => (validate_store(mode, "mode"), store_get(mode, "$mode", $$stores));
  const $range = () => (validate_store(range, "range"), store_get(range, "$range", $$stores));
  const $inputValueFrom = () => (validate_store(inputValueFrom, "inputValueFrom"), store_get(inputValueFrom, "$inputValueFrom", $$stores));
  const $inputValueTo = () => (validate_store(inputValueTo, "inputValueTo"), store_get(inputValueTo, "$inputValueTo", $$stores));
  const $hasCalendar = () => (validate_store(hasCalendar, "hasCalendar"), store_get(hasCalendar, "$hasCalendar", $$stores));
  const $labelTextEmpty = () => (validate_store(labelTextEmpty, "labelTextEmpty"), store_get(labelTextEmpty, "$labelTextEmpty", $$stores));
  let datePickerType = prop($$props, "datePickerType", 8, "simple");
  let value = prop($$props, "value", 12, "");
  let valueFrom = prop($$props, "valueFrom", 12, "");
  let valueTo = prop($$props, "valueTo", 12, "");
  let dateFormat = prop($$props, "dateFormat", 8, "m/d/Y");
  let maxDate = prop($$props, "maxDate", 8, null);
  let minDate = prop($$props, "minDate", 8, null);
  let locale = prop($$props, "locale", 8, "en");
  let short = prop($$props, "short", 8, false);
  let light = prop($$props, "light", 8, false);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let flatpickrProps = prop($$props, "flatpickrProps", 24, () => ({ static: true }));
  const dispatch = createEventDispatcher();
  const inputs = writable([]);
  const inputIds = derived2(inputs, (_) => _.map(({ id: id2 }) => id2));
  const labelTextEmpty = derived2(inputs, (_) => strict_equals(_.filter(({ labelText }) => !!labelText).length, 0));
  const inputValue = writable(value());
  const inputValueFrom = writable(valueFrom());
  const inputValueTo = writable(valueTo());
  const mode = writable(datePickerType());
  const range = derived2(mode, (_) => strict_equals(_, "range"));
  const hasCalendar = derived2(mode, (_) => strict_equals(_, "single") || strict_equals(_, "range"));
  let calendar = mutable_state(null);
  let datePickerRef = mutable_state(null);
  let inputRef = mutable_state(null);
  let inputRefTo = null;
  setContext("DatePicker", {
    range,
    inputValue,
    inputValueFrom,
    inputValueTo,
    inputIds,
    hasCalendar,
    add: (data) => {
      inputs.update((_) => [..._, data]);
    },
    declareRef: ({ id: id2, ref }) => {
      if (strict_equals($inputIds().indexOf(id2), 0)) {
        set(inputRef, ref);
      } else {
        inputRefTo = ref;
      }
    },
    updateValue: ({ type, value: value2 }) => {
      if (!get(calendar) && strict_equals(type, "input") || strict_equals(type, "change")) {
        inputValue.set(value2);
      }
      if (!get(calendar) && strict_equals(type, "change")) {
        dispatch("change", value2);
      }
    },
    blurInput: (relatedTarget) => {
      if (get(calendar) && !get(calendar).calendarContainer.contains(relatedTarget)) {
        get(calendar).close();
      }
    },
    openCalendar: () => {
      get(calendar).open();
    },
    focusCalendar: () => {
      (get(calendar).selectedDateElem || get(calendar).todayDateElem || get(calendar).calendarContainer.querySelector(".flatpickr-day[tabindex]") || get(calendar).calendarContainer).focus();
    }
  });
  async function initCalendar(options) {
    var _a, _b, _c, _d;
    if (get(calendar)) {
      get(calendar).set("minDate", minDate());
      get(calendar).set("maxDate", maxDate());
      get(calendar).set("locale", locale());
      get(calendar).set("dateFormat", dateFormat());
      Object.entries(flatpickrProps()).forEach(([option, value2]) => {
        get(calendar).set(options, value2);
      });
      return;
    }
    set(calendar, await createCalendar({
      options: {
        ...options,
        appendTo: get(datePickerRef),
        defaultDate: $inputValue(),
        mode: $mode()
      },
      base: get(inputRef),
      input: inputRefTo,
      dispatch: (event3) => {
        const detail = {
          selectedDates: get(calendar).selectedDates
        };
        if ($range()) {
          const from = get(inputRef).value;
          const to = inputRefTo.value;
          detail.dateStr = {
            from: get(inputRef).value,
            to: inputRefTo.value
          };
          valueFrom(from);
          valueTo(to);
        } else {
          detail.dateStr = get(inputRef).value;
        }
        return dispatch(event3, detail);
      }
    }));
    (_b = (_a = get(calendar)) == null ? void 0 : _a.calendarContainer) == null ? void 0 : _b.setAttribute("role", "application");
    (_d = (_c = get(calendar)) == null ? void 0 : _c.calendarContainer) == null ? void 0 : _d.setAttribute("aria-label", "calendar-container");
  }
  onMount(() => {
    return () => {
      if (get(calendar)) {
        get(calendar).destroy();
        set(calendar, null);
      }
    };
  });
  afterUpdate(() => {
    if (get(calendar)) {
      if ($range()) {
        get(calendar).setDate([$inputValueFrom(), $inputValueTo()]);
        mutate(inputRef, get(inputRef).value = $inputValueFrom());
      } else {
        get(calendar).setDate($inputValue());
      }
    }
  });
  legacy_pre_effect(() => $inputValue(), () => {
    value($inputValue());
  });
  legacy_pre_effect(() => deep_read_state(value()), () => {
    inputValue.set(value());
  });
  legacy_pre_effect(() => $inputValueFrom(), () => {
    valueFrom($inputValueFrom());
  });
  legacy_pre_effect(() => deep_read_state(valueFrom()), () => {
    inputValueFrom.set(valueFrom());
  });
  legacy_pre_effect(() => $inputValueTo(), () => {
    valueTo($inputValueTo());
  });
  legacy_pre_effect(() => deep_read_state(valueTo()), () => {
    inputValueTo.set(valueTo());
  });
  legacy_pre_effect(
    () => ($hasCalendar(), get(inputRef), deep_read_state(dateFormat()), deep_read_state(locale()), deep_read_state(maxDate()), deep_read_state(minDate()), deep_read_state(flatpickrProps())),
    () => {
      if ($hasCalendar() && get(inputRef)) {
        initCalendar({
          dateFormat: dateFormat(),
          locale: locale(),
          maxDate: maxDate(),
          minDate: minDate(),
          // default to static: true so the
          // date picker works inside a modal
          static: true,
          ...flatpickrProps()
        });
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root54();
  event2("click", $window, ({ target }) => {
    if (!get(calendar) || !get(calendar).isOpen) return;
    if (get(datePickerRef) && get(datePickerRef).contains(target)) return;
    if (!get(calendar).calendarContainer.contains(target)) get(calendar).close();
  });
  let attributes;
  var div_1 = child(div);
  var node = child(div_1);
  slot(node, $$props, "default", {}, null);
  reset(div_1);
  bind_this(div_1, ($$value) => set(datePickerRef, $$value), () => get(datePickerRef));
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--form-item", true);
    set_attribute(div_1, "id", id());
    toggle_class(div_1, "bx--date-picker", true);
    toggle_class(div_1, "bx--date-picker--short", short());
    toggle_class(div_1, "bx--date-picker--light", light());
    toggle_class(div_1, "bx--date-picker--simple", strict_equals(datePickerType(), "simple"));
    toggle_class(div_1, "bx--date-picker--single", strict_equals(datePickerType(), "single"));
    toggle_class(div_1, "bx--date-picker--range", strict_equals(datePickerType(), "range"));
    toggle_class(div_1, "bx--date-picker--nolabel", strict_equals(datePickerType(), "range") && $labelTextEmpty());
  });
  event2("keydown", div_1, (e) => {
    var _a;
    if (((_a = get(calendar)) == null ? void 0 : _a.isOpen) && strict_equals(e.key, "Escape")) {
      e.stopPropagation();
      get(calendar).close();
    }
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  DatePicker = hmr(DatePicker, () => DatePicker[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DatePicker[HMR].source;
    set(DatePicker[HMR].source, module.default[HMR].original);
  });
}
var DatePicker_default = DatePicker;
mark_module_end(DatePicker);

// node_modules/carbon-components-svelte/src/icons/Calendar.svelte
mark_module_start();
Calendar[FILENAME] = "node_modules/carbon-components-svelte/src/icons/Calendar.svelte";
var root_139 = add_locations(ns_template(`<title> </title>`), Calendar[FILENAME], [[24, 13]]);
var root55 = add_locations(ns_template(`<svg><!><path d="M26,4h-4V2h-2v2h-8V2h-2v2H6C4.9,4,4,4.9,4,6v20c0,1.1,0.9,2,2,2h20c1.1,0,2-0.9,2-2V6C28,4.9,27.1,4,26,4z M26,26H6V12h20	V26z M26,10H6V6h4v2h2V6h8v2h2V6h4V10z"></path></svg>`), Calendar[FILENAME], [[14, 0, [[25, 2]]]]);
function Calendar($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, Calendar);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root55();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_139();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next();
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar = hmr(Calendar, () => Calendar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar[HMR].source;
    set(Calendar[HMR].source, module.default[HMR].original);
  });
}
var Calendar_default = Calendar;
mark_module_end(Calendar);

// node_modules/carbon-components-svelte/src/DatePicker/DatePickerInput.svelte
mark_module_start();
DatePickerInput[FILENAME] = "node_modules/carbon-components-svelte/src/DatePicker/DatePickerInput.svelte";
var root_140 = add_locations(template(`<label><!></label>`), DatePickerInput[FILENAME], [[86, 4]]);
var root_65 = add_locations(template(`<div> </div>`), DatePickerInput[FILENAME], [[160, 4]]);
var root_74 = add_locations(template(`<div> </div>`), DatePickerInput[FILENAME], [[163, 4]]);
var root_82 = add_locations(template(`<div> </div>`), DatePickerInput[FILENAME], [[166, 4]]);
var root56 = add_locations(template(`<div><!> <div><input> <!> <!> <!></div> <!> <!> <!></div>`), DatePickerInput[FILENAME], [
  [81, 0, [[97, 2, [[102, 4]]]]]
]);
function DatePickerInput($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "size",
    "type",
    "placeholder",
    "pattern",
    "disabled",
    "helperText",
    "iconDescription",
    "id",
    "labelText",
    "hideLabel",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "name",
    "ref"
  ]);
  push($$props, false, DatePickerInput);
  const [$$stores, $$cleanup] = setup_stores();
  const $range = () => (validate_store(range, "range"), store_get(range, "$range", $$stores));
  const $inputIds = () => (validate_store(inputIds, "inputIds"), store_get(inputIds, "$inputIds", $$stores));
  const $inputValueFrom = () => (validate_store(inputValueFrom, "inputValueFrom"), store_get(inputValueFrom, "$inputValueFrom", $$stores));
  const $inputValueTo = () => (validate_store(inputValueTo, "inputValueTo"), store_get(inputValueTo, "$inputValueTo", $$stores));
  const $inputValue = () => (validate_store(inputValue, "inputValue"), store_get(inputValue, "$inputValue", $$stores));
  const $hasCalendar = () => (validate_store(hasCalendar, "hasCalendar"), store_get(hasCalendar, "$hasCalendar", $$stores));
  let size = prop($$props, "size", 8, void 0);
  let type = prop($$props, "type", 8, "text");
  let placeholder = prop($$props, "placeholder", 8, "");
  let pattern = prop($$props, "pattern", 8, "\\d{1,2}\\/\\d{1,2}\\/\\d{4}");
  let disabled = prop($$props, "disabled", 8, false);
  let helperText = prop($$props, "helperText", 8, "");
  let iconDescription = prop($$props, "iconDescription", 8, "");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let labelText = prop($$props, "labelText", 8, "");
  let hideLabel = prop($$props, "hideLabel", 8, false);
  let invalid = prop($$props, "invalid", 8, false);
  let invalidText = prop($$props, "invalidText", 8, "");
  let warn = prop($$props, "warn", 8, false);
  let warnText = prop($$props, "warnText", 8, "");
  let name = prop($$props, "name", 8, void 0);
  let ref = prop($$props, "ref", 12, null);
  const {
    range,
    add,
    hasCalendar,
    declareRef,
    inputIds,
    updateValue,
    blurInput,
    openCalendar,
    focusCalendar,
    inputValue,
    inputValueFrom,
    inputValueTo
  } = getContext("DatePicker");
  add({ id: id(), labelText: labelText() });
  legacy_pre_effect(
    () => (deep_read_state(ref()), deep_read_state(id())),
    () => {
      if (ref()) declareRef({ id: id(), ref: ref() });
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root56();
  toggle_class(div, "bx--date-picker-container", true);
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var label = root_140();
      var node_1 = child(label);
      slot(node_1, $$props, "labelText", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, labelText()));
        append($$anchor3, text2);
      });
      reset(label);
      template_effect(() => {
        set_attribute(label, "for", id());
        toggle_class(label, "bx--label", true);
        toggle_class(label, "bx--visually-hidden", hideLabel());
        toggle_class(label, "bx--label--disabled", disabled());
      });
      append($$anchor2, label);
    };
    if_block(node, ($$render) => {
      if (labelText() || $$slots.labelText) $$render(consequent);
    });
  }
  var div_1 = sibling(node, 2);
  toggle_class(div_1, "bx--date-picker-input__wrapper", true);
  var input = child(div_1);
  remove_input_defaults(input);
  let attributes;
  bind_this(input, ($$value) => ref($$value), () => ref());
  var node_2 = sibling(input, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_3 = first_child(fragment_1);
      WarningFilled_default(node_3, {
        class: "bx--date-picker__icon bx--date-picker__icon--invalid"
      });
      append($$anchor2, fragment_1);
    };
    if_block(node_2, ($$render) => {
      if (invalid()) $$render(consequent_1);
    });
  }
  var node_4 = sibling(node_2, 2);
  {
    var consequent_2 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_5 = first_child(fragment_2);
      WarningAltFilled_default(node_5, {
        class: "bx--date-picker__icon bx--date-picker__icon--warn"
      });
      append($$anchor2, fragment_2);
    };
    if_block(node_4, ($$render) => {
      if (!invalid() && warn()) $$render(consequent_2);
    });
  }
  var node_6 = sibling(node_4, 2);
  {
    var consequent_3 = ($$anchor2) => {
      var fragment_3 = comment();
      var node_7 = first_child(fragment_3);
      Calendar_default(node_7, {
        class: "bx--date-picker__icon",
        get "aria-label"() {
          return iconDescription();
        },
        $$events: { click: openCalendar }
      });
      append($$anchor2, fragment_3);
    };
    if_block(node_6, ($$render) => {
      if ($hasCalendar() && !invalid() && !warn()) $$render(consequent_3);
    });
  }
  reset(div_1);
  var node_8 = sibling(div_1, 2);
  {
    var consequent_4 = ($$anchor2) => {
      var div_2 = root_65();
      toggle_class(div_2, "bx--form-requirement", true);
      var text_1 = child(div_2, true);
      reset(div_2);
      template_effect(() => set_text(text_1, invalidText()));
      append($$anchor2, div_2);
    };
    if_block(node_8, ($$render) => {
      if (invalid()) $$render(consequent_4);
    });
  }
  var node_9 = sibling(node_8, 2);
  {
    var consequent_5 = ($$anchor2) => {
      var div_3 = root_74();
      toggle_class(div_3, "bx--form-requirement", true);
      var text_2 = child(div_3, true);
      reset(div_3);
      template_effect(() => set_text(text_2, warnText()));
      append($$anchor2, div_3);
    };
    if_block(node_9, ($$render) => {
      if (!invalid() && warn()) $$render(consequent_5);
    });
  }
  var node_10 = sibling(node_9, 2);
  {
    var consequent_6 = ($$anchor2) => {
      var div_4 = root_82();
      toggle_class(div_4, "bx--form__helper-text", true);
      var text_3 = child(div_4, true);
      reset(div_4);
      template_effect(() => {
        toggle_class(div_4, "bx--form__helper-text--disabled", disabled());
        set_text(text_3, helperText());
      });
      append($$anchor2, div_4);
    };
    if_block(node_10, ($$render) => {
      if (!invalid() && !warn() && helperText()) $$render(consequent_6);
    });
  }
  reset(div);
  template_effect(
    ($0) => {
      toggle_class(div, "bx--date-picker--nolabel", !labelText());
      toggle_class(div_1, "bx--date-picker-input__wrapper--invalid", invalid());
      toggle_class(div_1, "bx--date-picker-input__wrapper--warn", warn());
      attributes = set_attributes(input, attributes, {
        "data-invalid": invalid() || void 0,
        id: id(),
        name: name(),
        placeholder: placeholder(),
        type: type(),
        pattern: pattern(),
        disabled: disabled(),
        ...$$restProps,
        value: $0
      });
      toggle_class(input, "bx--date-picker__input", true);
      toggle_class(input, "bx--date-picker__input--invalid", invalid());
      toggle_class(input, "bx--date-picker__input--sm", strict_equals(size(), "sm"));
      toggle_class(input, "bx--date-picker__input--xl", strict_equals(size(), "xl"));
    },
    [
      () => $range() ? strict_equals($inputIds().indexOf(id()), 0) ? $inputValueFrom() : $inputValueTo() : $inputValue()
    ],
    derived_safe_equal
  );
  event2("input", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("input", input, ({ target }) => {
    updateValue({ type: "input", value: target.value });
  });
  event2("change", input, ({ target }) => {
    updateValue({ type: "change", value: target.value });
  });
  event2("keydown", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", input, ({ key }) => {
    if (strict_equals(key, "ArrowDown")) {
      focusCalendar();
    }
  });
  event2("keyup", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("blur", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("blur", input, ({ relatedTarget }) => {
    blurInput(relatedTarget);
  });
  event2("paste", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  DatePickerInput = hmr(DatePickerInput, () => DatePickerInput[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DatePickerInput[HMR].source;
    set(DatePickerInput[HMR].source, module.default[HMR].original);
  });
}
var DatePickerInput_default = DatePickerInput;
mark_module_end(DatePickerInput);

// node_modules/carbon-components-svelte/src/DatePicker/DatePickerSkeleton.svelte
mark_module_start();
DatePickerSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/DatePicker/DatePickerSkeleton.svelte";
var root_141 = add_locations(template(`<div><label></label> <div></div></div>`), DatePickerSkeleton[FILENAME], [[27, 6, [[28, 8], [29, 8]]]]);
var root57 = add_locations(template(`<div><div></div></div>`), DatePickerSkeleton[FILENAME], [[11, 0, [[19, 2]]]]);
function DatePickerSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["range", "id"]);
  push($$props, false, DatePickerSkeleton);
  let range = prop($$props, "range", 8, false);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  init();
  var div = root57();
  let attributes;
  var div_1 = child(div);
  toggle_class(div_1, "bx--date-picker", true);
  toggle_class(div_1, "bx--skeleton", true);
  toggle_class(div_1, "bx--date-picker--range", true);
  validate_each_keys(() => Array.from({ length: range() ? 2 : 1 }, (_, i) => i), (input) => input);
  each(div_1, 7, () => Array.from({ length: range() ? 2 : 1 }, (_, i) => i), (input) => input, ($$anchor2, input) => {
    var div_2 = root_141();
    toggle_class(div_2, "bx--date-picker-container", true);
    var label = child(div_2);
    var div_3 = sibling(label, 2);
    toggle_class(div_3, "bx--date-picker__input", true);
    toggle_class(div_3, "bx--skeleton", true);
    reset(div_2);
    template_effect(() => {
      set_attribute(label, "for", id());
      toggle_class(label, "bx--label", true);
    });
    append($$anchor2, div_2);
  });
  reset(div_1);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--form-item", true);
    toggle_class(div_1, "bx--date-picker--short", !range());
    toggle_class(div_1, "bx--date-picker--simple", !range());
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DatePickerSkeleton = hmr(DatePickerSkeleton, () => DatePickerSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DatePickerSkeleton[HMR].source;
    set(DatePickerSkeleton[HMR].source, module.default[HMR].original);
  });
}
var DatePickerSkeleton_default = DatePickerSkeleton;
mark_module_end(DatePickerSkeleton);

// node_modules/carbon-components-svelte/src/Dropdown/Dropdown.svelte
mark_module_start();
Dropdown[FILENAME] = "node_modules/carbon-components-svelte/src/Dropdown/Dropdown.svelte";
var root_143 = add_locations(template(`<label> </label>`), Dropdown[FILENAME], [[185, 4]]);
var root_218 = add_locations(template(`<!> <!> <button type="button" tabindex="0"><span><!></span> <!></button> <!>`, 1), Dropdown[FILENAME], [[230, 4, [[286, 6]]]]);
var root_1210 = add_locations(template(`<div> </div>`), Dropdown[FILENAME], [[330, 4]]);
var root58 = add_locations(template(`<div><!> <!> <!></div>`), Dropdown[FILENAME], [[176, 0]]);
function Dropdown($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "items",
    "itemToString",
    "selectedId",
    "type",
    "direction",
    "size",
    "open",
    "light",
    "disabled",
    "titleText",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "helperText",
    "label",
    "hideLabel",
    "translateWithId",
    "id",
    "name",
    "ref"
  ]);
  push($$props, false, Dropdown);
  const inline = mutable_state();
  const selectedItem = mutable_state();
  let items = prop($$props, "items", 24, () => []);
  let itemToString = prop($$props, "itemToString", 8, (item) => item.text || item.id);
  let selectedId = prop($$props, "selectedId", 12);
  let type = prop($$props, "type", 8, "default");
  let direction = prop($$props, "direction", 8, "bottom");
  let size = prop($$props, "size", 8, void 0);
  let open = prop($$props, "open", 12, false);
  let light = prop($$props, "light", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let titleText = prop($$props, "titleText", 8, "");
  let invalid = prop($$props, "invalid", 8, false);
  let invalidText = prop($$props, "invalidText", 8, "");
  let warn = prop($$props, "warn", 8, false);
  let warnText = prop($$props, "warnText", 8, "");
  let helperText = prop($$props, "helperText", 8, "");
  let label = prop($$props, "label", 8, void 0);
  let hideLabel = prop($$props, "hideLabel", 8, false);
  let translateWithId = prop($$props, "translateWithId", 8, void 0);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let name = prop($$props, "name", 8, void 0);
  let ref = prop($$props, "ref", 12, null);
  const dispatch = createEventDispatcher();
  let highlightedIndex = mutable_state(-1);
  function change(dir) {
    let index2 = get(highlightedIndex) + dir;
    if (strict_equals(items().length, 0)) return;
    if (index2 < 0) {
      index2 = items().length - 1;
    } else if (index2 >= items().length) {
      index2 = 0;
    }
    let disabled2 = items()[index2].disabled;
    while (disabled2) {
      index2 = index2 + dir;
      if (index2 < 0) {
        index2 = items().length - 1;
      } else if (index2 >= items().length) {
        index2 = 0;
      }
      disabled2 = items()[index2].disabled;
    }
    set(highlightedIndex, index2);
  }
  const dispatchSelect = () => {
    dispatch("select", {
      selectedId: selectedId(),
      selectedItem: items().find((item) => strict_equals(item.id, selectedId()))
    });
  };
  const pageClickHandler = ({ target }) => {
    if (open() && ref() && !ref().contains(target)) {
      open(false);
    }
  };
  onMount(() => {
    if (parent) {
      parent.addEventListener("click", pageClickHandler);
    }
    return () => {
      if (parent) {
        parent.removeEventListener("click", pageClickHandler);
      }
    };
  });
  legacy_pre_effect(() => deep_read_state(type()), () => {
    set(inline, strict_equals(type(), "inline"));
  });
  legacy_pre_effect(
    () => (deep_read_state(items()), deep_read_state(selectedId())),
    () => {
      set(selectedItem, items().find((item) => strict_equals(item.id, selectedId())));
    }
  );
  legacy_pre_effect(() => deep_read_state(open()), () => {
    if (!open()) {
      set(highlightedIndex, -1);
    }
  });
  legacy_pre_effect_reset();
  init();
  var div = root58();
  event2("click", $window, pageClickHandler);
  let attributes;
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var label_1 = root_143();
      var text2 = child(label_1, true);
      reset(label_1);
      template_effect(() => {
        set_attribute(label_1, "for", id());
        toggle_class(label_1, "bx--label", true);
        toggle_class(label_1, "bx--label--disabled", disabled());
        toggle_class(label_1, "bx--visually-hidden", hideLabel());
        set_text(text2, titleText());
      });
      append($$anchor2, label_1);
    };
    if_block(node, ($$render) => {
      if (titleText()) $$render(consequent);
    });
  }
  var node_1 = sibling(node, 2);
  const expression = derived_safe_equal(() => strict_equals(direction(), "top") && "bx--list-box--up");
  const expression_1 = derived_safe_equal(() => invalid() && "bx--dropdown--invalid");
  const expression_2 = derived_safe_equal(() => !invalid() && warn() && "bx--dropdown--warning");
  const expression_3 = derived_safe_equal(() => open() && "bx--dropdown--open");
  const expression_4 = derived_safe_equal(() => strict_equals(size(), "sm") && "bx--dropdown--sm");
  const expression_5 = derived_safe_equal(() => strict_equals(size(), "xl") && "bx--dropdown--xl");
  const expression_6 = derived_safe_equal(() => get(inline) && "bx--dropdown--inline");
  const expression_7 = derived_safe_equal(() => disabled() && "bx--dropdown--disabled");
  const expression_8 = derived_safe_equal(() => light() && "bx--dropdown--light");
  ListBox_default(node_1, {
    role: void 0,
    get type() {
      return type();
    },
    get size() {
      return size();
    },
    get name() {
      return name();
    },
    get "aria-label"() {
      return $$sanitized_props["aria-label"];
    },
    get class() {
      return `bx--dropdown 
      ${get(expression) ?? ""} 
      ${get(expression_1) ?? ""} 
      ${get(expression_2) ?? ""} 
      ${get(expression_3) ?? ""}
      ${get(expression_4) ?? ""}
      ${get(expression_5) ?? ""}
      ${get(expression_6) ?? ""}
      ${get(expression_7) ?? ""}
      ${get(expression_8) ?? ""}`;
    },
    get disabled() {
      return disabled();
    },
    get open() {
      return open();
    },
    get invalid() {
      return invalid();
    },
    get invalidText() {
      return invalidText();
    },
    get light() {
      return light();
    },
    get warn() {
      return warn();
    },
    get warnText() {
      return warnText();
    },
    $$events: {
      click: ({ target }) => {
        if (disabled()) return;
        open(ref().contains(target) ? !open() : false);
      }
    },
    children: wrap_snippet(Dropdown, ($$anchor2, $$slotProps) => {
      var fragment = root_218();
      var node_2 = first_child(fragment);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_1 = comment();
          var node_3 = first_child(fragment_1);
          WarningFilled_default(node_3, { class: "bx--list-box__invalid-icon" });
          append($$anchor3, fragment_1);
        };
        if_block(node_2, ($$render) => {
          if (invalid()) $$render(consequent_1);
        });
      }
      var node_4 = sibling(node_2, 2);
      {
        var consequent_2 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_5 = first_child(fragment_2);
          WarningAltFilled_default(node_5, {
            class: "bx--list-box__invalid-icon bx--list-box__invalid-icon--warning"
          });
          append($$anchor3, fragment_2);
        };
        if_block(node_4, ($$render) => {
          if (!invalid() && warn()) $$render(consequent_2);
        });
      }
      var button = sibling(node_4, 2);
      var span = child(button);
      toggle_class(span, "bx--list-box__label", true);
      var node_6 = child(span);
      {
        var consequent_3 = ($$anchor3) => {
          var text_1 = text();
          template_effect(
            ($0) => set_text(text_1, $0),
            [
              () => itemToString()(get(selectedItem))
            ],
            derived_safe_equal
          );
          append($$anchor3, text_1);
        };
        var alternate = ($$anchor3) => {
          var text_2 = text();
          template_effect(() => set_text(text_2, label()));
          append($$anchor3, text_2);
        };
        if_block(node_6, ($$render) => {
          if (get(selectedItem)) $$render(consequent_3);
          else $$render(alternate, false);
        });
      }
      reset(span);
      var node_7 = sibling(span, 2);
      ListBoxMenuIcon_default(node_7, {
        get translateWithId() {
          return translateWithId();
        },
        get open() {
          return open();
        },
        $$events: {
          click: (e) => {
            e.stopPropagation();
            if (disabled()) return;
            open(!open());
          }
        }
      });
      reset(button);
      bind_this(button, ($$value) => ref($$value), () => ref());
      var node_8 = sibling(button, 2);
      {
        var consequent_4 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_9 = first_child(fragment_5);
          ListBoxMenu_default(node_9, {
            get "aria-labelledby"() {
              return id();
            },
            get id() {
              return id();
            },
            children: wrap_snippet(Dropdown, ($$anchor4, $$slotProps2) => {
              var fragment_6 = comment();
              var node_10 = first_child(fragment_6);
              validate_each_keys(items, (item) => item.id);
              each(node_10, 3, items, (item) => item.id, ($$anchor5, item, i) => {
                var fragment_7 = comment();
                var node_11 = first_child(fragment_7);
                const expression_9 = derived_safe_equal(() => strict_equals(selectedId(), get(item).id));
                const expression_10 = derived_safe_equal(() => strict_equals(get(highlightedIndex), get(i)));
                ListBoxMenuItem_default(node_11, {
                  get id() {
                    return get(item).id;
                  },
                  get active() {
                    return get(expression_9);
                  },
                  get highlighted() {
                    return get(expression_10);
                  },
                  get disabled() {
                    return get(item).disabled;
                  },
                  $$events: {
                    click: (e) => {
                      if (get(item).disabled) {
                        e.stopPropagation();
                        return;
                      }
                      selectedId(get(item).id);
                      dispatchSelect();
                      ref().focus();
                    },
                    mouseenter: () => {
                      if (get(item).disabled) return;
                      set(highlightedIndex, get(i));
                    }
                  },
                  children: wrap_snippet(Dropdown, ($$anchor6, $$slotProps3) => {
                    var fragment_8 = comment();
                    var node_12 = first_child(fragment_8);
                    slot(
                      node_12,
                      $$props,
                      "default",
                      {
                        get item() {
                          return get(item);
                        },
                        get index() {
                          return get(i);
                        }
                      },
                      ($$anchor7) => {
                        var text_3 = text();
                        template_effect(($0) => set_text(text_3, $0), [() => itemToString()(get(item))], derived_safe_equal);
                        append($$anchor7, text_3);
                      }
                    );
                    append($$anchor6, fragment_8);
                  }),
                  $$slots: { default: true }
                });
                append($$anchor5, fragment_7);
              });
              append($$anchor4, fragment_6);
            }),
            $$slots: { default: true }
          });
          append($$anchor3, fragment_5);
        };
        if_block(node_8, ($$render) => {
          if (open()) $$render(consequent_4);
        });
      }
      template_effect(() => {
        set_attribute(button, "aria-expanded", open());
        button.disabled = disabled();
        set_attribute(button, "translatewithid", translateWithId());
        set_attribute(button, "id", id());
        toggle_class(button, "bx--list-box__field", true);
      });
      event2("keydown", button, (e) => {
        const { key } = e;
        if (["Enter", "ArrowDown", "ArrowUp"].includes(key)) {
          e.preventDefault();
        }
        if (strict_equals(key, "Enter")) {
          open(!open());
          if (get(highlightedIndex) > -1 && strict_equals(items()[get(highlightedIndex)].id, selectedId(), false)) {
            selectedId(items()[get(highlightedIndex)].id);
            dispatchSelect();
            open(false);
          }
        } else if (strict_equals(key, "Tab")) {
          open(false);
          ref().blur();
        } else if (strict_equals(key, "ArrowDown")) {
          if (!open()) open(true);
          change(1);
        } else if (strict_equals(key, "ArrowUp")) {
          if (!open()) open(true);
          change(-1);
        } else if (strict_equals(key, "Escape")) {
          open(false);
        }
      });
      event2("keyup", button, (e) => {
        const { key } = e;
        if ([" "].includes(key)) {
          e.preventDefault();
        } else {
          return;
        }
        open(!open());
        if (get(highlightedIndex) > -1 && strict_equals(items()[get(highlightedIndex)].id, selectedId(), false)) {
          selectedId(items()[get(highlightedIndex)].id);
          dispatchSelect();
          open(false);
        }
      });
      append($$anchor2, fragment);
    }),
    $$slots: { default: true }
  });
  var node_13 = sibling(node_1, 2);
  {
    var consequent_5 = ($$anchor2) => {
      var div_1 = root_1210();
      toggle_class(div_1, "bx--form__helper-text", true);
      var text_4 = child(div_1, true);
      reset(div_1);
      template_effect(() => {
        toggle_class(div_1, "bx--form__helper-text--disabled", disabled());
        set_text(text_4, helperText());
      });
      append($$anchor2, div_1);
    };
    if_block(node_13, ($$render) => {
      if (!get(inline) && !invalid() && !warn() && helperText()) $$render(consequent_5);
    });
  }
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--dropdown__wrapper", true);
    toggle_class(div, "bx--list-box__wrapper", true);
    toggle_class(div, "bx--dropdown__wrapper--inline", get(inline));
    toggle_class(div, "bx--list-box__wrapper--inline", get(inline));
    toggle_class(div, "bx--dropdown__wrapper--inline--invalid", get(inline) && invalid());
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dropdown = hmr(Dropdown, () => Dropdown[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dropdown[HMR].source;
    set(Dropdown[HMR].source, module.default[HMR].original);
  });
}
var Dropdown_default = Dropdown;
mark_module_end(Dropdown);

// node_modules/carbon-components-svelte/src/Dropdown/DropdownSkeleton.svelte
mark_module_start();
DropdownSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/Dropdown/DropdownSkeleton.svelte";
var root59 = add_locations(template(`<div><div role="button"><span></span></div></div>`), DropdownSkeleton[FILENAME], [
  [8, 0, [[20, 2, [[21, 4]]]]]
]);
function DropdownSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["inline"]);
  push($$props, false, DropdownSkeleton);
  let inline = prop($$props, "inline", 8, false);
  var div = root59();
  let attributes;
  var div_1 = child(div);
  toggle_class(div_1, "bx--list-box__field", true);
  var span = child(div_1);
  toggle_class(span, "bx--list-box__label", true);
  reset(div_1);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--skeleton", true);
    toggle_class(div, "bx--dropdown-v2", true);
    toggle_class(div, "bx--list-box", true);
    toggle_class(div, "bx--form-item", true);
    toggle_class(div, "bx--list-box--inline", inline());
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DropdownSkeleton = hmr(DropdownSkeleton, () => DropdownSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DropdownSkeleton[HMR].source;
    set(DropdownSkeleton[HMR].source, module.default[HMR].original);
  });
}
var DropdownSkeleton_default = DropdownSkeleton;
mark_module_end(DropdownSkeleton);

// node_modules/carbon-components-svelte/src/icons/CheckmarkFilled.svelte
mark_module_start();
CheckmarkFilled[FILENAME] = "node_modules/carbon-components-svelte/src/icons/CheckmarkFilled.svelte";
var root_144 = add_locations(ns_template(`<title> </title>`), CheckmarkFilled[FILENAME], [[24, 13]]);
var root60 = add_locations(ns_template(`<svg><!><path d="M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2ZM14,21.5908l-5-5L10.5906,15,14,18.4092,21.41,11l1.5957,1.5859Z"></path><path fill="none" d="M14 21.591L9 16.591 10.591 15 14 18.409 21.41 11 23.005 12.585 14 21.591z" data-icon-path="inner-path"></path></svg>`), CheckmarkFilled[FILENAME], [[14, 0, [[25, 2], [27, 10]]]]);
function CheckmarkFilled($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, CheckmarkFilled);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root60();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_144();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next(2);
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CheckmarkFilled = hmr(CheckmarkFilled, () => CheckmarkFilled[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CheckmarkFilled[HMR].source;
    set(CheckmarkFilled[HMR].source, module.default[HMR].original);
  });
}
var CheckmarkFilled_default = CheckmarkFilled;
mark_module_end(CheckmarkFilled);

// node_modules/carbon-components-svelte/src/Loading/Loading.svelte
mark_module_start();
Loading[FILENAME] = "node_modules/carbon-components-svelte/src/Loading/Loading.svelte";
var root_219 = add_locations(ns_template(`<circle cx="50%" cy="50%"></circle>`), Loading[FILENAME], [[33, 10]]);
var root_145 = add_locations(template(`<div><div aria-atomic="true"><svg viewBox="0 0 100 100"><title> </title><!><circle cx="50%" cy="50%"></circle></svg></div></div>`), Loading[FILENAME], [
  [
    18,
    2,
    [
      [
        23,
        4,
        [[30, 6, [[31, 8], [39, 8]]]]
      ]
    ]
  ]
]);
var root_46 = add_locations(ns_template(`<circle cx="50%" cy="50%"></circle>`), Loading[FILENAME], [[59, 8]]);
var root_39 = add_locations(template(`<div><svg viewBox="0 0 100 100"><title> </title><!><circle cx="50%" cy="50%"></circle></svg></div>`), Loading[FILENAME], [
  [
    48,
    2,
    [[56, 4, [[57, 6], [65, 6]]]]
  ]
]);
function Loading($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "small",
    "active",
    "withOverlay",
    "description"
  ]);
  push($$props, false, Loading);
  const spinnerRadius = mutable_state();
  let small = prop($$props, "small", 8, false);
  let active = prop($$props, "active", 8, true);
  let withOverlay = prop($$props, "withOverlay", 8, true);
  let description = prop($$props, "description", 8, "loading");
  legacy_pre_effect(() => deep_read_state(small()), () => {
    set(spinnerRadius, small() ? "42" : "44");
  });
  legacy_pre_effect_reset();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var div = root_145();
      let attributes;
      var div_1 = child(div);
      var svg = child(div_1);
      toggle_class(svg, "bx--loading__svg", true);
      var title = child(svg);
      var text2 = child(title, true);
      reset(title);
      var node_1 = sibling(title);
      {
        var consequent = ($$anchor3) => {
          var circle = root_219();
          template_effect(() => {
            set_attribute(circle, "r", get(spinnerRadius));
            toggle_class(circle, "bx--loading__background", true);
          });
          append($$anchor3, circle);
        };
        if_block(node_1, ($$render) => {
          if (small()) $$render(consequent);
        });
      }
      var circle_1 = sibling(node_1);
      reset(svg);
      reset(div_1);
      reset(div);
      template_effect(() => {
        attributes = set_attributes(div, attributes, { ...$$restProps });
        toggle_class(div, "bx--loading-overlay", true);
        toggle_class(div, "bx--loading-overlay--stop", !active());
        set_attribute(div_1, "aria-live", active() ? "assertive" : "off");
        toggle_class(div_1, "bx--loading", true);
        toggle_class(div_1, "bx--loading--small", small());
        toggle_class(div_1, "bx--loading--stop", !active());
        set_text(text2, description());
        set_attribute(circle_1, "r", get(spinnerRadius));
        toggle_class(circle_1, "bx--loading__stroke", true);
      });
      append($$anchor2, div);
    };
    var alternate = ($$anchor2) => {
      var div_2 = root_39();
      let attributes_1;
      var svg_1 = child(div_2);
      toggle_class(svg_1, "bx--loading__svg", true);
      var title_1 = child(svg_1);
      var text_1 = child(title_1, true);
      reset(title_1);
      var node_2 = sibling(title_1);
      {
        var consequent_2 = ($$anchor3) => {
          var circle_2 = root_46();
          template_effect(() => {
            set_attribute(circle_2, "r", get(spinnerRadius));
            toggle_class(circle_2, "bx--loading__background", true);
          });
          append($$anchor3, circle_2);
        };
        if_block(node_2, ($$render) => {
          if (small()) $$render(consequent_2);
        });
      }
      var circle_3 = sibling(node_2);
      reset(svg_1);
      reset(div_2);
      template_effect(() => {
        attributes_1 = set_attributes(div_2, attributes_1, {
          "aria-atomic": "true",
          "aria-live": active() ? "assertive" : "off",
          ...$$restProps
        });
        toggle_class(div_2, "bx--loading", true);
        toggle_class(div_2, "bx--loading--small", small());
        toggle_class(div_2, "bx--loading--stop", !active());
        set_text(text_1, description());
        set_attribute(circle_3, "r", get(spinnerRadius));
        toggle_class(circle_3, "bx--loading__stroke", true);
      });
      append($$anchor2, div_2);
    };
    if_block(node, ($$render) => {
      if (withOverlay()) $$render(consequent_1);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Loading = hmr(Loading, () => Loading[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Loading[HMR].source;
    set(Loading[HMR].source, module.default[HMR].original);
  });
}
var Loading_default = Loading;
mark_module_end(Loading);

// node_modules/carbon-components-svelte/src/FileUploader/Filename.svelte
mark_module_start();
Filename[FILENAME] = "node_modules/carbon-components-svelte/src/FileUploader/Filename.svelte";
var root_220 = add_locations(template(`<!> <button><!></button>`, 1), Filename[FILENAME], [[37, 2]]);
var root61 = add_locations(template(`<!> <!> <!>`, 1), Filename[FILENAME], []);
function Filename($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["status", "iconDescription", "invalid"]);
  push($$props, false, Filename);
  let status = prop($$props, "status", 8, "uploading");
  let iconDescription = prop($$props, "iconDescription", 8, "");
  let invalid = prop($$props, "invalid", 8, false);
  var fragment = root61();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      Loading_default(node_1, spread_props(
        {
          get description() {
            return iconDescription();
          }
        },
        () => $$restProps,
        { small: true, withOverlay: false }
      ));
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (strict_equals(status(), "uploading")) $$render(consequent);
    });
  }
  var node_2 = sibling(node, 2);
  {
    var consequent_2 = ($$anchor2) => {
      var fragment_2 = root_220();
      var node_3 = first_child(fragment_2);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          WarningFilled_default(node_4, { class: "bx--file-invalid" });
          append($$anchor3, fragment_3);
        };
        if_block(node_3, ($$render) => {
          if (invalid()) $$render(consequent_1);
        });
      }
      var button = sibling(node_3, 2);
      let attributes;
      var node_5 = child(button);
      Close_default(node_5, {});
      reset(button);
      template_effect(() => {
        attributes = set_attributes(button, attributes, {
          "aria-label": iconDescription(),
          type: "button",
          tabindex: "0",
          ...$$restProps
        });
        toggle_class(button, "bx--file-close", true);
      });
      event2("click", button, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("keydown", button, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, fragment_2);
    };
    if_block(node_2, ($$render) => {
      if (strict_equals(status(), "edit")) $$render(consequent_2);
    });
  }
  var node_6 = sibling(node_2, 2);
  {
    var consequent_3 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_7 = first_child(fragment_4);
      CheckmarkFilled_default(node_7, spread_props(
        {
          get "aria-label"() {
            return iconDescription();
          },
          get title() {
            return iconDescription();
          },
          class: "bx--file-complete"
        },
        () => $$restProps
      ));
      append($$anchor2, fragment_4);
    };
    if_block(node_6, ($$render) => {
      if (strict_equals(status(), "complete")) $$render(consequent_3);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Filename = hmr(Filename, () => Filename[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Filename[HMR].source;
    set(Filename[HMR].source, module.default[HMR].original);
  });
}
var Filename_default = Filename;
mark_module_end(Filename);

// node_modules/carbon-components-svelte/src/FileUploader/FileUploaderButton.svelte
mark_module_start();
FileUploaderButton[FILENAME] = "node_modules/carbon-components-svelte/src/FileUploader/FileUploaderButton.svelte";
var root62 = add_locations(template(`<label><span><!></span></label> <input>`, 1), FileUploaderButton[FILENAME], [[71, 0, [[95, 2]]], [101, 0]]);
function FileUploaderButton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "accept",
    "files",
    "multiple",
    "disabled",
    "disableLabelChanges",
    "kind",
    "size",
    "labelText",
    "role",
    "tabindex",
    "id",
    "name",
    "ref"
  ]);
  push($$props, false, FileUploaderButton);
  let accept = prop($$props, "accept", 24, () => []);
  let files = prop($$props, "files", 28, () => []);
  let multiple = prop($$props, "multiple", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let disableLabelChanges = prop($$props, "disableLabelChanges", 8, false);
  let kind = prop($$props, "kind", 8, "primary");
  let size = prop($$props, "size", 8, "small");
  let labelText = prop($$props, "labelText", 12, "Add file");
  let role = prop($$props, "role", 8, "button");
  let tabindex = prop($$props, "tabindex", 8, "0");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let name = prop($$props, "name", 8, "");
  let ref = prop($$props, "ref", 12, null);
  const dispatch = createEventDispatcher();
  let initialLabelText = labelText();
  legacy_pre_effect(
    () => (deep_read_state(ref()), deep_read_state(files())),
    () => {
      if (ref() && strict_equals(files().length, 0)) {
        labelText(initialLabelText);
        ref(ref().value = "", true);
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = root62();
  var label = first_child(fragment);
  var span = child(label);
  var node = child(span);
  slot(node, $$props, "labelText", {}, ($$anchor2) => {
    var text2 = text();
    template_effect(() => set_text(text2, labelText()));
    append($$anchor2, text2);
  });
  reset(span);
  reset(label);
  var input = sibling(label, 2);
  remove_input_defaults(input);
  let attributes;
  bind_this(input, ($$value) => ref($$value), () => ref());
  template_effect(() => {
    set_attribute(label, "aria-disabled", disabled());
    set_attribute(label, "for", id());
    set_attribute(label, "tabindex", disabled() ? "-1" : tabindex());
    toggle_class(label, "bx--btn", true);
    toggle_class(label, "bx--btn--disabled", disabled());
    toggle_class(label, "bx--btn--primary", strict_equals(kind(), "primary"));
    toggle_class(label, "bx--btn--secondary", strict_equals(kind(), "secondary"));
    toggle_class(label, "bx--btn--tertiary", strict_equals(kind(), "tertiary"));
    toggle_class(label, "bx--btn--ghost", strict_equals(kind(), "ghost"));
    toggle_class(label, "bx--btn--danger", strict_equals(kind(), "danger"));
    toggle_class(label, "bx--btn--danger-tertiary", strict_equals(kind(), "danger-tertiary"));
    toggle_class(label, "bx--btn--danger-ghost", strict_equals(kind(), "danger-ghost"));
    toggle_class(label, "bx--btn--sm", strict_equals(size(), "small"));
    toggle_class(label, "bx--btn--field", strict_equals(size(), "field"));
    toggle_class(label, "bx--btn--lg", strict_equals(size(), "lg"));
    toggle_class(label, "bx--btn--xl", strict_equals(size(), "xl"));
    set_attribute(span, "role", role());
    attributes = set_attributes(input, attributes, {
      type: "file",
      tabindex: "-1",
      accept: accept(),
      disabled: disabled(),
      id: id(),
      multiple: multiple(),
      name: name(),
      ...$$restProps
    });
    toggle_class(input, "bx--visually-hidden", true);
  });
  event2("keydown", label, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", label, ({ key }) => {
    if (strict_equals(key, " ") || strict_equals(key, "Enter")) {
      ref().click();
    }
  });
  event2("change", input, stopPropagation(({ target }) => {
    files([...target.files]);
    if (files() && !disableLabelChanges()) {
      labelText(files().length > 1 ? `${files().length} files` : files()[0].name);
    }
    dispatch("change", files());
  }));
  event2("click", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", input, ({ target }) => {
    target.value = null;
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileUploaderButton = hmr(FileUploaderButton, () => FileUploaderButton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileUploaderButton[HMR].source;
    set(FileUploaderButton[HMR].source, module.default[HMR].original);
  });
}
var FileUploaderButton_default = FileUploaderButton;
mark_module_end(FileUploaderButton);

// node_modules/carbon-components-svelte/src/FileUploader/FileUploader.svelte
mark_module_start();
FileUploader[FILENAME] = "node_modules/carbon-components-svelte/src/FileUploader/FileUploader.svelte";
var root_146 = add_locations(template(`<p><!></p>`), FileUploader[FILENAME], [[119, 4]]);
var root_310 = add_locations(template(`<p><!></p>`), FileUploader[FILENAME], [[129, 4]]);
var root_55 = add_locations(template(`<span><p> </p> <span><!></span></span>`), FileUploader[FILENAME], [[154, 6, [[155, 8], [156, 8]]]]);
var root63 = add_locations(template(`<div><!> <!> <!> <div></div></div>`), FileUploader[FILENAME], [[110, 0, [[152, 2]]]]);
function FileUploader($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "clearFiles",
    "status",
    "disabled",
    "accept",
    "files",
    "multiple",
    "labelTitle",
    "labelDescription",
    "kind",
    "size",
    "buttonLabel",
    "iconDescription",
    "name"
  ]);
  push($$props, false, FileUploader);
  let status = prop($$props, "status", 8, "uploading");
  let disabled = prop($$props, "disabled", 8, false);
  let accept = prop($$props, "accept", 24, () => []);
  let files = prop($$props, "files", 28, () => []);
  let multiple = prop($$props, "multiple", 8, false);
  const clearFiles = () => {
    files([]);
  };
  let labelTitle = prop($$props, "labelTitle", 8, "");
  let labelDescription = prop($$props, "labelDescription", 8, "");
  let kind = prop($$props, "kind", 8, "primary");
  let size = prop($$props, "size", 8, "small");
  let buttonLabel = prop($$props, "buttonLabel", 8, "");
  let iconDescription = prop($$props, "iconDescription", 8, "Provide icon description");
  let name = prop($$props, "name", 8, "");
  const dispatch = createEventDispatcher();
  let prevFiles = [];
  const getFileId = (file) => file.lastModified + file.name;
  afterUpdate(() => {
    const fileIds = files().map(getFileId);
    const prevFileIds = prevFiles.map(getFileId);
    const addedIds = fileIds.filter((_) => !prevFileIds.includes(_));
    const removedIds = prevFileIds.filter((_) => !fileIds.includes(_));
    if (addedIds.length > 0) {
      dispatch("add", addedIds.map((id) => files().find((file) => strict_equals(id, getFileId(file)))));
    }
    if (removedIds.length > 0) {
      dispatch("remove", removedIds.map((id) => prevFiles.find((file) => strict_equals(id, getFileId(file)))));
    }
    prevFiles = [...files()];
  });
  init();
  var div = root63();
  let attributes;
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var p = root_146();
      toggle_class(p, "bx--file--label", true);
      var node_1 = child(p);
      slot(node_1, $$props, "labelTitle", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, labelTitle()));
        append($$anchor3, text2);
      });
      reset(p);
      template_effect(() => toggle_class(p, "bx--label-description--disabled", disabled()));
      append($$anchor2, p);
    };
    if_block(node, ($$render) => {
      if (labelTitle() || $$slots.labelTitle) $$render(consequent);
    });
  }
  var node_2 = sibling(node, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var p_1 = root_310();
      toggle_class(p_1, "bx--label-description", true);
      var node_3 = child(p_1);
      slot(node_3, $$props, "labelDescription", {}, ($$anchor3) => {
        var text_1 = text();
        template_effect(() => set_text(text_1, labelDescription()));
        append($$anchor3, text_1);
      });
      reset(p_1);
      template_effect(() => toggle_class(p_1, "bx--label-description--disabled", disabled()));
      append($$anchor2, p_1);
    };
    if_block(node_2, ($$render) => {
      if (labelDescription() || $$slots.labelDescription) $$render(consequent_1);
    });
  }
  var node_4 = sibling(node_2, 2);
  FileUploaderButton_default(node_4, {
    get disabled() {
      return disabled();
    },
    disableLabelChanges: true,
    get labelText() {
      return buttonLabel();
    },
    get accept() {
      return accept();
    },
    get name() {
      return name();
    },
    get multiple() {
      return multiple();
    },
    get kind() {
      return kind();
    },
    get size() {
      return size();
    },
    $$events: {
      change: [
        function($$arg) {
          bubble_event.call(this, $$props, $$arg);
        },
        (e) => {
          files(e.detail);
        }
      ]
    }
  });
  var div_1 = sibling(node_4, 2);
  toggle_class(div_1, "bx--file-container", true);
  each(div_1, 5, files, index, ($$anchor2, $$item, i, $$array) => {
    let name2 = () => get($$item).name;
    name2();
    var span = root_55();
    toggle_class(span, "bx--file__selected-file", true);
    var p_2 = child(span);
    toggle_class(p_2, "bx--file-filename", true);
    var text_2 = child(p_2, true);
    reset(p_2);
    var span_1 = sibling(p_2, 2);
    toggle_class(span_1, "bx--file__state-container", true);
    var node_5 = child(span_1);
    Filename_default(node_5, {
      get iconDescription() {
        return iconDescription();
      },
      get status() {
        return status();
      },
      $$events: {
        keydown: [
          function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          },
          ({ key }) => {
            if (strict_equals(key, " ") || strict_equals(key, "Enter")) {
              files(files().filter((_, index2) => strict_equals(index2, i, false)));
            }
          }
        ],
        click: [
          function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          },
          () => {
            files(files().filter((_, index2) => strict_equals(index2, i, false)));
          }
        ]
      }
    });
    reset(span_1);
    reset(span);
    template_effect(() => set_text(text_2, name2()));
    append($$anchor2, span);
  });
  reset(div_1);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--form-item", true);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  bind_prop($$props, "clearFiles", clearFiles);
  return pop({
    get clearFiles() {
      return clearFiles;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  FileUploader = hmr(FileUploader, () => FileUploader[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileUploader[HMR].source;
    set(FileUploader[HMR].source, module.default[HMR].original);
  });
}
var FileUploader_default = FileUploader;
mark_module_end(FileUploader);

// node_modules/carbon-components-svelte/src/FileUploader/FileUploaderItem.svelte
mark_module_start();
FileUploaderItem[FILENAME] = "node_modules/carbon-components-svelte/src/FileUploader/FileUploaderItem.svelte";
var root_221 = add_locations(template(`<p> </p>`), FileUploaderItem[FILENAME], [[75, 8]]);
var root_147 = add_locations(template(`<div><div> </div> <!></div>`), FileUploaderItem[FILENAME], [[72, 4, [[73, 6]]]]);
var root64 = add_locations(template(`<span><p> </p> <span><!></span> <!></span>`), FileUploaderItem[FILENAME], [[44, 0, [[55, 2], [56, 2]]]]);
function FileUploaderItem($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "status",
    "size",
    "iconDescription",
    "invalid",
    "errorSubject",
    "errorBody",
    "id",
    "name"
  ]);
  push($$props, false, FileUploaderItem);
  let status = prop($$props, "status", 8, "uploading");
  let size = prop($$props, "size", 8, "default");
  let iconDescription = prop($$props, "iconDescription", 8, "");
  let invalid = prop($$props, "invalid", 8, false);
  let errorSubject = prop($$props, "errorSubject", 8, "");
  let errorBody = prop($$props, "errorBody", 8, "");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let name = prop($$props, "name", 8, "");
  const dispatch = createEventDispatcher();
  init();
  var span = root64();
  let attributes;
  var p = child(span);
  toggle_class(p, "bx--file-filename", true);
  var text2 = child(p, true);
  reset(p);
  var span_1 = sibling(p, 2);
  toggle_class(span_1, "bx--file__state-container", true);
  var node = child(span_1);
  Filename_default(node, {
    get iconDescription() {
      return iconDescription();
    },
    get status() {
      return status();
    },
    get invalid() {
      return invalid();
    },
    $$events: {
      keydown: ({ key }) => {
        if (strict_equals(key, " ") || strict_equals(key, "Enter")) {
          dispatch("delete", id());
        }
      },
      click: () => {
        dispatch("delete", id());
      }
    }
  });
  reset(span_1);
  var node_1 = sibling(span_1, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var div = root_147();
      toggle_class(div, "bx--form-requirement", true);
      var div_1 = child(div);
      toggle_class(div_1, "bx--form-requirement__title", true);
      var text_1 = child(div_1, true);
      reset(div_1);
      var node_2 = sibling(div_1, 2);
      {
        var consequent = ($$anchor3) => {
          var p_1 = root_221();
          toggle_class(p_1, "bx--form-requirement__supplement", true);
          var text_2 = child(p_1, true);
          reset(p_1);
          template_effect(() => set_text(text_2, errorBody()));
          append($$anchor3, p_1);
        };
        if_block(node_2, ($$render) => {
          if (errorBody()) $$render(consequent);
        });
      }
      reset(div);
      template_effect(() => set_text(text_1, errorSubject()));
      append($$anchor2, div);
    };
    if_block(node_1, ($$render) => {
      if (invalid() && errorSubject()) $$render(consequent_1);
    });
  }
  reset(span);
  template_effect(() => {
    attributes = set_attributes(span, attributes, { id: id(), ...$$restProps });
    toggle_class(span, "bx--file__selected-file", true);
    toggle_class(span, "bx--file__selected-file--invalid", invalid());
    toggle_class(span, "bx--file__selected-file--md", strict_equals(size(), "field"));
    toggle_class(span, "bx--file__selected-file--sm", strict_equals(size(), "small"));
    set_text(text2, name());
  });
  event2("mouseover", span, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", span, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", span, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, span);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileUploaderItem = hmr(FileUploaderItem, () => FileUploaderItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileUploaderItem[HMR].source;
    set(FileUploaderItem[HMR].source, module.default[HMR].original);
  });
}
var FileUploaderItem_default = FileUploaderItem;
mark_module_end(FileUploaderItem);

// node_modules/carbon-components-svelte/src/FileUploader/FileUploaderDropContainer.svelte
mark_module_start();
FileUploaderDropContainer[FILENAME] = "node_modules/carbon-components-svelte/src/FileUploader/FileUploaderDropContainer.svelte";
var root65 = add_locations(template(`<div><label><div><!></div></label> <input type="file" tabindex="-1"></div>`), FileUploaderDropContainer[FILENAME], [
  [
    58,
    0,
    [[87, 2, [[99, 4]]], [109, 2]]
  ]
]);
function FileUploaderDropContainer($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "accept",
    "files",
    "multiple",
    "validateFiles",
    "labelText",
    "role",
    "disabled",
    "tabindex",
    "id",
    "name",
    "ref"
  ]);
  push($$props, false, FileUploaderDropContainer);
  let accept = prop($$props, "accept", 24, () => []);
  let files = prop($$props, "files", 28, () => []);
  let multiple = prop($$props, "multiple", 8, false);
  let validateFiles = prop($$props, "validateFiles", 8, (files2) => files2);
  let labelText = prop($$props, "labelText", 8, "Add file");
  let role = prop($$props, "role", 8, "button");
  let disabled = prop($$props, "disabled", 8, false);
  let tabindex = prop($$props, "tabindex", 8, "0");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let name = prop($$props, "name", 8, "");
  let ref = prop($$props, "ref", 12, null);
  const dispatch = createEventDispatcher();
  let over = mutable_state(false);
  init();
  var div = root65();
  let attributes;
  var label = child(div);
  var div_1 = child(label);
  var node = child(div_1);
  slot(node, $$props, "labelText", {}, ($$anchor2) => {
    var text2 = text();
    template_effect(() => set_text(text2, labelText()));
    append($$anchor2, text2);
  });
  reset(div_1);
  reset(label);
  var input = sibling(label, 2);
  bind_this(input, ($$value) => ref($$value), () => ref());
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--file", true);
    set_attribute(label, "for", id());
    set_attribute(label, "tabindex", tabindex());
    toggle_class(label, "bx--file-browse-btn", true);
    toggle_class(label, "bx--file-browse-btn--disabled", disabled());
    set_attribute(div_1, "role", role());
    toggle_class(div_1, "bx--file__drop-container", true);
    toggle_class(div_1, "bx--file__drop-container--drag-over", get(over));
    set_attribute(input, "id", id());
    input.disabled = disabled();
    set_attribute(input, "accept", accept());
    set_attribute(input, "name", name());
    input.multiple = multiple();
    toggle_class(input, "bx--file-input", true);
  });
  event2("keydown", label, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", label, ({ key }) => {
    if (strict_equals(key, " ") || strict_equals(key, "Enter")) {
      ref().click();
    }
  });
  event2("change", input, ({ target }) => {
    files(validateFiles()([...target.files]));
    dispatch("add", files());
    dispatch("change", files());
  });
  event2("click", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", input, ({ target }) => {
    target.value = null;
  });
  event2("dragover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("dragover", div, preventDefault(stopPropagation(({ dataTransfer }) => {
    if (!disabled()) {
      set(over, true);
      dataTransfer.dropEffect = "copy";
    }
  })));
  event2("dragleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("dragleave", div, preventDefault(stopPropagation(({ dataTransfer }) => {
    if (!disabled()) {
      set(over, false);
      dataTransfer.dropEffect = "move";
    }
  })));
  event2("drop", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("drop", div, preventDefault(stopPropagation(({ dataTransfer }) => {
    if (!disabled()) {
      set(over, false);
      files(validateFiles()([...dataTransfer.files]));
      dispatch("add", files());
      dispatch("change", files());
    }
  })));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileUploaderDropContainer = hmr(FileUploaderDropContainer, () => FileUploaderDropContainer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileUploaderDropContainer[HMR].source;
    set(FileUploaderDropContainer[HMR].source, module.default[HMR].original);
  });
}
var FileUploaderDropContainer_default = FileUploaderDropContainer;
mark_module_end(FileUploaderDropContainer);

// node_modules/carbon-components-svelte/src/FileUploader/FileUploaderSkeleton.svelte
mark_module_start();
FileUploaderSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/FileUploader/FileUploaderSkeleton.svelte";
var root66 = add_locations(template(`<div><!> <!> <!></div>`), FileUploaderSkeleton[FILENAME], [[8, 0]]);
function FileUploaderSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, FileUploaderSkeleton);
  var div = root66();
  let attributes;
  var node = child(div);
  SkeletonText_default(node, { heading: true, width: "100px" });
  var node_1 = sibling(node, 2);
  SkeletonText_default(node_1, {
    width: "225px",
    class: "bx--label-description"
  });
  var node_2 = sibling(node_1, 2);
  ButtonSkeleton_default(node_2, {});
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--form-item", true);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileUploaderSkeleton = hmr(FileUploaderSkeleton, () => FileUploaderSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileUploaderSkeleton[HMR].source;
    set(FileUploaderSkeleton[HMR].source, module.default[HMR].original);
  });
}
var FileUploaderSkeleton_default = FileUploaderSkeleton;
mark_module_end(FileUploaderSkeleton);

// node_modules/carbon-components-svelte/src/Form/Form.svelte
mark_module_start();
Form[FILENAME] = "node_modules/carbon-components-svelte/src/Form/Form.svelte";
var root67 = add_locations(template(`<form><!></form>`), Form[FILENAME], [[8, 0]]);
function Form($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["ref"]);
  push($$props, false, Form);
  let ref = prop($$props, "ref", 12, null);
  var form = root67();
  let attributes;
  var node = child(form);
  slot(node, $$props, "default", {}, null);
  reset(form);
  bind_this(form, ($$value) => ref($$value), () => ref());
  template_effect(() => {
    attributes = set_attributes(form, attributes, { ...$$restProps });
    toggle_class(form, "bx--form", true);
  });
  event2("click", form, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", form, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", form, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", form, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", form, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("submit", form, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, form);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Form = hmr(Form, () => Form[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Form[HMR].source;
    set(Form[HMR].source, module.default[HMR].original);
  });
}
var Form_default = Form;
mark_module_end(Form);

// node_modules/carbon-components-svelte/src/FluidForm/FluidForm.svelte
mark_module_start();
FluidForm[FILENAME] = "node_modules/carbon-components-svelte/src/FluidForm/FluidForm.svelte";
function FluidForm($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, FluidForm);
  setContext("Form", { isFluid: true });
  init();
  var fragment = comment();
  var node = first_child(fragment);
  Form_default(node, spread_props(() => $$restProps, {
    get class() {
      return `bx--form--fluid ${$$restProps.class ?? ""}`;
    },
    $$events: {
      click($$arg) {
        bubble_event.call(this, $$props, $$arg);
      },
      keydown($$arg) {
        bubble_event.call(this, $$props, $$arg);
      },
      mouseover($$arg) {
        bubble_event.call(this, $$props, $$arg);
      },
      mouseenter($$arg) {
        bubble_event.call(this, $$props, $$arg);
      },
      mouseleave($$arg) {
        bubble_event.call(this, $$props, $$arg);
      },
      submit($$arg) {
        bubble_event.call(this, $$props, $$arg);
      }
    },
    children: wrap_snippet(FluidForm, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FluidForm = hmr(FluidForm, () => FluidForm[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FluidForm[HMR].source;
    set(FluidForm[HMR].source, module.default[HMR].original);
  });
}
var FluidForm_default = FluidForm;
mark_module_end(FluidForm);

// node_modules/carbon-components-svelte/src/FormGroup/FormGroup.svelte
mark_module_start();
FormGroup[FILENAME] = "node_modules/carbon-components-svelte/src/FormGroup/FormGroup.svelte";
var root_148 = add_locations(template(`<legend> </legend>`), FormGroup[FILENAME], [[35, 4]]);
var root_222 = add_locations(template(`<div> </div>`), FormGroup[FILENAME], [[42, 4]]);
var root68 = add_locations(template(`<fieldset><!> <!> <!></fieldset>`), FormGroup[FILENAME], [[23, 0]]);
function FormGroup($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "noMargin",
    "invalid",
    "message",
    "messageText",
    "legendText",
    "legendId"
  ]);
  push($$props, false, FormGroup);
  let noMargin = prop($$props, "noMargin", 8, false);
  let invalid = prop($$props, "invalid", 8, false);
  let message = prop($$props, "message", 8, false);
  let messageText = prop($$props, "messageText", 8, "");
  let legendText = prop($$props, "legendText", 8, "");
  let legendId = prop($$props, "legendId", 8, "");
  init();
  var fieldset = root68();
  let attributes;
  var node = child(fieldset);
  {
    var consequent = ($$anchor2) => {
      var legend = root_148();
      var text2 = child(legend, true);
      reset(legend);
      template_effect(() => {
        set_attribute(legend, "id", legendId() || $$restProps["aria-labelledby"]);
        toggle_class(legend, "bx--label", true);
        set_text(text2, legendText());
      });
      append($$anchor2, legend);
    };
    if_block(node, ($$render) => {
      if (legendText()) $$render(consequent);
    });
  }
  var node_1 = sibling(node, 2);
  slot(node_1, $$props, "default", {}, null);
  var node_2 = sibling(node_1, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var div = root_222();
      toggle_class(div, "bx--form__requirement", true);
      var text_1 = child(div, true);
      reset(div);
      template_effect(() => set_text(text_1, messageText()));
      append($$anchor2, div);
    };
    if_block(node_2, ($$render) => {
      if (message()) $$render(consequent_1);
    });
  }
  reset(fieldset);
  template_effect(() => {
    attributes = set_attributes(fieldset, attributes, {
      "data-invalid": invalid() || void 0,
      "aria-labelledby": $$restProps["aria-labelledby"] || legendId(),
      ...$$restProps
    });
    toggle_class(fieldset, "bx--fieldset", true);
    toggle_class(fieldset, "bx--fieldset--no-margin", noMargin());
  });
  event2("click", fieldset, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", fieldset, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", fieldset, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", fieldset, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, fieldset);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FormGroup = hmr(FormGroup, () => FormGroup[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FormGroup[HMR].source;
    set(FormGroup[HMR].source, module.default[HMR].original);
  });
}
var FormGroup_default = FormGroup;
mark_module_end(FormGroup);

// node_modules/carbon-components-svelte/src/FormItem/FormItem.svelte
mark_module_start();
FormItem[FILENAME] = "node_modules/carbon-components-svelte/src/FormItem/FormItem.svelte";
var root69 = add_locations(template(`<div><!></div>`), FormItem[FILENAME], [[3, 0]]);
function FormItem($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, FormItem);
  var div = root69();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--form-item", true);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FormItem = hmr(FormItem, () => FormItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FormItem[HMR].source;
    set(FormItem[HMR].source, module.default[HMR].original);
  });
}
var FormItem_default = FormItem;
mark_module_end(FormItem);

// node_modules/carbon-components-svelte/src/FormLabel/FormLabel.svelte
mark_module_start();
FormLabel[FILENAME] = "node_modules/carbon-components-svelte/src/FormLabel/FormLabel.svelte";
var root70 = add_locations(template(`<label><!></label>`), FormLabel[FILENAME], [[8, 0]]);
function FormLabel($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["id"]);
  push($$props, false, FormLabel);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  init();
  var label = root70();
  let attributes;
  var node = child(label);
  slot(node, $$props, "default", {}, null);
  reset(label);
  template_effect(() => {
    attributes = set_attributes(label, attributes, { for: id(), ...$$restProps });
    toggle_class(label, "bx--label", true);
  });
  event2("click", label, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", label, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", label, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", label, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, label);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FormLabel = hmr(FormLabel, () => FormLabel[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FormLabel[HMR].source;
    set(FormLabel[HMR].source, module.default[HMR].original);
  });
}
var FormLabel_default = FormLabel;
mark_module_end(FormLabel);

// node_modules/carbon-components-svelte/src/Grid/Grid.svelte
mark_module_start();
Grid[FILENAME] = "node_modules/carbon-components-svelte/src/Grid/Grid.svelte";
var root_223 = add_locations(template(`<div><!></div>`), Grid[FILENAME], [[55, 2]]);
function Grid($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "as",
    "condensed",
    "narrow",
    "fullWidth",
    "noGutter",
    "noGutterLeft",
    "noGutterRight",
    "padding"
  ]);
  push($$props, false, Grid);
  const props = mutable_state();
  let as = prop($$props, "as", 8, false);
  let condensed = prop($$props, "condensed", 8, false);
  let narrow = prop($$props, "narrow", 8, false);
  let fullWidth = prop($$props, "fullWidth", 8, false);
  let noGutter = prop($$props, "noGutter", 8, false);
  let noGutterLeft = prop($$props, "noGutterLeft", 8, false);
  let noGutterRight = prop($$props, "noGutterRight", 8, false);
  let padding = prop($$props, "padding", 8, false);
  legacy_pre_effect(
    () => (deep_read_state($$restProps), deep_read_state(condensed()), deep_read_state(narrow()), deep_read_state(fullWidth()), deep_read_state(noGutter()), deep_read_state(noGutterLeft()), deep_read_state(noGutterRight()), deep_read_state(padding())),
    () => {
      set(props, {
        ...$$restProps,
        class: [
          $$restProps.class,
          "bx--grid",
          condensed() && "bx--grid--condensed",
          narrow() && "bx--grid--narrow",
          fullWidth() && "bx--grid--full-width",
          noGutter() && "bx--no-gutter",
          noGutterLeft() && "bx--no-gutter--left",
          noGutterRight() && "bx--no-gutter--right",
          padding() && "bx--row-padding"
        ].filter(Boolean).join(" ")
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        $$props,
        "default",
        {
          get props() {
            return get(props);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_223();
      let attributes;
      var node_2 = child(div);
      slot(node_2, $$props, "default", {}, null);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(props) }));
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if (as()) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Grid = hmr(Grid, () => Grid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Grid[HMR].source;
    set(Grid[HMR].source, module.default[HMR].original);
  });
}
var Grid_default = Grid;
mark_module_end(Grid);

// node_modules/carbon-components-svelte/src/Grid/Row.svelte
mark_module_start();
Row[FILENAME] = "node_modules/carbon-components-svelte/src/Grid/Row.svelte";
var root_224 = add_locations(template(`<div><!></div>`), Row[FILENAME], [[51, 2]]);
function Row($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "as",
    "condensed",
    "narrow",
    "noGutter",
    "noGutterLeft",
    "noGutterRight",
    "padding"
  ]);
  push($$props, false, Row);
  const props = mutable_state();
  let as = prop($$props, "as", 8, false);
  let condensed = prop($$props, "condensed", 8, false);
  let narrow = prop($$props, "narrow", 8, false);
  let noGutter = prop($$props, "noGutter", 8, false);
  let noGutterLeft = prop($$props, "noGutterLeft", 8, false);
  let noGutterRight = prop($$props, "noGutterRight", 8, false);
  let padding = prop($$props, "padding", 8, false);
  legacy_pre_effect(
    () => (deep_read_state($$restProps), deep_read_state(condensed()), deep_read_state(narrow()), deep_read_state(noGutter()), deep_read_state(noGutterLeft()), deep_read_state(noGutterRight()), deep_read_state(padding())),
    () => {
      set(props, {
        ...$$restProps,
        class: [
          $$restProps.class,
          "bx--row",
          condensed() && "bx--row--condensed",
          narrow() && "bx--row--narrow",
          noGutter() && "bx--no-gutter",
          noGutterLeft() && "bx--no-gutter--left",
          noGutterRight() && "bx--no-gutter--right",
          padding() && "bx--row-padding"
        ].filter(Boolean).join(" ")
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        $$props,
        "default",
        {
          get props() {
            return get(props);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_224();
      let attributes;
      var node_2 = child(div);
      slot(node_2, $$props, "default", {}, null);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(props) }));
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if (as()) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Row = hmr(Row, () => Row[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Row[HMR].source;
    set(Row[HMR].source, module.default[HMR].original);
  });
}
var Row_default = Row;
mark_module_end(Row);

// node_modules/carbon-components-svelte/src/Grid/Column.svelte
mark_module_start();
Column[FILENAME] = "node_modules/carbon-components-svelte/src/Grid/Column.svelte";
var root_225 = add_locations(template(`<div><!></div>`), Column[FILENAME], [[116, 2]]);
function Column($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "as",
    "noGutter",
    "noGutterLeft",
    "noGutterRight",
    "padding",
    "aspectRatio",
    "sm",
    "md",
    "lg",
    "xlg",
    "max"
  ]);
  push($$props, false, Column);
  const columnClass = mutable_state();
  const props = mutable_state();
  let as = prop($$props, "as", 8, false);
  let noGutter = prop($$props, "noGutter", 8, false);
  let noGutterLeft = prop($$props, "noGutterLeft", 8, false);
  let noGutterRight = prop($$props, "noGutterRight", 8, false);
  let padding = prop($$props, "padding", 8, false);
  let aspectRatio = prop($$props, "aspectRatio", 8, void 0);
  let sm = prop($$props, "sm", 8, void 0);
  let md = prop($$props, "md", 8, void 0);
  let lg = prop($$props, "lg", 8, void 0);
  let xlg = prop($$props, "xlg", 8, void 0);
  let max = prop($$props, "max", 8, void 0);
  const breakpoints2 = ["sm", "md", "lg", "xlg", "max"];
  legacy_pre_effect(
    () => (deep_read_state(sm()), deep_read_state(md()), deep_read_state(lg()), deep_read_state(xlg()), deep_read_state(max())),
    () => {
      set(columnClass, [
        sm(),
        md(),
        lg(),
        xlg(),
        max()
      ].map((breakpoint, i) => {
        const name = breakpoints2[i];
        if (strict_equals(breakpoint, true)) {
          return `bx--col-${name}`;
        } else if (strict_equals(typeof breakpoint, "number")) {
          return `bx--col-${name}-${breakpoint}`;
        } else if (strict_equals(typeof breakpoint, "object")) {
          let bp = [];
          if (strict_equals(typeof breakpoint.span, "number")) {
            bp = [...bp, `bx--col-${name}-${breakpoint.span}`];
          } else if (strict_equals(breakpoint.span, true)) {
            bp = [...bp, `bx--col-${name}`];
          }
          if (strict_equals(typeof breakpoint.offset, "number")) {
            bp = [
              ...bp,
              `bx--offset-${name}-${breakpoint.offset}`
            ];
          }
          return bp.join(" ");
        }
      }).filter(Boolean).join(" "));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state($$restProps), get(columnClass), deep_read_state(noGutter()), deep_read_state(noGutterLeft()), deep_read_state(noGutterRight()), deep_read_state(aspectRatio()), deep_read_state(padding())),
    () => {
      set(props, {
        ...$$restProps,
        class: [
          $$restProps.class,
          get(columnClass),
          !get(columnClass) && "bx--col",
          noGutter() && "bx--no-gutter",
          noGutterLeft() && "bx--no-gutter--left",
          noGutterRight() && "bx--no-gutter--right",
          aspectRatio() && `bx--aspect-ratio bx--aspect-ratio--${aspectRatio()}`,
          padding() && "bx--col-padding"
        ].filter(Boolean).join(" ")
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        $$props,
        "default",
        {
          get props() {
            return get(props);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_225();
      let attributes;
      var node_2 = child(div);
      slot(node_2, $$props, "default", {}, null);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(props) }));
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if (as()) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Column = hmr(Column, () => Column[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Column[HMR].source;
    set(Column[HMR].source, module.default[HMR].original);
  });
}
var Column_default = Column;
mark_module_end(Column);

// node_modules/carbon-components-svelte/src/ImageLoader/ImageLoader.svelte
mark_module_start();
ImageLoader[FILENAME] = "node_modules/carbon-components-svelte/src/ImageLoader/ImageLoader.svelte";
var root_47 = add_locations(template(`<img>`), ImageLoader[FILENAME], [[85, 6]]);
var root_149 = add_locations(template(`<!> <!> <!>`, 1), ImageLoader[FILENAME], []);
var root_103 = add_locations(template(`<img>`), ImageLoader[FILENAME], [[104, 8]]);
var root_75 = add_locations(template(`<!> <!> <!>`, 1), ImageLoader[FILENAME], []);
function ImageLoader($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "loadImage",
    "src",
    "alt",
    "ratio",
    "loading",
    "loaded",
    "error",
    "fadeIn"
  ]);
  push($$props, false, ImageLoader);
  let src = prop($$props, "src", 8, "");
  let alt = prop($$props, "alt", 8, "");
  let ratio = prop($$props, "ratio", 8, void 0);
  let loading = prop($$props, "loading", 12, false);
  let loaded = prop($$props, "loaded", 12, false);
  let error = prop($$props, "error", 12, false);
  let fadeIn = prop($$props, "fadeIn", 8, false);
  const loadImage = (url) => {
    if (equals(image, null, false)) image = null;
    loaded(false);
    error(false);
    image = new Image();
    image.src = url || src();
    image.onload = () => loaded(true);
    image.onerror = () => error(true);
  };
  const dispatch = createEventDispatcher();
  const fast02 = 110;
  let image = null;
  onMount(() => {
    return () => image = null;
  });
  legacy_pre_effect(
    () => (deep_read_state(loaded()), deep_read_state(error())),
    () => {
      loading(!loaded() && !error());
    }
  );
  legacy_pre_effect(() => deep_read_state(src()), () => {
    if (src() && strict_equals(typeof window, "undefined", false)) loadImage();
  });
  legacy_pre_effect(() => deep_read_state(loaded()), () => {
    if (loaded()) dispatch("load");
  });
  legacy_pre_effect(() => deep_read_state(error()), () => {
    if (error()) dispatch("error");
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_3 = ($$anchor2) => {
      var fragment_1 = root_149();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          slot(node_2, $$props, "loading", {}, null);
          append($$anchor3, fragment_2);
        };
        if_block(node_1, ($$render) => {
          if (loading()) $$render(consequent);
        });
      }
      var node_3 = sibling(node_1, 2);
      key_block(node_3, src, ($$anchor3) => {
        var fragment_3 = comment();
        var node_4 = first_child(fragment_3);
        {
          var consequent_1 = ($$anchor4) => {
            var img = root_47();
            let attributes;
            template_effect(() => {
              attributes = set_attributes(img, attributes, {
                ...$$restProps,
                src: src(),
                alt: alt()
              });
              set_style(img, "width", "100%");
            });
            handle_lazy_img(img);
            replay_events(img);
            transition(3, img, () => fade, () => ({ duration: fadeIn() ? fast02 : 0 }));
            append($$anchor4, img);
          };
          if_block(node_4, ($$render) => {
            if (loaded()) $$render(consequent_1);
          });
        }
        append($$anchor3, fragment_3);
      });
      var node_5 = sibling(node_3, 2);
      {
        var consequent_2 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_6 = first_child(fragment_4);
          slot(node_6, $$props, "error", {}, null);
          append($$anchor3, fragment_4);
        };
        if_block(node_5, ($$render) => {
          if (error()) $$render(consequent_2);
        });
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_5 = comment();
      var node_7 = first_child(fragment_5);
      AspectRatio_default(node_7, {
        get ratio() {
          return ratio();
        },
        children: wrap_snippet(ImageLoader, ($$anchor3, $$slotProps) => {
          var fragment_6 = root_75();
          var node_8 = first_child(fragment_6);
          {
            var consequent_4 = ($$anchor4) => {
              var fragment_7 = comment();
              var node_9 = first_child(fragment_7);
              slot(node_9, $$props, "loading", {}, null);
              append($$anchor4, fragment_7);
            };
            if_block(node_8, ($$render) => {
              if (loading()) $$render(consequent_4);
            });
          }
          var node_10 = sibling(node_8, 2);
          key_block(node_10, src, ($$anchor4) => {
            var fragment_8 = comment();
            var node_11 = first_child(fragment_8);
            {
              var consequent_5 = ($$anchor5) => {
                var img_1 = root_103();
                let attributes_1;
                template_effect(() => {
                  attributes_1 = set_attributes(img_1, attributes_1, {
                    ...$$restProps,
                    src: src(),
                    alt: alt()
                  });
                  set_style(img_1, "width", "100%");
                });
                handle_lazy_img(img_1);
                replay_events(img_1);
                transition(3, img_1, () => fade, () => ({ duration: fadeIn() ? fast02 : 0 }));
                append($$anchor5, img_1);
              };
              if_block(node_11, ($$render) => {
                if (loaded()) $$render(consequent_5);
              });
            }
            append($$anchor4, fragment_8);
          });
          var node_12 = sibling(node_10, 2);
          {
            var consequent_6 = ($$anchor4) => {
              var fragment_9 = comment();
              var node_13 = first_child(fragment_9);
              slot(node_13, $$props, "error", {}, null);
              append($$anchor4, fragment_9);
            };
            if_block(node_12, ($$render) => {
              if (error()) $$render(consequent_6);
            });
          }
          append($$anchor3, fragment_6);
        }),
        $$slots: { default: true }
      });
      append($$anchor2, fragment_5);
    };
    if_block(node, ($$render) => {
      if (strict_equals(ratio(), void 0)) $$render(consequent_3);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  bind_prop($$props, "loadImage", loadImage);
  return pop({
    get loadImage() {
      return loadImage;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  ImageLoader = hmr(ImageLoader, () => ImageLoader[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ImageLoader[HMR].source;
    set(ImageLoader[HMR].source, module.default[HMR].original);
  });
}
var ImageLoader_default = ImageLoader;
mark_module_end(ImageLoader);

// node_modules/carbon-components-svelte/src/icons/ErrorFilled.svelte
mark_module_start();
ErrorFilled[FILENAME] = "node_modules/carbon-components-svelte/src/icons/ErrorFilled.svelte";
var root_150 = add_locations(ns_template(`<title> </title>`), ErrorFilled[FILENAME], [[24, 13]]);
var root71 = add_locations(ns_template(`<svg><!><path fill="none" d="M14.9 7.2H17.1V24.799H14.9z" data-icon-path="inner-path" transform="rotate(-45 16 16)"></path><path d="M16,2A13.914,13.914,0,0,0,2,16,13.914,13.914,0,0,0,16,30,13.914,13.914,0,0,0,30,16,13.914,13.914,0,0,0,16,2Zm5.4449,21L9,10.5557,10.5557,9,23,21.4448Z"></path></svg>`), ErrorFilled[FILENAME], [[14, 0, [[25, 2], [29, 41]]]]);
function ErrorFilled($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, ErrorFilled);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root71();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_150();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next(2);
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ErrorFilled = hmr(ErrorFilled, () => ErrorFilled[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ErrorFilled[HMR].source;
    set(ErrorFilled[HMR].source, module.default[HMR].original);
  });
}
var ErrorFilled_default = ErrorFilled;
mark_module_end(ErrorFilled);

// node_modules/carbon-components-svelte/src/InlineLoading/InlineLoading.svelte
mark_module_start();
InlineLoading[FILENAME] = "node_modules/carbon-components-svelte/src/InlineLoading/InlineLoading.svelte";
var root_66 = add_locations(template(`<div> </div>`), InlineLoading[FILENAME], [[80, 4]]);
var root72 = add_locations(template(`<div><div><!></div> <!></div>`), InlineLoading[FILENAME], [[50, 0, [[59, 2]]]]);
function InlineLoading($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "status",
    "description",
    "iconDescription",
    "successDelay"
  ]);
  push($$props, false, InlineLoading);
  let status = prop($$props, "status", 8, "active");
  let description = prop($$props, "description", 8, void 0);
  let iconDescription = prop($$props, "iconDescription", 8, void 0);
  let successDelay = prop($$props, "successDelay", 8, 1500);
  const dispatch = createEventDispatcher();
  let timeout = void 0;
  onMount(() => {
    return () => {
      clearTimeout(timeout);
    };
  });
  afterUpdate(() => {
    if (strict_equals(status(), "finished")) {
      timeout = setTimeout(
        () => {
          dispatch("success");
        },
        successDelay()
      );
    }
  });
  init();
  var div = root72();
  let attributes;
  var div_1 = child(div);
  toggle_class(div_1, "bx--inline-loading__animation", true);
  var node = child(div_1);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      const expression = derived_safe_equal(() => iconDescription() || status());
      ErrorFilled_default(node_1, {
        class: "bx--inline-loading--error",
        get title() {
          return get(expression);
        }
      });
      append($$anchor2, fragment);
    };
    var alternate_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          const expression_1 = derived_safe_equal(() => iconDescription() || status());
          CheckmarkFilled_default(node_3, {
            class: "bx--inline-loading__checkmark-container",
            get title() {
              return get(expression_1);
            }
          });
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          {
            var consequent_2 = ($$anchor4) => {
              var fragment_4 = comment();
              var node_5 = first_child(fragment_4);
              const expression_2 = derived_safe_equal(() => strict_equals(status(), "active"));
              Loading_default(node_5, {
                small: true,
                get description() {
                  return iconDescription();
                },
                withOverlay: false,
                get active() {
                  return get(expression_2);
                }
              });
              append($$anchor4, fragment_4);
            };
            if_block(
              node_4,
              ($$render) => {
                if (strict_equals(status(), "inactive") || strict_equals(status(), "active")) $$render(consequent_2);
              },
              true
            );
          }
          append($$anchor3, fragment_3);
        };
        if_block(
          node_2,
          ($$render) => {
            if (strict_equals(status(), "finished")) $$render(consequent_1);
            else $$render(alternate, false);
          },
          true
        );
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (strict_equals(status(), "error")) $$render(consequent);
      else $$render(alternate_1, false);
    });
  }
  reset(div_1);
  var node_6 = sibling(div_1, 2);
  {
    var consequent_3 = ($$anchor2) => {
      var div_2 = root_66();
      toggle_class(div_2, "bx--inline-loading__text", true);
      var text2 = child(div_2, true);
      reset(div_2);
      template_effect(() => set_text(text2, description()));
      append($$anchor2, div_2);
    };
    if_block(node_6, ($$render) => {
      if (description()) $$render(consequent_3);
    });
  }
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { "aria-live": "assertive", ...$$restProps });
    toggle_class(div, "bx--inline-loading", true);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InlineLoading = hmr(InlineLoading, () => InlineLoading[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InlineLoading[HMR].source;
    set(InlineLoading[HMR].source, module.default[HMR].original);
  });
}
var InlineLoading_default = InlineLoading;
mark_module_end(InlineLoading);

// node_modules/carbon-components-svelte/src/icons/Launch.svelte
mark_module_start();
Launch[FILENAME] = "node_modules/carbon-components-svelte/src/icons/Launch.svelte";
var root_151 = add_locations(ns_template(`<title> </title>`), Launch[FILENAME], [[24, 13]]);
var root73 = add_locations(ns_template(`<svg><!><path d="M26,28H6a2.0027,2.0027,0,0,1-2-2V6A2.0027,2.0027,0,0,1,6,4H16V6H6V26H26V16h2V26A2.0027,2.0027,0,0,1,26,28Z"></path><path d="M20 2L20 4 26.586 4 18 12.586 19.414 14 28 5.414 28 12 30 12 30 2 20 2z"></path></svg>`), Launch[FILENAME], [[14, 0, [[25, 2], [27, 10]]]]);
function Launch($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, Launch);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root73();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_151();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next(2);
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Launch = hmr(Launch, () => Launch[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Launch[HMR].source;
    set(Launch[HMR].source, module.default[HMR].original);
  });
}
var Launch_default = Launch;
mark_module_end(Launch);

// node_modules/carbon-components-svelte/src/Link/OutboundLink.svelte
mark_module_start();
OutboundLink[FILENAME] = "node_modules/carbon-components-svelte/src/Link/OutboundLink.svelte";
function OutboundLink($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, OutboundLink);
  var fragment = comment();
  var node = first_child(fragment);
  Link_default(node, spread_props(() => $$restProps, {
    target: "_blank",
    icon: Launch_default,
    $$events: {
      click($$arg) {
        bubble_event.call(this, $$props, $$arg);
      },
      mouseover($$arg) {
        bubble_event.call(this, $$props, $$arg);
      },
      mouseenter($$arg) {
        bubble_event.call(this, $$props, $$arg);
      },
      mouseleave($$arg) {
        bubble_event.call(this, $$props, $$arg);
      }
    },
    children: wrap_snippet(OutboundLink, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  OutboundLink = hmr(OutboundLink, () => OutboundLink[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OutboundLink[HMR].source;
    set(OutboundLink[HMR].source, module.default[HMR].original);
  });
}
var OutboundLink_default = OutboundLink;
mark_module_end(OutboundLink);

// node_modules/carbon-components-svelte/src/ListItem/ListItem.svelte
mark_module_start();
ListItem[FILENAME] = "node_modules/carbon-components-svelte/src/ListItem/ListItem.svelte";
var root74 = add_locations(template(`<li><!></li>`), ListItem[FILENAME], [[3, 0]]);
function ListItem($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, ListItem);
  var li = root74();
  let attributes;
  var node = child(li);
  slot(node, $$props, "default", {}, null);
  reset(li);
  template_effect(() => {
    attributes = set_attributes(li, attributes, { ...$$restProps });
    toggle_class(li, "bx--list__item", true);
  });
  event2("click", li, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", li, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", li, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", li, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, li);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ListItem = hmr(ListItem, () => ListItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ListItem[HMR].source;
    set(ListItem[HMR].source, module.default[HMR].original);
  });
}
var ListItem_default = ListItem;
mark_module_end(ListItem);

// node_modules/carbon-components-svelte/src/LocalStorage/LocalStorage.svelte
mark_module_start();
LocalStorage[FILENAME] = "node_modules/carbon-components-svelte/src/LocalStorage/LocalStorage.svelte";
function LocalStorage($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, LocalStorage);
  let key = prop($$props, "key", 8, "local-storage-key");
  let value = prop($$props, "value", 12, "");
  function clearItem() {
    localStorage.removeItem(key());
  }
  function clearAll() {
    localStorage.clear();
  }
  const dispatch = createEventDispatcher();
  let prevValue = value();
  function setItem() {
    if (strict_equals(typeof value(), "object")) {
      localStorage.setItem(key(), JSON.stringify(value()));
    } else {
      localStorage.setItem(key(), value());
    }
  }
  onMount(() => {
    const item = localStorage.getItem(key());
    if (equals(item, null, false)) {
      try {
        value(JSON.parse(item));
      } catch (e) {
        value(item);
      }
    } else {
      setItem(value());
      dispatch("save");
    }
  });
  afterUpdate(() => {
    if (strict_equals(prevValue, value(), false)) {
      setItem(value());
      dispatch("update", { prevValue, value: value() });
    }
    prevValue = value();
  });
  init();
  bind_prop($$props, "clearItem", clearItem);
  bind_prop($$props, "clearAll", clearAll);
  return pop({
    get clearItem() {
      return clearItem;
    },
    get clearAll() {
      return clearAll;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  LocalStorage = hmr(LocalStorage, () => LocalStorage[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LocalStorage[HMR].source;
    set(LocalStorage[HMR].source, module.default[HMR].original);
  });
}
var LocalStorage_default = LocalStorage;
mark_module_end(LocalStorage);

// node_modules/carbon-components-svelte/src/MultiSelect/MultiSelect.svelte
mark_module_start();
MultiSelect[FILENAME] = "node_modules/carbon-components-svelte/src/MultiSelect/MultiSelect.svelte";
var root_153 = add_locations(template(`<label><!></label>`), MultiSelect[FILENAME], [[297, 4]]);
var root_83 = add_locations(template(`<input> <!> <!> <!>`, 1), MultiSelect[FILENAME], [[408, 8]]);
var root_1111 = add_locations(template(`<span> </span> <!>`, 1), MultiSelect[FILENAME], [[482, 8]]);
var root_67 = add_locations(template(`<!> <!> <!>`, 1), MultiSelect[FILENAME], []);
var root_311 = add_locations(template(`<!> <!> <!> <div><!></div>`, 1), MultiSelect[FILENAME], [[486, 4]]);
var root_172 = add_locations(template(`<div> </div>`), MultiSelect[FILENAME], [[539, 4]]);
var root75 = add_locations(template(`<div><!> <!> <!></div>`), MultiSelect[FILENAME], [[288, 0]]);
function MultiSelect($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "items",
    "itemToString",
    "itemToInput",
    "selectedIds",
    "value",
    "size",
    "type",
    "direction",
    "selectionFeedback",
    "disabled",
    "filterable",
    "filterItem",
    "open",
    "light",
    "locale",
    "placeholder",
    "sortItem",
    "translateWithId",
    "translateWithIdSelection",
    "titleText",
    "useTitleInItem",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "helperText",
    "label",
    "hideLabel",
    "id",
    "name",
    "inputRef",
    "multiSelectRef",
    "fieldRef",
    "selectionRef",
    "highlightedId"
  ]);
  push($$props, false, MultiSelect);
  const menuId = mutable_state();
  const inline = mutable_state();
  const ariaLabel = mutable_state();
  const sortedItems = mutable_state();
  const checked = mutable_state();
  const unchecked = mutable_state();
  const filteredItems = mutable_state();
  let items = prop($$props, "items", 28, () => []);
  let itemToString = prop($$props, "itemToString", 8, (item) => item.text || item.id);
  let itemToInput = prop($$props, "itemToInput", 8, (item) => {
  });
  let selectedIds = prop($$props, "selectedIds", 28, () => []);
  let value = prop($$props, "value", 12, "");
  let size = prop($$props, "size", 8, void 0);
  let type = prop($$props, "type", 8, "default");
  let direction = prop($$props, "direction", 8, "bottom");
  let selectionFeedback = prop($$props, "selectionFeedback", 8, "top-after-reopen");
  let disabled = prop($$props, "disabled", 8, false);
  let filterable = prop($$props, "filterable", 8, false);
  let filterItem = prop($$props, "filterItem", 8, (item, value2) => item.text.toLowerCase().includes(value2.trim().toLowerCase()));
  let open = prop($$props, "open", 12, false);
  let light = prop($$props, "light", 8, false);
  let locale = prop($$props, "locale", 8, "en");
  let placeholder = prop($$props, "placeholder", 8, "");
  let sortItem = prop($$props, "sortItem", 8, (a, b) => a.text.localeCompare(b.text, locale(), { numeric: true }));
  let translateWithId = prop($$props, "translateWithId", 8, void 0);
  let translateWithIdSelection = prop($$props, "translateWithIdSelection", 8, void 0);
  let titleText = prop($$props, "titleText", 8, "");
  let useTitleInItem = prop($$props, "useTitleInItem", 8, false);
  let invalid = prop($$props, "invalid", 8, false);
  let invalidText = prop($$props, "invalidText", 8, "");
  let warn = prop($$props, "warn", 8, false);
  let warnText = prop($$props, "warnText", 8, "");
  let helperText = prop($$props, "helperText", 8, "");
  let label = prop($$props, "label", 8, "");
  let hideLabel = prop($$props, "hideLabel", 8, false);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let name = prop($$props, "name", 8, void 0);
  let inputRef = prop($$props, "inputRef", 12, null);
  let multiSelectRef = prop($$props, "multiSelectRef", 12, null);
  let fieldRef = prop($$props, "fieldRef", 12, null);
  let selectionRef = prop($$props, "selectionRef", 12, null);
  let highlightedId = prop($$props, "highlightedId", 12, null);
  const dispatch = createEventDispatcher();
  let initialSorted = false;
  let highlightedIndex = mutable_state(-1);
  let prevChecked = [];
  setContext("MultiSelect", {
    declareRef: ({ key, ref }) => {
      switch (key) {
        case "field":
          fieldRef(ref);
          break;
        case "selection":
          selectionRef(ref);
          break;
      }
    }
  });
  function change(direction2) {
    let index2 = get(highlightedIndex) + direction2;
    const length = filterable() ? get(filteredItems).length : items().length;
    if (strict_equals(length, 0)) return;
    if (index2 < 0) {
      index2 = length - 1;
    } else if (index2 >= length) {
      index2 = 0;
    }
    let disabled2 = items()[index2].disabled;
    while (disabled2) {
      index2 = index2 + direction2;
      if (index2 < 0) {
        index2 = items().length - 1;
      } else if (index2 >= items().length) {
        index2 = 0;
      }
      disabled2 = items()[index2].disabled;
    }
    set(highlightedIndex, index2);
  }
  function sort() {
    return [
      ...get(checked).length > 1 ? get(checked).sort(sortItem()) : get(checked),
      ...get(unchecked).sort(sortItem())
    ];
  }
  afterUpdate(() => {
    if (strict_equals(get(checked).length, prevChecked.length, false)) {
      if (strict_equals(selectionFeedback(), "top")) {
        set(sortedItems, sort());
      }
      prevChecked = get(checked);
      selectedIds(get(checked).map(({ id: id2 }) => id2));
      dispatch("select", {
        selectedIds: selectedIds(),
        selected: get(checked),
        unselected: get(unchecked)
      });
    }
    if (!open()) {
      if (!initialSorted || strict_equals(selectionFeedback(), "fixed", false)) {
        set(sortedItems, sort());
        initialSorted = true;
      }
      set(highlightedIndex, -1);
      value("");
    }
    items(get(sortedItems));
  });
  legacy_pre_effect(() => deep_read_state(id()), () => {
    set(menuId, `menu-${id()}`);
  });
  legacy_pre_effect(() => deep_read_state(type()), () => {
    set(inline, strict_equals(type(), "inline"));
  });
  legacy_pre_effect(() => deep_read_state($$sanitized_props), () => {
    set(ariaLabel, $$sanitized_props["aria-label"] || "Choose an item");
  });
  legacy_pre_effect(
    () => (deep_read_state(items()), deep_read_state(selectedIds())),
    () => {
      set(sortedItems, items().map((item) => ({
        ...item,
        checked: selectedIds().includes(item.id)
      })));
    }
  );
  legacy_pre_effect(() => get(sortedItems), () => {
    set(checked, get(sortedItems).filter(({ checked: checked2 }) => checked2));
  });
  legacy_pre_effect(() => get(sortedItems), () => {
    set(unchecked, get(sortedItems).filter(({ checked: checked2 }) => !checked2));
  });
  legacy_pre_effect(
    () => (get(sortedItems), deep_read_state(filterItem()), deep_read_state(value())),
    () => {
      set(filteredItems, get(sortedItems).filter((item) => filterItem()(item, value())));
    }
  );
  legacy_pre_effect(
    () => (get(highlightedIndex), deep_read_state(filterable()), get(filteredItems), get(sortedItems)),
    () => {
      var _a;
      highlightedId(get(highlightedIndex) > -1 ? ((_a = (filterable() ? get(filteredItems) : get(sortedItems))[get(highlightedIndex)]) == null ? void 0 : _a.id) ?? null : null);
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root75();
  event2("click", $window, ({ target }) => {
    if (open() && multiSelectRef() && !multiSelectRef().contains(target)) {
      open(false);
    }
  });
  toggle_class(div, "bx--multi-select__wrapper", true);
  toggle_class(div, "bx--list-box__wrapper", true);
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var label_1 = root_153();
      var node_1 = child(label_1);
      slot(node_1, $$props, "titleText", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, titleText()));
        append($$anchor3, text2);
      });
      reset(label_1);
      template_effect(() => {
        set_attribute(label_1, "for", id());
        toggle_class(label_1, "bx--label", true);
        toggle_class(label_1, "bx--label--disabled", disabled());
        toggle_class(label_1, "bx--visually-hidden", hideLabel());
      });
      append($$anchor2, label_1);
    };
    if_block(node, ($$render) => {
      if (titleText() || $$slots.titleText) $$render(consequent);
    });
  }
  var node_2 = sibling(node, 2);
  const expression = derived_safe_equal(() => strict_equals(direction(), "top") && "bx--list-box--up");
  const expression_1 = derived_safe_equal(() => filterable() && "bx--combo-box");
  const expression_2 = derived_safe_equal(() => filterable() && "bx--multi-select--filterable");
  const expression_3 = derived_safe_equal(() => invalid() && "bx--multi-select--invalid");
  const expression_4 = derived_safe_equal(() => get(inline) && "bx--multi-select--inline");
  const expression_5 = derived_safe_equal(() => get(checked).length > 0 && "bx--multi-select--selected");
  ListBox_default(node_2, {
    role: void 0,
    get disabled() {
      return disabled();
    },
    get invalid() {
      return invalid();
    },
    get invalidText() {
      return invalidText();
    },
    get open() {
      return open();
    },
    get light() {
      return light();
    },
    get size() {
      return size();
    },
    get warn() {
      return warn();
    },
    get warnText() {
      return warnText();
    },
    get class() {
      return `bx--multi-select ${get(expression) ?? ""} ${get(expression_1) ?? ""}
      ${get(expression_2) ?? ""}
      ${get(expression_3) ?? ""}
      ${get(expression_4) ?? ""}
      ${get(expression_5) ?? ""}`;
    },
    children: wrap_snippet(MultiSelect, ($$anchor2, $$slotProps) => {
      var fragment_1 = root_311();
      var node_3 = first_child(fragment_1);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_4 = first_child(fragment_2);
          WarningFilled_default(node_4, { class: "bx--list-box__invalid-icon" });
          append($$anchor3, fragment_2);
        };
        if_block(node_3, ($$render) => {
          if (invalid()) $$render(consequent_1);
        });
      }
      var node_5 = sibling(node_3, 2);
      {
        var consequent_2 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_6 = first_child(fragment_3);
          WarningAltFilled_default(node_6, {
            class: "bx--list-box__invalid-icon bx--list-box__invalid-icon--warning"
          });
          append($$anchor3, fragment_3);
        };
        if_block(node_5, ($$render) => {
          if (!invalid() && warn()) $$render(consequent_2);
        });
      }
      var node_7 = sibling(node_5, 2);
      ListBoxField_default(node_7, {
        role: "button",
        tabindex: "0",
        get "aria-expanded"() {
          return open();
        },
        get id() {
          return id();
        },
        get disabled() {
          return disabled();
        },
        get translateWithId() {
          return translateWithId();
        },
        $$events: {
          click: () => {
            if (disabled()) return;
            if (filterable()) {
              open(true);
              inputRef().focus();
            } else {
              open(!open());
            }
          },
          keydown: (e) => {
            if (filterable()) {
              return;
            }
            const key = e.key;
            if ([" ", "ArrowUp", "ArrowDown"].includes(key)) {
              e.preventDefault();
            }
            if (strict_equals(key, " ")) {
              open(!open());
            } else if (strict_equals(key, "Tab")) {
              if (selectionRef() && get(checked).length > 0) {
                selectionRef().focus();
              } else {
                open(false);
                fieldRef().blur();
              }
            } else if (strict_equals(key, "ArrowDown")) {
              change(1);
            } else if (strict_equals(key, "ArrowUp")) {
              change(-1);
            } else if (strict_equals(key, "Enter")) {
              if (get(highlightedIndex) > -1) {
                set(sortedItems, get(sortedItems).map((item, i) => {
                  if (strict_equals(i, get(highlightedIndex), false)) return item;
                  return { ...item, checked: !item.checked };
                }));
              }
            } else if (strict_equals(key, "Escape")) {
              open(false);
            }
          },
          focus: () => {
            if (filterable()) {
              open(true);
              if (inputRef()) inputRef().focus();
            }
          },
          blur: (e) => {
            if (!filterable()) dispatch("blur", e);
          }
        },
        children: wrap_snippet(MultiSelect, ($$anchor3, $$slotProps2) => {
          var fragment_4 = root_67();
          var node_8 = first_child(fragment_4);
          {
            var consequent_3 = ($$anchor4) => {
              var fragment_5 = comment();
              var node_9 = first_child(fragment_5);
              ListBoxSelection_default(node_9, {
                get selectionCount() {
                  return get(checked).length;
                },
                get translateWithId() {
                  return translateWithIdSelection();
                },
                get disabled() {
                  return disabled();
                },
                $$events: {
                  clear: [
                    function($$arg) {
                      bubble_event.call(this, $$props, $$arg);
                    },
                    () => {
                      selectedIds([]);
                      set(sortedItems, get(sortedItems).map((item) => ({ ...item, checked: false })));
                      if (fieldRef()) fieldRef().blur();
                    }
                  ]
                }
              });
              append($$anchor4, fragment_5);
            };
            if_block(node_8, ($$render) => {
              if (get(checked).length > 0) $$render(consequent_3);
            });
          }
          var node_10 = sibling(node_8, 2);
          {
            var consequent_6 = ($$anchor4) => {
              var fragment_6 = root_83();
              var input = first_child(fragment_6);
              remove_input_defaults(input);
              let attributes;
              bind_this(input, ($$value) => inputRef($$value), () => inputRef());
              var node_11 = sibling(input, 2);
              {
                var consequent_4 = ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_12 = first_child(fragment_7);
                  WarningFilled_default(node_12, { class: "bx--list-box__invalid-icon" });
                  append($$anchor5, fragment_7);
                };
                if_block(node_11, ($$render) => {
                  if (invalid()) $$render(consequent_4);
                });
              }
              var node_13 = sibling(node_11, 2);
              {
                var consequent_5 = ($$anchor5) => {
                  var fragment_8 = comment();
                  var node_14 = first_child(fragment_8);
                  ListBoxSelection_default(node_14, {
                    get translateWithId() {
                      return translateWithIdSelection();
                    },
                    get disabled() {
                      return disabled();
                    },
                    get open() {
                      return open();
                    },
                    $$events: {
                      clear: () => {
                        value("");
                        open(false);
                      }
                    }
                  });
                  append($$anchor5, fragment_8);
                };
                if_block(node_13, ($$render) => {
                  if (value()) $$render(consequent_5);
                });
              }
              var node_15 = sibling(node_13, 2);
              const expression_6 = derived_safe_equal(() => open() ? "auto" : "none");
              ListBoxMenuIcon_default(node_15, {
                get style() {
                  return `pointer-events: ${get(expression_6) ?? ""}`;
                },
                get translateWithId() {
                  return translateWithId();
                },
                get open() {
                  return open();
                },
                $$events: {
                  click: (e) => {
                    e.stopPropagation();
                    open(!open());
                  }
                }
              });
              template_effect(() => {
                attributes = set_attributes(input, attributes, {
                  ...$$restProps,
                  role: "combobox",
                  tabindex: "0",
                  autocomplete: "off",
                  "aria-autocomplete": "list",
                  "aria-expanded": open(),
                  "aria-activedescendant": highlightedId(),
                  "aria-disabled": disabled(),
                  "aria-controls": get(menuId),
                  disabled: disabled(),
                  placeholder: placeholder(),
                  id: id(),
                  name: name()
                });
                toggle_class(input, "bx--text-input", true);
                toggle_class(input, "bx--text-input--empty", strict_equals(value(), ""));
                toggle_class(input, "bx--text-input--light", light());
              });
              bind_value(input, value);
              event2("keydown", input, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("keydown", input, stopPropagation(({ key }) => {
                if (strict_equals(key, "Enter")) {
                  if (highlightedId()) {
                    const filteredItemIndex = get(sortedItems).findIndex((item) => strict_equals(item.id, highlightedId()));
                    set(sortedItems, get(sortedItems).map((item, i) => {
                      if (strict_equals(i, filteredItemIndex, false)) return item;
                      return { ...item, checked: !item.checked };
                    }));
                  }
                } else if (strict_equals(key, "Tab")) {
                  open(false);
                  inputRef().blur();
                } else if (strict_equals(key, "ArrowDown")) {
                  change(1);
                } else if (strict_equals(key, "ArrowUp")) {
                  change(-1);
                } else if (strict_equals(key, "Escape")) {
                  open(false);
                } else if (strict_equals(key, " ")) {
                  if (!open()) open(true);
                }
              }));
              event2("keyup", input, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("focus", input, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("blur", input, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("paste", input, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              append($$anchor4, fragment_6);
            };
            if_block(node_10, ($$render) => {
              if (filterable()) $$render(consequent_6);
            });
          }
          var node_16 = sibling(node_10, 2);
          {
            var consequent_7 = ($$anchor4) => {
              var fragment_9 = root_1111();
              var span = first_child(fragment_9);
              toggle_class(span, "bx--list-box__label", true);
              var text_1 = child(span, true);
              reset(span);
              var node_17 = sibling(span, 2);
              ListBoxMenuIcon_default(node_17, {
                get open() {
                  return open();
                },
                get translateWithId() {
                  return translateWithId();
                }
              });
              template_effect(() => set_text(text_1, label()));
              append($$anchor4, fragment_9);
            };
            if_block(node_16, ($$render) => {
              if (!filterable()) $$render(consequent_7);
            });
          }
          append($$anchor3, fragment_4);
        }),
        $$slots: { default: true }
      });
      var div_1 = sibling(node_7, 2);
      var node_18 = child(div_1);
      ListBoxMenu_default(node_18, {
        get "aria-label"() {
          return get(ariaLabel);
        },
        get id() {
          return id();
        },
        "aria-multiselectable": "true",
        children: wrap_snippet(MultiSelect, ($$anchor3, $$slotProps2) => {
          var fragment_10 = comment();
          var node_19 = first_child(fragment_10);
          validate_each_keys(() => filterable() ? get(filteredItems) : get(sortedItems), (item) => item.id);
          each(node_19, 3, () => filterable() ? get(filteredItems) : get(sortedItems), (item) => item.id, ($$anchor4, item, i) => {
            var fragment_11 = comment();
            var node_20 = first_child(fragment_11);
            const expression_7 = derived_safe_equal(() => strict_equals(get(highlightedIndex), get(i)));
            ListBoxMenuItem_default(node_20, {
              get id() {
                return get(item).id;
              },
              role: "option",
              get "aria-labelledby"() {
                return `checkbox-${get(item).id ?? ""}`;
              },
              get "aria-selected"() {
                return get(item).checked;
              },
              get active() {
                return get(item).checked;
              },
              get highlighted() {
                return get(expression_7);
              },
              get disabled() {
                return get(item).disabled;
              },
              $$events: {
                click: (e) => {
                  if (get(item).disabled) {
                    e.stopPropagation();
                    return;
                  }
                  set(sortedItems, get(sortedItems).map((_) => strict_equals(_.id, get(item).id) ? { ..._, checked: !_.checked } : _));
                  fieldRef().focus();
                },
                mouseenter: () => {
                  if (get(item).disabled) return;
                  set(highlightedIndex, get(i));
                }
              },
              children: wrap_snippet(MultiSelect, ($$anchor5, $$slotProps3) => {
                var fragment_12 = comment();
                var node_21 = first_child(fragment_12);
                const expression_8 = derived_safe_equal(() => useTitleInItem() ? itemToString()(get(item)) : void 0);
                var spread_element = derived(() => itemToInput()(get(item)));
                Checkbox_default(node_21, spread_props(
                  {
                    get name() {
                      return get(item).id;
                    },
                    get title() {
                      return get(expression_8);
                    }
                  },
                  () => get(spread_element),
                  {
                    readonly: true,
                    tabindex: "-1",
                    get id() {
                      return `checkbox-${get(item).id ?? ""}`;
                    },
                    get checked() {
                      return get(item).checked;
                    },
                    get disabled() {
                      return get(item).disabled;
                    },
                    $$events: {
                      blur: () => {
                        if (strict_equals(get(i), get(filteredItems).length - 1)) open(false);
                      }
                    },
                    $$slots: {
                      labelText: ($$anchor6, $$slotProps4) => {
                        var fragment_13 = comment();
                        var node_22 = first_child(fragment_13);
                        slot(
                          node_22,
                          $$props,
                          "default",
                          {
                            get item() {
                              return get(item);
                            },
                            get index() {
                              return get(i);
                            }
                          },
                          ($$anchor7) => {
                            var text_2 = text();
                            template_effect(($0) => set_text(text_2, $0), [() => itemToString()(get(item))], derived_safe_equal);
                            append($$anchor7, text_2);
                          }
                        );
                        append($$anchor6, fragment_13);
                      }
                    }
                  }
                ));
                append($$anchor5, fragment_12);
              }),
              $$slots: { default: true }
            });
            append($$anchor4, fragment_11);
          });
          append($$anchor3, fragment_10);
        }),
        $$slots: { default: true }
      });
      reset(div_1);
      template_effect(() => set_style(div_1, "display", open() ? "block" : "none"));
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  var node_23 = sibling(node_2, 2);
  {
    var consequent_8 = ($$anchor2) => {
      var div_2 = root_172();
      toggle_class(div_2, "bx--form__helper-text", true);
      var text_3 = child(div_2, true);
      reset(div_2);
      template_effect(() => {
        toggle_class(div_2, "bx--form__helper-text--disabled", disabled());
        set_text(text_3, helperText());
      });
      append($$anchor2, div_2);
    };
    if_block(node_23, ($$render) => {
      if (!get(inline) && !invalid() && !warn() && helperText()) $$render(consequent_8);
    });
  }
  reset(div);
  bind_this(div, ($$value) => multiSelectRef($$value), () => multiSelectRef());
  template_effect(() => {
    toggle_class(div, "bx--multi-select__wrapper--inline", get(inline));
    toggle_class(div, "bx--list-box__wrapper--inline", get(inline));
    toggle_class(div, "bx--multi-select__wrapper--inline--invalid", get(inline) && invalid());
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MultiSelect = hmr(MultiSelect, () => MultiSelect[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MultiSelect[HMR].source;
    set(MultiSelect[HMR].source, module.default[HMR].original);
  });
}
var MultiSelect_default = MultiSelect;
mark_module_end(MultiSelect);

// node_modules/carbon-components-svelte/src/Modal/Modal.svelte
mark_module_start();
Modal[FILENAME] = "node_modules/carbon-components-svelte/src/Modal/Modal.svelte";
var root_154 = add_locations(template(`<button type="button"><!></button>`), Modal[FILENAME], [[212, 8]]);
var root_226 = add_locations(template(`<h2><!></h2>`), Modal[FILENAME], [[225, 8]]);
var root_56 = add_locations(template(`<button type="button"><!></button>`), Modal[FILENAME], [[233, 8]]);
var root_68 = add_locations(template(`<div></div>`), Modal[FILENAME], [[260, 6]]);
var root_76 = add_locations(template(`<div><!> <!></div>`), Modal[FILENAME], [[263, 6]]);
var root76 = add_locations(template(`<div><div tabindex="-1" aria-modal="true"><div><!> <!> <h3><!></h3> <!></div> <div><!></div> <!> <!></div></div>`), Modal[FILENAME], [
  [
    136,
    0,
    [
      [
        195,
        2,
        [
          [210, 4, [[229, 6]]],
          [247, 4]
        ]
      ]
    ]
  ]
]);
function Modal($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "size",
    "open",
    "danger",
    "alert",
    "passiveModal",
    "modalHeading",
    "modalLabel",
    "modalAriaLabel",
    "iconDescription",
    "hasForm",
    "hasScrollingContent",
    "primaryButtonText",
    "primaryButtonDisabled",
    "primaryButtonIcon",
    "shouldSubmitOnEnter",
    "secondaryButtonText",
    "secondaryButtons",
    "selectorPrimaryFocus",
    "preventCloseOnClickOutside",
    "id",
    "ref"
  ]);
  push($$props, false, Modal);
  const [$$stores, $$cleanup] = setup_stores();
  const $openStore = () => (validate_store(openStore, "openStore"), store_get(openStore, "$openStore", $$stores));
  const modalLabelId = mutable_state();
  const modalHeadingId = mutable_state();
  const modalBodyId = mutable_state();
  const ariaLabel = mutable_state();
  let size = prop($$props, "size", 8, void 0);
  let open = prop($$props, "open", 12, false);
  let danger = prop($$props, "danger", 8, false);
  let alert = prop($$props, "alert", 8, false);
  let passiveModal = prop($$props, "passiveModal", 8, false);
  let modalHeading = prop($$props, "modalHeading", 8, void 0);
  let modalLabel = prop($$props, "modalLabel", 8, void 0);
  let modalAriaLabel = prop($$props, "modalAriaLabel", 8, void 0);
  let iconDescription = prop($$props, "iconDescription", 8, "Close the modal");
  let hasForm = prop($$props, "hasForm", 8, false);
  let hasScrollingContent = prop($$props, "hasScrollingContent", 8, false);
  let primaryButtonText = prop($$props, "primaryButtonText", 8, "");
  let primaryButtonDisabled = prop($$props, "primaryButtonDisabled", 8, false);
  let primaryButtonIcon = prop($$props, "primaryButtonIcon", 8, void 0);
  let shouldSubmitOnEnter = prop($$props, "shouldSubmitOnEnter", 8, true);
  let secondaryButtonText = prop($$props, "secondaryButtonText", 8, "");
  let secondaryButtons = prop($$props, "secondaryButtons", 24, () => []);
  let selectorPrimaryFocus = prop($$props, "selectorPrimaryFocus", 8, "[data-modal-primary-focus]");
  let preventCloseOnClickOutside = prop($$props, "preventCloseOnClickOutside", 8, false);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let ref = prop($$props, "ref", 12, null);
  const dispatch = createEventDispatcher();
  let buttonRef = mutable_state(null);
  let innerModal = mutable_state(null);
  let opened = false;
  let didClickInnerModal = mutable_state(false);
  function focus(element) {
    const node = (element || get(innerModal)).querySelector(selectorPrimaryFocus()) || get(buttonRef);
    node.focus();
  }
  const openStore = writable(open());
  trackModal(openStore);
  afterUpdate(() => {
    if (opened) {
      if (!open()) {
        opened = false;
        dispatch("close");
      }
    } else if (open()) {
      opened = true;
      focus();
      dispatch("open");
    }
  });
  legacy_pre_effect(() => deep_read_state(open()), () => {
    store_set(openStore, open());
  });
  legacy_pre_effect(() => deep_read_state(id()), () => {
    set(modalLabelId, `bx--modal-header__label--modal-${id()}`);
  });
  legacy_pre_effect(() => deep_read_state(id()), () => {
    set(modalHeadingId, `bx--modal-header__heading--modal-${id()}`);
  });
  legacy_pre_effect(() => deep_read_state(id()), () => {
    set(modalBodyId, `bx--modal-body--${id()}`);
  });
  legacy_pre_effect(
    () => (deep_read_state(modalLabel()), deep_read_state($$sanitized_props), deep_read_state(modalAriaLabel()), deep_read_state(modalHeading())),
    () => {
      set(ariaLabel, modalLabel() || $$sanitized_props["aria-label"] || modalAriaLabel() || modalHeading());
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root76();
  let attributes;
  var div_1 = child(div);
  var div_2 = child(div_1);
  toggle_class(div_2, "bx--modal-header", true);
  var node_1 = child(div_2);
  {
    var consequent = ($$anchor2) => {
      var button_1 = root_154();
      var node_2 = child(button_1);
      Close_default(node_2, {
        size: 20,
        class: "bx--modal-close__icon",
        "aria-hidden": "true"
      });
      reset(button_1);
      bind_this(button_1, ($$value) => set(buttonRef, $$value), () => get(buttonRef));
      template_effect(() => {
        set_attribute(button_1, "aria-label", iconDescription());
        toggle_class(button_1, "bx--modal-close", true);
      });
      event2("click", button_1, () => {
        open(false);
      });
      append($$anchor2, button_1);
    };
    if_block(node_1, ($$render) => {
      if (passiveModal()) $$render(consequent);
    });
  }
  var node_3 = sibling(node_1, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var h2 = root_226();
      var node_4 = child(h2);
      slot(node_4, $$props, "label", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, modalLabel()));
        append($$anchor3, text2);
      });
      reset(h2);
      template_effect(() => {
        set_attribute(h2, "id", get(modalLabelId));
        toggle_class(h2, "bx--modal-header__label", true);
      });
      append($$anchor2, h2);
    };
    if_block(node_3, ($$render) => {
      if (modalLabel()) $$render(consequent_1);
    });
  }
  var h3 = sibling(node_3, 2);
  var node_5 = child(h3);
  slot(node_5, $$props, "heading", {}, ($$anchor2) => {
    var text_1 = text();
    template_effect(() => set_text(text_1, modalHeading()));
    append($$anchor2, text_1);
  });
  reset(h3);
  var node_6 = sibling(h3, 2);
  {
    var consequent_2 = ($$anchor2) => {
      var button_2 = root_56();
      var node_7 = child(button_2);
      Close_default(node_7, {
        size: 20,
        class: "bx--modal-close__icon",
        "aria-hidden": "true"
      });
      reset(button_2);
      bind_this(button_2, ($$value) => set(buttonRef, $$value), () => get(buttonRef));
      template_effect(() => {
        set_attribute(button_2, "aria-label", iconDescription());
        toggle_class(button_2, "bx--modal-close", true);
      });
      event2("click", button_2, () => {
        open(false);
      });
      append($$anchor2, button_2);
    };
    if_block(node_6, ($$render) => {
      if (!passiveModal()) $$render(consequent_2);
    });
  }
  reset(div_2);
  var div_3 = sibling(div_2, 2);
  var node_8 = child(div_3);
  slot(node_8, $$props, "default", {}, null);
  reset(div_3);
  var node_9 = sibling(div_3, 2);
  {
    var consequent_3 = ($$anchor2) => {
      var div_4 = root_68();
      toggle_class(div_4, "bx--modal-content--overflow-indicator", true);
      append($$anchor2, div_4);
    };
    if_block(node_9, ($$render) => {
      if (hasScrollingContent()) $$render(consequent_3);
    });
  }
  var node_10 = sibling(node_9, 2);
  {
    var consequent_6 = ($$anchor2) => {
      var div_5 = root_76();
      toggle_class(div_5, "bx--modal-footer", true);
      var node_11 = child(div_5);
      {
        var consequent_4 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_12 = first_child(fragment_2);
          each(node_12, 1, secondaryButtons, index, ($$anchor4, button) => {
            var fragment_3 = comment();
            var node_13 = first_child(fragment_3);
            Button_default(node_13, {
              kind: "secondary",
              $$events: {
                click: () => {
                  dispatch("click:button--secondary", { text: get(button).text });
                }
              },
              children: wrap_snippet(Modal, ($$anchor5, $$slotProps) => {
                next();
                var text_2 = text();
                template_effect(() => set_text(text_2, get(button).text));
                append($$anchor5, text_2);
              }),
              $$slots: { default: true }
            });
            append($$anchor4, fragment_3);
          });
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var fragment_5 = comment();
          var node_14 = first_child(fragment_5);
          {
            var consequent_5 = ($$anchor4) => {
              var fragment_6 = comment();
              var node_15 = first_child(fragment_6);
              Button_default(node_15, {
                kind: "secondary",
                $$events: {
                  click: () => {
                    dispatch("click:button--secondary", { text: secondaryButtonText() });
                  }
                },
                children: wrap_snippet(Modal, ($$anchor5, $$slotProps) => {
                  next();
                  var text_3 = text();
                  template_effect(() => set_text(text_3, secondaryButtonText()));
                  append($$anchor5, text_3);
                }),
                $$slots: { default: true }
              });
              append($$anchor4, fragment_6);
            };
            if_block(
              node_14,
              ($$render) => {
                if (secondaryButtonText()) $$render(consequent_5);
              },
              true
            );
          }
          append($$anchor3, fragment_5);
        };
        if_block(node_11, ($$render) => {
          if (secondaryButtons().length > 0) $$render(consequent_4);
          else $$render(alternate, false);
        });
      }
      var node_16 = sibling(node_11, 2);
      const expression = derived_safe_equal(() => danger() ? "danger" : "primary");
      Button_default(node_16, {
        get kind() {
          return get(expression);
        },
        get disabled() {
          return primaryButtonDisabled();
        },
        get icon() {
          return primaryButtonIcon();
        },
        $$events: {
          click: () => {
            dispatch("submit");
            dispatch("click:button--primary");
          }
        },
        children: wrap_snippet(Modal, ($$anchor3, $$slotProps) => {
          next();
          var text_4 = text();
          template_effect(() => set_text(text_4, primaryButtonText()));
          append($$anchor3, text_4);
        }),
        $$slots: { default: true }
      });
      reset(div_5);
      template_effect(() => toggle_class(div_5, "bx--modal-footer--three-button", strict_equals(secondaryButtons().length, 2)));
      append($$anchor2, div_5);
    };
    if_block(node_10, ($$render) => {
      if (!passiveModal()) $$render(consequent_6);
    });
  }
  reset(div_1);
  bind_this(div_1, ($$value) => set(innerModal, $$value), () => get(innerModal));
  reset(div);
  bind_this(div, ($$value) => ref($$value), () => ref());
  template_effect(() => {
    attributes = set_attributes(div, attributes, {
      role: "presentation",
      id: id(),
      ...$$restProps
    });
    toggle_class(div, "bx--modal", true);
    toggle_class(div, "bx--modal-tall", !passiveModal());
    toggle_class(div, "is-visible", open());
    toggle_class(div, "bx--modal--danger", danger());
    set_attribute(div_1, "role", alert() ? passiveModal() ? "alert" : "alertdialog" : "dialog");
    set_attribute(div_1, "aria-describedby", alert() && !passiveModal() ? get(modalBodyId) : void 0);
    set_attribute(div_1, "aria-label", get(ariaLabel));
    toggle_class(div_1, "bx--modal-container", true);
    toggle_class(div_1, "bx--modal-container--xs", strict_equals(size(), "xs"));
    toggle_class(div_1, "bx--modal-container--sm", strict_equals(size(), "sm"));
    toggle_class(div_1, "bx--modal-container--lg", strict_equals(size(), "lg"));
    set_attribute(h3, "id", get(modalHeadingId));
    toggle_class(h3, "bx--modal-header__heading", true);
    set_attribute(div_3, "id", get(modalBodyId));
    set_attribute(div_3, "tabindex", hasScrollingContent() ? "0" : void 0);
    set_attribute(div_3, "role", hasScrollingContent() ? "region" : void 0);
    set_attribute(div_3, "aria-label", hasScrollingContent() ? get(ariaLabel) : void 0);
    set_attribute(div_3, "aria-labelledby", modalLabel() ? get(modalLabelId) : get(modalHeadingId));
    toggle_class(div_3, "bx--modal-content", true);
    toggle_class(div_3, "bx--modal-content--with-form", hasForm());
    toggle_class(div_3, "bx--modal-scroll-content", hasScrollingContent());
  });
  event2("click", div_1, () => {
    set(didClickInnerModal, true);
  });
  event2("keydown", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", div, (e) => {
    if (open()) {
      if (strict_equals(e.key, "Escape")) {
        open(false);
      } else if (strict_equals(e.key, "Tab")) {
        const selectorTabbable = `
  a[href], area[href], input:not([disabled]):not([tabindex='-1']),
  button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),
  textarea:not([disabled]):not([tabindex='-1']),
  iframe, object, embed, *[tabindex]:not([tabindex='-1']):not([disabled]), *[contenteditable=true]
`;
        const tabbable = Array.from(ref().querySelectorAll(selectorTabbable));
        let index2 = tabbable.indexOf(document.activeElement);
        if (strict_equals(index2, -1) && e.shiftKey) index2 = 0;
        index2 += tabbable.length + (e.shiftKey ? -1 : 1);
        index2 %= tabbable.length;
        tabbable[index2].focus();
        e.preventDefault();
      } else if (shouldSubmitOnEnter() && strict_equals(e.key, "Enter") && !primaryButtonDisabled()) {
        dispatch("submit");
        dispatch("click:button--primary");
      }
    }
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", div, () => {
    if (!get(didClickInnerModal) && !preventCloseOnClickOutside()) open(false);
    set(didClickInnerModal, false);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("transitionend", div, (e) => {
    if (strict_equals(e.propertyName, "transform")) {
      dispatch("transitionend", { open: open() });
    }
  });
  append($$anchor, div);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Modal = hmr(Modal, () => Modal[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Modal[HMR].source;
    set(Modal[HMR].source, module.default[HMR].original);
  });
}
var Modal_default = Modal;
mark_module_end(Modal);

// node_modules/carbon-components-svelte/src/Notification/NotificationButton.svelte
mark_module_start();
NotificationButton[FILENAME] = "node_modules/carbon-components-svelte/src/Notification/NotificationButton.svelte";
var root77 = add_locations(template(`<button><!></button>`), NotificationButton[FILENAME], [[27, 0]]);
function NotificationButton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "notificationType",
    "icon",
    "title",
    "iconDescription"
  ]);
  push($$props, false, NotificationButton);
  let notificationType = prop($$props, "notificationType", 8, "toast");
  let icon = prop($$props, "icon", 8, Close_default);
  let title = prop($$props, "title", 8, void 0);
  let iconDescription = prop($$props, "iconDescription", 8, "Close icon");
  var button = root77();
  let attributes;
  var node = child(button);
  const expression = derived_safe_equal(() => strict_equals(notificationType(), "toast") && "bx--toast-notification__close-icon");
  const expression_1 = derived_safe_equal(() => strict_equals(notificationType(), "inline") && "bx--inline-notification__close-icon");
  component(node, icon, ($$anchor2, $$component) => {
    $$component($$anchor2, {
      size: 20,
      get title() {
        return title();
      },
      get class() {
        return `${get(expression) ?? ""} ${get(expression_1) ?? ""}`;
      }
    });
  });
  reset(button);
  template_effect(() => {
    attributes = set_attributes(button, attributes, {
      type: "button",
      "aria-label": iconDescription(),
      title: iconDescription(),
      ...$$restProps
    });
    toggle_class(button, "bx--toast-notification__close-button", strict_equals(notificationType(), "toast"));
    toggle_class(button, "bx--inline-notification__close-button", strict_equals(notificationType(), "inline"));
  });
  event2("click", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, button);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  NotificationButton = hmr(NotificationButton, () => NotificationButton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = NotificationButton[HMR].source;
    set(NotificationButton[HMR].source, module.default[HMR].original);
  });
}
var NotificationButton_default = NotificationButton;
mark_module_end(NotificationButton);

// node_modules/carbon-components-svelte/src/icons/InformationFilled.svelte
mark_module_start();
InformationFilled[FILENAME] = "node_modules/carbon-components-svelte/src/icons/InformationFilled.svelte";
var root_155 = add_locations(ns_template(`<title> </title>`), InformationFilled[FILENAME], [[24, 13]]);
var root78 = add_locations(ns_template(`<svg><!><path fill="none" d="M16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,13.875H17.125v-8H13v2.25h1.875v5.75H12v2.25h8Z" data-icon-path="inner-path"></path><path d="M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,6a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,16.125H12v-2.25h2.875v-5.75H13v-2.25h4.125v8H20Z"></path></svg>`), InformationFilled[FILENAME], [[14, 0, [[25, 2], [28, 39]]]]);
function InformationFilled($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, InformationFilled);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root78();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_155();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next(2);
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InformationFilled = hmr(InformationFilled, () => InformationFilled[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InformationFilled[HMR].source;
    set(InformationFilled[HMR].source, module.default[HMR].original);
  });
}
var InformationFilled_default = InformationFilled;
mark_module_end(InformationFilled);

// node_modules/carbon-components-svelte/src/icons/InformationSquareFilled.svelte
mark_module_start();
InformationSquareFilled[FILENAME] = "node_modules/carbon-components-svelte/src/icons/InformationSquareFilled.svelte";
var root_156 = add_locations(ns_template(`<title> </title>`), InformationSquareFilled[FILENAME], [[24, 13]]);
var root79 = add_locations(ns_template(`<svg><!><path fill="none" d="M16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,13.875H17.125v-8H13v2.25h1.875v5.75H12v2.25h8Z" data-icon-path="inner-path"></path><path d="M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,16.125H12v-2.25h2.875v-5.75H13v-2.25h4.125v8H20Z"></path></svg>`), InformationSquareFilled[FILENAME], [[14, 0, [[25, 2], [28, 39]]]]);
function InformationSquareFilled($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, InformationSquareFilled);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root79();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_156();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next(2);
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InformationSquareFilled = hmr(InformationSquareFilled, () => InformationSquareFilled[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InformationSquareFilled[HMR].source;
    set(InformationSquareFilled[HMR].source, module.default[HMR].original);
  });
}
var InformationSquareFilled_default = InformationSquareFilled;
mark_module_end(InformationSquareFilled);

// node_modules/carbon-components-svelte/src/Notification/NotificationIcon.svelte
mark_module_start();
NotificationIcon[FILENAME] = "node_modules/carbon-components-svelte/src/Notification/NotificationIcon.svelte";
function NotificationIcon($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, NotificationIcon);
  let kind = prop($$props, "kind", 8, "error");
  let notificationType = prop($$props, "notificationType", 8, "toast");
  let iconDescription = prop($$props, "iconDescription", 8);
  const icons = {
    error: ErrorFilled_default,
    "info-square": InformationSquareFilled_default,
    info: InformationFilled_default,
    success: CheckmarkFilled_default,
    warning: WarningFilled_default,
    "warning-alt": WarningAltFilled_default
  };
  var fragment = comment();
  var node = first_child(fragment);
  const expression = derived_safe_equal(() => strict_equals(notificationType(), "toast") && "bx--toast-notification__icon");
  const expression_1 = derived_safe_equal(() => strict_equals(notificationType(), "inline") && "bx--inline-notification__icon");
  component(node, () => icons[kind()], ($$anchor2, $$component) => {
    $$component($$anchor2, {
      size: 20,
      get title() {
        return iconDescription();
      },
      get class() {
        return `${get(expression) ?? ""} ${get(expression_1) ?? ""}`;
      }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  NotificationIcon = hmr(NotificationIcon, () => NotificationIcon[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = NotificationIcon[HMR].source;
    set(NotificationIcon[HMR].source, module.default[HMR].original);
  });
}
var NotificationIcon_default = NotificationIcon;
mark_module_end(NotificationIcon);

// node_modules/carbon-components-svelte/src/Notification/ToastNotification.svelte
mark_module_start();
ToastNotification[FILENAME] = "node_modules/carbon-components-svelte/src/Notification/ToastNotification.svelte";
var root_157 = add_locations(template(`<div><!> <div><h3><!></h3> <div><!></div> <div><!></div> <!></div> <!></div>`), ToastNotification[FILENAME], [
  [
    94,
    2,
    [
      [
        113,
        4,
        [[114, 6], [117, 6], [120, 6]]
      ]
    ]
  ]
]);
function ToastNotification($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "kind",
    "lowContrast",
    "timeout",
    "role",
    "title",
    "subtitle",
    "caption",
    "statusIconDescription",
    "closeButtonDescription",
    "hideCloseButton",
    "fullWidth"
  ]);
  push($$props, false, ToastNotification);
  let kind = prop($$props, "kind", 8, "error");
  let lowContrast = prop($$props, "lowContrast", 8, false);
  let timeout = prop($$props, "timeout", 8, 0);
  let role = prop($$props, "role", 8, "alert");
  let title = prop($$props, "title", 8, "");
  let subtitle = prop($$props, "subtitle", 8, "");
  let caption = prop($$props, "caption", 8, "");
  let statusIconDescription = prop($$props, "statusIconDescription", 24, () => kind() + " icon");
  let closeButtonDescription = prop($$props, "closeButtonDescription", 8, "Close notification");
  let hideCloseButton = prop($$props, "hideCloseButton", 8, false);
  let fullWidth = prop($$props, "fullWidth", 8, false);
  const dispatch = createEventDispatcher();
  let open = mutable_state(true);
  let timeoutId = mutable_state(void 0);
  function close(closeFromTimeout) {
    clearTimeout(get(timeoutId));
    const shouldContinue = dispatch(
      "close",
      {
        timeout: strict_equals(closeFromTimeout, true)
      },
      { cancelable: true }
    );
    if (shouldContinue) {
      set(open, false);
    }
  }
  onMount(() => {
    return () => {
      clearTimeout(get(timeoutId));
    };
  });
  legacy_pre_effect(
    () => (get(timeoutId), get(open), deep_read_state(timeout())),
    () => {
      if (strict_equals(typeof window, "undefined", false)) {
        clearTimeout(get(timeoutId));
        if (get(open) && timeout()) {
          set(timeoutId, setTimeout(() => close(true), timeout()));
        }
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var div = root_157();
      let attributes;
      var node_1 = child(div);
      NotificationIcon_default(node_1, {
        get kind() {
          return kind();
        },
        get iconDescription() {
          return statusIconDescription();
        }
      });
      var div_1 = sibling(node_1, 2);
      toggle_class(div_1, "bx--toast-notification__details", true);
      var h3 = child(div_1);
      toggle_class(h3, "bx--toast-notification__title", true);
      var node_2 = child(h3);
      slot(node_2, $$props, "title", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, title()));
        append($$anchor3, text2);
      });
      reset(h3);
      var div_2 = sibling(h3, 2);
      toggle_class(div_2, "bx--toast-notification__subtitle", true);
      var node_3 = child(div_2);
      slot(node_3, $$props, "subtitle", {}, ($$anchor3) => {
        var text_1 = text();
        template_effect(() => set_text(text_1, subtitle()));
        append($$anchor3, text_1);
      });
      reset(div_2);
      var div_3 = sibling(div_2, 2);
      toggle_class(div_3, "bx--toast-notification__caption", true);
      var node_4 = child(div_3);
      slot(node_4, $$props, "caption", {}, ($$anchor3) => {
        var text_2 = text();
        template_effect(() => set_text(text_2, caption()));
        append($$anchor3, text_2);
      });
      reset(div_3);
      var node_5 = sibling(div_3, 2);
      slot(node_5, $$props, "default", {}, null);
      reset(div_1);
      var node_6 = sibling(div_1, 2);
      {
        var consequent = ($$anchor3) => {
          var fragment_4 = comment();
          var node_7 = first_child(fragment_4);
          NotificationButton_default(node_7, {
            get iconDescription() {
              return closeButtonDescription();
            },
            $$events: { click: close }
          });
          append($$anchor3, fragment_4);
        };
        if_block(node_6, ($$render) => {
          if (!hideCloseButton()) $$render(consequent);
        });
      }
      reset(div);
      template_effect(() => {
        attributes = set_attributes(div, attributes, {
          role: role(),
          kind: kind(),
          ...$$restProps
        });
        toggle_class(div, "bx--toast-notification", true);
        toggle_class(div, "bx--toast-notification--low-contrast", lowContrast());
        toggle_class(div, "bx--toast-notification--error", strict_equals(kind(), "error"));
        toggle_class(div, "bx--toast-notification--info", strict_equals(kind(), "info"));
        toggle_class(div, "bx--toast-notification--info-square", strict_equals(kind(), "info-square"));
        toggle_class(div, "bx--toast-notification--success", strict_equals(kind(), "success"));
        toggle_class(div, "bx--toast-notification--warning", strict_equals(kind(), "warning"));
        toggle_class(div, "bx--toast-notification--warning-alt", strict_equals(kind(), "warning-alt"));
        set_style(div, "width", fullWidth() ? "100%" : void 0);
      });
      event2("click", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseover", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseenter", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseleave", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if (get(open)) $$render(consequent_1);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ToastNotification = hmr(ToastNotification, () => ToastNotification[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ToastNotification[HMR].source;
    set(ToastNotification[HMR].source, module.default[HMR].original);
  });
}
var ToastNotification_default = ToastNotification;
mark_module_end(ToastNotification);

// node_modules/carbon-components-svelte/src/Notification/InlineNotification.svelte
mark_module_start();
InlineNotification[FILENAME] = "node_modules/carbon-components-svelte/src/Notification/InlineNotification.svelte";
var root_158 = add_locations(template(`<div><div><!> <div><p><!></p> <div><!></div> <!></div></div> <!> <!></div>`), InlineNotification[FILENAME], [
  [
    72,
    2,
    [
      [
        90,
        4,
        [[96, 6, [[97, 8], [100, 8]]]]
      ]
    ]
  ]
]);
function InlineNotification($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "kind",
    "lowContrast",
    "timeout",
    "role",
    "title",
    "subtitle",
    "hideCloseButton",
    "statusIconDescription",
    "closeButtonDescription"
  ]);
  push($$props, false, InlineNotification);
  let kind = prop($$props, "kind", 8, "error");
  let lowContrast = prop($$props, "lowContrast", 8, false);
  let timeout = prop($$props, "timeout", 8, 0);
  let role = prop($$props, "role", 8, "alert");
  let title = prop($$props, "title", 8, "");
  let subtitle = prop($$props, "subtitle", 8, "");
  let hideCloseButton = prop($$props, "hideCloseButton", 8, false);
  let statusIconDescription = prop($$props, "statusIconDescription", 24, () => kind() + " icon");
  let closeButtonDescription = prop($$props, "closeButtonDescription", 8, "Close notification");
  const dispatch = createEventDispatcher();
  let open = mutable_state(true);
  let timeoutId = void 0;
  function close(closeFromTimeout) {
    const shouldContinue = dispatch(
      "close",
      {
        timeout: strict_equals(closeFromTimeout, true)
      },
      { cancelable: true }
    );
    if (shouldContinue) {
      set(open, false);
    }
  }
  onMount(() => {
    if (timeout()) {
      timeoutId = setTimeout(() => close(true), timeout());
    }
    return () => {
      clearTimeout(timeoutId);
    };
  });
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var div = root_158();
      let attributes;
      var div_1 = child(div);
      toggle_class(div_1, "bx--inline-notification__details", true);
      var node_1 = child(div_1);
      NotificationIcon_default(node_1, {
        notificationType: "inline",
        get kind() {
          return kind();
        },
        get iconDescription() {
          return statusIconDescription();
        }
      });
      var div_2 = sibling(node_1, 2);
      toggle_class(div_2, "bx--inline-notification__text-wrapper", true);
      var p = child(div_2);
      toggle_class(p, "bx--inline-notification__title", true);
      var node_2 = child(p);
      slot(node_2, $$props, "title", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, title()));
        append($$anchor3, text2);
      });
      reset(p);
      var div_3 = sibling(p, 2);
      toggle_class(div_3, "bx--inline-notification__subtitle", true);
      var node_3 = child(div_3);
      slot(node_3, $$props, "subtitle", {}, ($$anchor3) => {
        var text_1 = text();
        template_effect(() => set_text(text_1, subtitle()));
        append($$anchor3, text_1);
      });
      reset(div_3);
      var node_4 = sibling(div_3, 2);
      slot(node_4, $$props, "default", {}, null);
      reset(div_2);
      reset(div_1);
      var node_5 = sibling(div_1, 2);
      slot(node_5, $$props, "actions", {}, null);
      var node_6 = sibling(node_5, 2);
      {
        var consequent = ($$anchor3) => {
          var fragment_3 = comment();
          var node_7 = first_child(fragment_3);
          NotificationButton_default(node_7, {
            get iconDescription() {
              return closeButtonDescription();
            },
            notificationType: "inline",
            $$events: { click: close }
          });
          append($$anchor3, fragment_3);
        };
        if_block(node_6, ($$render) => {
          if (!hideCloseButton()) $$render(consequent);
        });
      }
      reset(div);
      template_effect(() => {
        attributes = set_attributes(div, attributes, {
          role: role(),
          kind: kind(),
          ...$$restProps
        });
        toggle_class(div, "bx--inline-notification", true);
        toggle_class(div, "bx--inline-notification--low-contrast", lowContrast());
        toggle_class(div, "bx--inline-notification--hide-close-button", hideCloseButton());
        toggle_class(div, "bx--inline-notification--error", strict_equals(kind(), "error"));
        toggle_class(div, "bx--inline-notification--info", strict_equals(kind(), "info"));
        toggle_class(div, "bx--inline-notification--info-square", strict_equals(kind(), "info-square"));
        toggle_class(div, "bx--inline-notification--success", strict_equals(kind(), "success"));
        toggle_class(div, "bx--inline-notification--warning", strict_equals(kind(), "warning"));
        toggle_class(div, "bx--inline-notification--warning-alt", strict_equals(kind(), "warning-alt"));
      });
      event2("click", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseover", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseenter", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseleave", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if (get(open)) $$render(consequent_1);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InlineNotification = hmr(InlineNotification, () => InlineNotification[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InlineNotification[HMR].source;
    set(InlineNotification[HMR].source, module.default[HMR].original);
  });
}
var InlineNotification_default = InlineNotification;
mark_module_end(InlineNotification);

// node_modules/carbon-components-svelte/src/Notification/NotificationActionButton.svelte
mark_module_start();
NotificationActionButton[FILENAME] = "node_modules/carbon-components-svelte/src/Notification/NotificationActionButton.svelte";
function NotificationActionButton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, NotificationActionButton);
  init();
  var fragment = comment();
  var node = first_child(fragment);
  Button_default(node, spread_props({ kind: "ghost", size: "small" }, () => $$restProps, {
    get class() {
      return `bx--inline-notification__action-button ${$$restProps.class ?? ""}`;
    },
    $$events: {
      click($$arg) {
        bubble_event.call(this, $$props, $$arg);
      },
      mouseover($$arg) {
        bubble_event.call(this, $$props, $$arg);
      },
      mouseenter($$arg) {
        bubble_event.call(this, $$props, $$arg);
      },
      mouseleave($$arg) {
        bubble_event.call(this, $$props, $$arg);
      }
    },
    children: wrap_snippet(NotificationActionButton, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  NotificationActionButton = hmr(NotificationActionButton, () => NotificationActionButton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = NotificationActionButton[HMR].source;
    set(NotificationActionButton[HMR].source, module.default[HMR].original);
  });
}
var NotificationActionButton_default = NotificationActionButton;
mark_module_end(NotificationActionButton);

// node_modules/carbon-components-svelte/src/icons/Add.svelte
mark_module_start();
Add[FILENAME] = "node_modules/carbon-components-svelte/src/icons/Add.svelte";
var root_159 = add_locations(ns_template(`<title> </title>`), Add[FILENAME], [[24, 13]]);
var root80 = add_locations(ns_template(`<svg><!><path d="M17 15L17 8 15 8 15 15 8 15 8 17 15 17 15 24 17 24 17 17 24 17 24 15z"></path></svg>`), Add[FILENAME], [[14, 0, [[25, 2]]]]);
function Add($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, Add);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root80();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_159();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next();
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Add = hmr(Add, () => Add[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Add[HMR].source;
    set(Add[HMR].source, module.default[HMR].original);
  });
}
var Add_default = Add;
mark_module_end(Add);

// node_modules/carbon-components-svelte/src/icons/Subtract.svelte
mark_module_start();
Subtract[FILENAME] = "node_modules/carbon-components-svelte/src/icons/Subtract.svelte";
var root_160 = add_locations(ns_template(`<title> </title>`), Subtract[FILENAME], [[24, 13]]);
var root81 = add_locations(ns_template(`<svg><!><path d="M8 15H24V17H8z"></path></svg>`), Subtract[FILENAME], [[14, 0, [[25, 2]]]]);
function Subtract($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, Subtract);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root81();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_160();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next();
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Subtract = hmr(Subtract, () => Subtract[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Subtract[HMR].source;
    set(Subtract[HMR].source, module.default[HMR].original);
  });
}
var Subtract_default = Subtract;
mark_module_end(Subtract);

// node_modules/carbon-components-svelte/src/icons/EditOff.svelte
mark_module_start();
EditOff[FILENAME] = "node_modules/carbon-components-svelte/src/icons/EditOff.svelte";
var root_161 = add_locations(ns_template(`<title> </title>`), EditOff[FILENAME], [[24, 13]]);
var root82 = add_locations(ns_template(`<svg><!><path d="M30 28.6L3.4 2 2 3.4l10.1 10.1L4 21.6V28h6.4l8.1-8.1L28.6 30 30 28.6zM9.6 26H6v-3.6l7.5-7.5 3.6 3.6L9.6 26zM29.4 6.2L29.4 6.2l-3.6-3.6c-.8-.8-2-.8-2.8 0l0 0 0 0-8 8 1.4 1.4L20 8.4l3.6 3.6L20 15.6l1.4 1.4 8-8C30.2 8.2 30.2 7 29.4 6.2L29.4 6.2zM25 10.6L21.4 7l3-3L28 7.6 25 10.6z"></path></svg>`), EditOff[FILENAME], [[14, 0, [[25, 2]]]]);
function EditOff($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, EditOff);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root82();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_161();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next();
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  EditOff = hmr(EditOff, () => EditOff[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EditOff[HMR].source;
    set(EditOff[HMR].source, module.default[HMR].original);
  });
}
var EditOff_default = EditOff;
mark_module_end(EditOff);

// node_modules/carbon-components-svelte/src/NumberInput/NumberInput.svelte
mark_module_start();
NumberInput[FILENAME] = "node_modules/carbon-components-svelte/src/NumberInput/NumberInput.svelte";
var root_162 = add_locations(template(`<label><!></label>`), NumberInput[FILENAME], [[177, 6]]);
var root_48 = add_locations(template(`<!> <!>`, 1), NumberInput[FILENAME], []);
var root_77 = add_locations(template(`<div><button type="button" tabindex="-1"><!></button> <div></div> <button type="button" tabindex="-1"><!></button> <div></div></div>`), NumberInput[FILENAME], [
  [
    228,
    8,
    [
      [229, 10],
      [243, 10],
      [244, 10],
      [258, 10]
    ]
  ]
]);
var root_84 = add_locations(template(`<div> </div>`), NumberInput[FILENAME], [[263, 6]]);
var root_92 = add_locations(template(`<div> </div>`), NumberInput[FILENAME], [[271, 6]]);
var root_104 = add_locations(template(`<div> </div>`), NumberInput[FILENAME], [[276, 6]]);
var root83 = add_locations(template(`<div><div><!> <div><input> <!> <!></div> <!> <!> <!></div></div>`), NumberInput[FILENAME], [
  [
    158,
    0,
    [
      [
        165,
        2,
        [[186, 4, [[190, 6]]]]
      ]
    ]
  ]
]);
function NumberInput($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "translationIds",
    "size",
    "value",
    "step",
    "max",
    "min",
    "light",
    "readonly",
    "allowEmpty",
    "disabled",
    "hideSteppers",
    "iconDescription",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "helperText",
    "label",
    "hideLabel",
    "translateWithId",
    "id",
    "name",
    "ref"
  ]);
  push($$props, false, NumberInput);
  const incrementLabel = mutable_state();
  const decrementLabel = mutable_state();
  const error = mutable_state();
  const errorId = mutable_state();
  const ariaLabel = mutable_state();
  let size = prop($$props, "size", 8, void 0);
  let value = prop($$props, "value", 12, null);
  let step = prop($$props, "step", 8, 1);
  let max = prop($$props, "max", 8, void 0);
  let min = prop($$props, "min", 8, void 0);
  let light = prop($$props, "light", 8, false);
  let readonly2 = prop($$props, "readonly", 8, false);
  let allowEmpty = prop($$props, "allowEmpty", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let hideSteppers = prop($$props, "hideSteppers", 8, false);
  let iconDescription = prop($$props, "iconDescription", 8, "");
  let invalid = prop($$props, "invalid", 8, false);
  let invalidText = prop($$props, "invalidText", 8, "");
  let warn = prop($$props, "warn", 8, false);
  let warnText = prop($$props, "warnText", 8, "");
  let helperText = prop($$props, "helperText", 8, "");
  let label = prop($$props, "label", 8, "");
  let hideLabel = prop($$props, "hideLabel", 8, false);
  let translateWithId = prop($$props, "translateWithId", 8, (id2) => defaultTranslations[id2]);
  const translationIds = {
    increment: "increment",
    decrement: "decrement"
  };
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let name = prop($$props, "name", 8, void 0);
  let ref = prop($$props, "ref", 12, null);
  const defaultTranslations = {
    [translationIds.increment]: "Increment number",
    [translationIds.decrement]: "Decrement number"
  };
  const dispatch = createEventDispatcher();
  function updateValue(isIncrementing) {
    if (isIncrementing) {
      ref().stepUp();
    } else {
      ref().stepDown();
    }
    value(+ref().value);
    dispatch("input", value());
    dispatch("change", value());
  }
  function parse(raw) {
    return equals(raw, "", false) ? Number(raw) : null;
  }
  function onInput({ target }) {
    value(parse(target.value));
    dispatch("input", value());
  }
  function onChange({ target }) {
    dispatch("change", parse(target.value));
  }
  legacy_pre_effect(() => deep_read_state(translateWithId()), () => {
    set(incrementLabel, translateWithId()("increment"));
  });
  legacy_pre_effect(() => deep_read_state(translateWithId()), () => {
    set(decrementLabel, translateWithId()("decrement"));
  });
  legacy_pre_effect(
    () => (deep_read_state(invalid()), deep_read_state(readonly2()), deep_read_state(allowEmpty()), deep_read_state(value()), deep_read_state(max()), deep_read_state(min())),
    () => {
      set(error, invalid() && !readonly2() || !allowEmpty() && equals(value(), null) || value() > max() || strict_equals(typeof value(), "number") && value() < min());
    }
  );
  legacy_pre_effect(() => deep_read_state(id()), () => {
    set(errorId, `error-${id()}`);
  });
  legacy_pre_effect(() => deep_read_state($$sanitized_props), () => {
    set(ariaLabel, $$sanitized_props["aria-label"] || "Numeric input field with increment and decrement buttons");
  });
  legacy_pre_effect_reset();
  init();
  var div = root83();
  toggle_class(div, "bx--form-item", true);
  var div_1 = child(div);
  var node = child(div_1);
  {
    var consequent = ($$anchor2) => {
      var label_1 = root_162();
      var node_1 = child(label_1);
      slot(node_1, $$props, "label", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, label()));
        append($$anchor3, text2);
      });
      reset(label_1);
      template_effect(() => {
        set_attribute(label_1, "for", id());
        toggle_class(label_1, "bx--label", true);
        toggle_class(label_1, "bx--label--disabled", disabled());
        toggle_class(label_1, "bx--visually-hidden", hideLabel());
      });
      append($$anchor2, label_1);
    };
    if_block(node, ($$render) => {
      if ($$slots.label || label()) $$render(consequent);
    });
  }
  var div_2 = sibling(node, 2);
  toggle_class(div_2, "bx--number__input-wrapper", true);
  var input = child(div_2);
  remove_input_defaults(input);
  let attributes;
  bind_this(input, ($$value) => ref($$value), () => ref());
  var node_2 = sibling(input, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_3 = first_child(fragment_1);
      EditOff_default(node_3, { class: "bx--text-input__readonly-icon" });
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = root_48();
      var node_4 = first_child(fragment_2);
      {
        var consequent_2 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_5 = first_child(fragment_3);
          WarningFilled_default(node_5, { class: "bx--number__invalid" });
          append($$anchor3, fragment_3);
        };
        if_block(node_4, ($$render) => {
          if (invalid()) $$render(consequent_2);
        });
      }
      var node_6 = sibling(node_4, 2);
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_7 = first_child(fragment_4);
          WarningAltFilled_default(node_7, {
            class: "bx--number__invalid bx--number__invalid--warning"
          });
          append($$anchor3, fragment_4);
        };
        if_block(node_6, ($$render) => {
          if (!invalid() && warn()) $$render(consequent_3);
        });
      }
      append($$anchor2, fragment_2);
    };
    if_block(node_2, ($$render) => {
      if (readonly2()) $$render(consequent_1);
      else $$render(alternate, false);
    });
  }
  var node_8 = sibling(node_2, 2);
  {
    var consequent_4 = ($$anchor2) => {
      var div_3 = root_77();
      toggle_class(div_3, "bx--number__controls", true);
      var button = child(div_3);
      var node_9 = child(button);
      Subtract_default(node_9, { class: "down-icon" });
      reset(button);
      var div_4 = sibling(button, 2);
      toggle_class(div_4, "bx--number__rule-divider", true);
      var button_1 = sibling(div_4, 2);
      var node_10 = child(button_1);
      Add_default(node_10, { class: "up-icon" });
      reset(button_1);
      var div_5 = sibling(button_1, 2);
      toggle_class(div_5, "bx--number__rule-divider", true);
      reset(div_3);
      template_effect(() => {
        set_attribute(button, "title", get(decrementLabel) || iconDescription());
        set_attribute(button, "aria-label", get(decrementLabel) || iconDescription());
        button.disabled = disabled();
        toggle_class(button, "bx--number__control-btn", true);
        toggle_class(button, "down-icon", true);
        set_attribute(button_1, "title", get(incrementLabel) || iconDescription());
        set_attribute(button_1, "aria-label", get(incrementLabel) || iconDescription());
        button_1.disabled = disabled();
        toggle_class(button_1, "bx--number__control-btn", true);
        toggle_class(button_1, "up-icon", true);
      });
      event2("click", button, () => {
        updateValue(false);
      });
      event2("click", button_1, () => {
        updateValue(true);
      });
      append($$anchor2, div_3);
    };
    if_block(node_8, ($$render) => {
      if (!hideSteppers()) $$render(consequent_4);
    });
  }
  reset(div_2);
  var node_11 = sibling(div_2, 2);
  {
    var consequent_5 = ($$anchor2) => {
      var div_6 = root_84();
      toggle_class(div_6, "bx--form__helper-text", true);
      var text_1 = child(div_6, true);
      reset(div_6);
      template_effect(() => {
        toggle_class(div_6, "bx--form__helper-text--disabled", disabled());
        set_text(text_1, helperText());
      });
      append($$anchor2, div_6);
    };
    if_block(node_11, ($$render) => {
      if (!get(error) && !warn() && helperText()) $$render(consequent_5);
    });
  }
  var node_12 = sibling(node_11, 2);
  {
    var consequent_6 = ($$anchor2) => {
      var div_7 = root_92();
      var text_2 = child(div_7, true);
      reset(div_7);
      template_effect(() => {
        set_attribute(div_7, "id", get(errorId));
        toggle_class(div_7, "bx--form-requirement", true);
        set_text(text_2, invalidText());
      });
      append($$anchor2, div_7);
    };
    if_block(node_12, ($$render) => {
      if (get(error)) $$render(consequent_6);
    });
  }
  var node_13 = sibling(node_12, 2);
  {
    var consequent_7 = ($$anchor2) => {
      var div_8 = root_104();
      var text_3 = child(div_8, true);
      reset(div_8);
      template_effect(() => {
        set_attribute(div_8, "id", get(errorId));
        toggle_class(div_8, "bx--form-requirement", true);
        set_text(text_3, warnText());
      });
      append($$anchor2, div_8);
    };
    if_block(node_13, ($$render) => {
      if (!get(error) && warn()) $$render(consequent_7);
    });
  }
  reset(div_1);
  reset(div);
  template_effect(() => {
    set_attribute(div_1, "data-invalid", get(error) || void 0);
    toggle_class(div_1, "bx--number", true);
    toggle_class(div_1, "bx--number--helpertext", true);
    toggle_class(div_1, "bx--number--readonly", readonly2());
    toggle_class(div_1, "bx--number--light", light());
    toggle_class(div_1, "bx--number--nolabel", hideLabel());
    toggle_class(div_1, "bx--number--nosteppers", hideSteppers());
    toggle_class(div_1, "bx--number--sm", strict_equals(size(), "sm"));
    toggle_class(div_1, "bx--number--xl", strict_equals(size(), "xl"));
    toggle_class(div_2, "bx--number__input-wrapper--warning", !invalid() && warn());
    attributes = set_attributes(input, attributes, {
      type: "number",
      pattern: "[0-9]*",
      "aria-describedby": get(errorId),
      "data-invalid": get(error) || void 0,
      "aria-invalid": get(error) || void 0,
      "aria-label": label() ? void 0 : get(ariaLabel),
      disabled: disabled(),
      id: id(),
      name: name(),
      max: max(),
      min: min(),
      step: step(),
      value: value() ?? "",
      readonly: readonly2(),
      ...$$restProps
    });
  });
  event2("change", input, onChange);
  event2("input", input, onInput);
  event2("keydown", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keyup", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("focus", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("blur", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("paste", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  bind_prop($$props, "translationIds", translationIds);
  return pop({
    get translationIds() {
      return translationIds;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  NumberInput = hmr(NumberInput, () => NumberInput[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = NumberInput[HMR].source;
    set(NumberInput[HMR].source, module.default[HMR].original);
  });
}
var NumberInput_default = NumberInput;
mark_module_end(NumberInput);

// node_modules/carbon-components-svelte/src/NumberInput/NumberInputSkeleton.svelte
mark_module_start();
NumberInputSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/NumberInput/NumberInputSkeleton.svelte";
var root_163 = add_locations(template(`<span></span>`), NumberInputSkeleton[FILENAME], [[17, 4]]);
var root84 = add_locations(template(`<div><!> <div></div></div>`), NumberInputSkeleton[FILENAME], [[8, 0, [[19, 2]]]]);
function NumberInputSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["hideLabel"]);
  push($$props, false, NumberInputSkeleton);
  let hideLabel = prop($$props, "hideLabel", 8, false);
  var div = root84();
  let attributes;
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var span = root_163();
      toggle_class(span, "bx--label", true);
      toggle_class(span, "bx--skeleton", true);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if (!hideLabel()) $$render(consequent);
    });
  }
  var div_1 = sibling(node, 2);
  toggle_class(div_1, "bx--number", true);
  toggle_class(div_1, "bx--skeleton", true);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--form-item", true);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  NumberInputSkeleton = hmr(NumberInputSkeleton, () => NumberInputSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = NumberInputSkeleton[HMR].source;
    set(NumberInputSkeleton[HMR].source, module.default[HMR].original);
  });
}
var NumberInputSkeleton_default = NumberInputSkeleton;
mark_module_end(NumberInputSkeleton);

// node_modules/carbon-components-svelte/src/OrderedList/OrderedList.svelte
mark_module_start();
OrderedList[FILENAME] = "node_modules/carbon-components-svelte/src/OrderedList/OrderedList.svelte";
var root85 = add_locations(template(`<ol><!></ol>`), OrderedList[FILENAME], [[14, 0]]);
function OrderedList($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["nested", "native", "expressive"]);
  push($$props, false, OrderedList);
  let nested = prop($$props, "nested", 8, false);
  let native = prop($$props, "native", 8, false);
  let expressive = prop($$props, "expressive", 8, false);
  var ol = root85();
  let attributes;
  var node = child(ol);
  slot(node, $$props, "default", {}, null);
  reset(ol);
  template_effect(() => {
    attributes = set_attributes(ol, attributes, { ...$$restProps });
    toggle_class(ol, "bx--list--ordered", !native());
    toggle_class(ol, "bx--list--ordered--native", native());
    toggle_class(ol, "bx--list--nested", nested());
    toggle_class(ol, "bx--list--expressive", expressive());
  });
  event2("click", ol, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", ol, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", ol, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", ol, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, ol);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  OrderedList = hmr(OrderedList, () => OrderedList[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OrderedList[HMR].source;
    set(OrderedList[HMR].source, module.default[HMR].original);
  });
}
var OrderedList_default = OrderedList;
mark_module_end(OrderedList);

// node_modules/carbon-components-svelte/src/icons/CaretLeft.svelte
mark_module_start();
CaretLeft[FILENAME] = "node_modules/carbon-components-svelte/src/icons/CaretLeft.svelte";
var root_164 = add_locations(ns_template(`<title> </title>`), CaretLeft[FILENAME], [[24, 13]]);
var root86 = add_locations(ns_template(`<svg><!><path d="M20 24L10 16 20 8z"></path></svg>`), CaretLeft[FILENAME], [[14, 0, [[25, 2]]]]);
function CaretLeft($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, CaretLeft);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root86();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_164();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next();
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CaretLeft = hmr(CaretLeft, () => CaretLeft[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretLeft[HMR].source;
    set(CaretLeft[HMR].source, module.default[HMR].original);
  });
}
var CaretLeft_default = CaretLeft;
mark_module_end(CaretLeft);

// node_modules/carbon-components-svelte/src/Select/Select.svelte
mark_module_start();
Select[FILENAME] = "node_modules/carbon-components-svelte/src/Select/Select.svelte";
var root_165 = add_locations(template(`<label><!></label>`), Select[FILENAME], [[137, 6]]);
var root_57 = add_locations(template(`<div> </div>`), Select[FILENAME], [[179, 10]]);
var root_69 = add_locations(template(`<div> </div>`), Select[FILENAME], [[185, 8]]);
var root_312 = add_locations(template(`<div><div><select><!></select> <!> <!></div> <!></div> <!>`, 1), Select[FILENAME], [
  [
    149,
    6,
    [[150, 8, [[154, 10]]]]
  ]
]);
var root_105 = add_locations(template(`<div> </div>`), Select[FILENAME], [[228, 8]]);
var root_1112 = add_locations(template(`<div> </div>`), Select[FILENAME], [[236, 8]]);
var root_1211 = add_locations(template(`<div> </div>`), Select[FILENAME], [[241, 8]]);
var root_78 = add_locations(template(`<div><select><!></select> <!> <!> <!></div> <!> <!> <!>`, 1), Select[FILENAME], [[194, 6, [[198, 8]]]]);
var root87 = add_locations(template(`<div><div><!> <!> <!></div></div>`), Select[FILENAME], [[127, 0, [[128, 2]]]]);
function Select($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "selected",
    "size",
    "inline",
    "light",
    "disabled",
    "id",
    "name",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "helperText",
    "noLabel",
    "labelText",
    "hideLabel",
    "ref",
    "required"
  ]);
  push($$props, false, Select);
  const [$$stores, $$cleanup] = setup_stores();
  const $defaultValue = () => (validate_store(defaultValue, "defaultValue"), store_get(defaultValue, "$defaultValue", $$stores));
  const $defaultSelectId = () => (validate_store(defaultSelectId, "defaultSelectId"), store_get(defaultSelectId, "$defaultSelectId", $$stores));
  const $itemTypesByValue = () => (validate_store(itemTypesByValue, "itemTypesByValue"), store_get(itemTypesByValue, "$itemTypesByValue", $$stores));
  const $selectedValue = () => (validate_store(selectedValue, "selectedValue"), store_get(selectedValue, "$selectedValue", $$stores));
  const errorId = mutable_state();
  let selected = prop($$props, "selected", 12, void 0);
  let size = prop($$props, "size", 8, void 0);
  let inline = prop($$props, "inline", 8, false);
  let light = prop($$props, "light", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let name = prop($$props, "name", 8, void 0);
  let invalid = prop($$props, "invalid", 8, false);
  let invalidText = prop($$props, "invalidText", 8, "");
  let warn = prop($$props, "warn", 8, false);
  let warnText = prop($$props, "warnText", 8, "");
  let helperText = prop($$props, "helperText", 8, "");
  let noLabel = prop($$props, "noLabel", 8, false);
  let labelText = prop($$props, "labelText", 8, "");
  let hideLabel = prop($$props, "hideLabel", 8, false);
  let ref = prop($$props, "ref", 12, null);
  let required = prop($$props, "required", 8, false);
  const dispatch = createEventDispatcher();
  const selectedValue = writable(selected());
  const defaultSelectId = writable(null);
  const defaultValue = writable(null);
  const itemTypesByValue = writable({});
  setContext("Select", {
    selectedValue,
    setDefaultValue: (id2, value) => {
      if (strict_equals($defaultValue(), null)) {
        defaultSelectId.set(id2);
        defaultValue.set(value);
      } else {
        if (strict_equals($defaultSelectId(), id2)) {
          selectedValue.set(value);
        }
      }
      itemTypesByValue.update((types) => ({ ...types, [value]: typeof value }));
    }
  });
  const handleChange = ({ target }) => {
    let value = target.value;
    if (strict_equals($itemTypesByValue()[value], "number")) {
      value = Number(value);
    }
    selectedValue.set(value);
  };
  let prevSelected = void 0;
  afterUpdate(() => {
    selected($selectedValue());
    if (strict_equals(prevSelected, void 0, false) && strict_equals(selected(), prevSelected, false)) {
      dispatch("update", $selectedValue());
    }
    prevSelected = selected();
  });
  legacy_pre_effect(() => deep_read_state(id()), () => {
    set(errorId, `error-${id()}`);
  });
  legacy_pre_effect(
    () => (deep_read_state(selected()), $defaultValue()),
    () => {
      selectedValue.set(selected() ?? $defaultValue());
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root87();
  let attributes;
  var div_1 = child(div);
  toggle_class(div_1, "bx--select", true);
  var node = child(div_1);
  {
    var consequent = ($$anchor2) => {
      var label = root_165();
      var node_1 = child(label);
      slot(node_1, $$props, "labelText", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, labelText()));
        append($$anchor3, text2);
      });
      reset(label);
      template_effect(() => {
        set_attribute(label, "for", id());
        toggle_class(label, "bx--label", true);
        toggle_class(label, "bx--visually-hidden", hideLabel());
        toggle_class(label, "bx--label--disabled", disabled());
      });
      append($$anchor2, label);
    };
    if_block(node, ($$render) => {
      if (!noLabel()) $$render(consequent);
    });
  }
  var node_2 = sibling(node, 2);
  {
    var consequent_4 = ($$anchor2) => {
      var fragment_1 = root_312();
      var div_2 = first_child(fragment_1);
      toggle_class(div_2, "bx--select-input--inline__wrapper", true);
      var div_3 = child(div_2);
      var select = child(div_3);
      var node_3 = child(select);
      slot(node_3, $$props, "default", {}, null);
      reset(select);
      bind_this(select, ($$value) => ref($$value), () => ref());
      var node_4 = sibling(select, 2);
      ChevronDown_default(node_4, { class: "bx--select__arrow" });
      var node_5 = sibling(node_4, 2);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_6 = first_child(fragment_2);
          WarningFilled_default(node_6, { class: "bx--select__invalid-icon" });
          append($$anchor3, fragment_2);
        };
        if_block(node_5, ($$render) => {
          if (invalid()) $$render(consequent_1);
        });
      }
      reset(div_3);
      var node_7 = sibling(div_3, 2);
      {
        var consequent_2 = ($$anchor3) => {
          var div_4 = root_57();
          var text_1 = child(div_4, true);
          reset(div_4);
          template_effect(() => {
            set_attribute(div_4, "id", get(errorId));
            toggle_class(div_4, "bx--form-requirement", true);
            set_text(text_1, invalidText());
          });
          append($$anchor3, div_4);
        };
        if_block(node_7, ($$render) => {
          if (invalid()) $$render(consequent_2);
        });
      }
      reset(div_2);
      var node_8 = sibling(div_2, 2);
      {
        var consequent_3 = ($$anchor3) => {
          var div_5 = root_69();
          toggle_class(div_5, "bx--form__helper-text", true);
          var text_2 = child(div_5, true);
          reset(div_5);
          template_effect(() => {
            toggle_class(div_5, "bx--form__helper-text--disabled", disabled());
            set_text(text_2, helperText());
          });
          append($$anchor3, div_5);
        };
        if_block(node_8, ($$render) => {
          if (!invalid() && !warn() && helperText()) $$render(consequent_3);
        });
      }
      template_effect(() => {
        set_attribute(div_3, "data-invalid", invalid() || void 0);
        toggle_class(div_3, "bx--select-input__wrapper", true);
        set_attribute(select, "aria-describedby", invalid() ? get(errorId) : void 0);
        set_attribute(select, "aria-invalid", invalid() || void 0);
        select.disabled = disabled() || void 0;
        select.required = required() || void 0;
        set_attribute(select, "id", id());
        set_attribute(select, "name", name());
        toggle_class(select, "bx--select-input", true);
        toggle_class(select, "bx--select-input--sm", strict_equals(size(), "sm"));
        toggle_class(select, "bx--select-input--xl", strict_equals(size(), "xl"));
      });
      event2("change", select, handleChange);
      event2("change", select, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("input", select, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("focus", select, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("blur", select, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, fragment_1);
    };
    if_block(node_2, ($$render) => {
      if (inline()) $$render(consequent_4);
    });
  }
  var node_9 = sibling(node_2, 2);
  {
    var consequent_10 = ($$anchor2) => {
      var fragment_3 = root_78();
      var div_6 = first_child(fragment_3);
      var select_1 = child(div_6);
      var node_10 = child(select_1);
      slot(node_10, $$props, "default", {}, null);
      reset(select_1);
      bind_this(select_1, ($$value) => ref($$value), () => ref());
      var node_11 = sibling(select_1, 2);
      ChevronDown_default(node_11, { class: "bx--select__arrow" });
      var node_12 = sibling(node_11, 2);
      {
        var consequent_5 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_13 = first_child(fragment_4);
          WarningFilled_default(node_13, { class: "bx--select__invalid-icon" });
          append($$anchor3, fragment_4);
        };
        if_block(node_12, ($$render) => {
          if (invalid()) $$render(consequent_5);
        });
      }
      var node_14 = sibling(node_12, 2);
      {
        var consequent_6 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_15 = first_child(fragment_5);
          WarningAltFilled_default(node_15, {
            class: "bx--select__invalid-icon bx--select__invalid-icon--warning"
          });
          append($$anchor3, fragment_5);
        };
        if_block(node_14, ($$render) => {
          if (!invalid() && warn()) $$render(consequent_6);
        });
      }
      reset(div_6);
      var node_16 = sibling(div_6, 2);
      {
        var consequent_7 = ($$anchor3) => {
          var div_7 = root_105();
          toggle_class(div_7, "bx--form__helper-text", true);
          var text_3 = child(div_7, true);
          reset(div_7);
          template_effect(() => {
            toggle_class(div_7, "bx--form__helper-text--disabled", disabled());
            set_text(text_3, helperText());
          });
          append($$anchor3, div_7);
        };
        if_block(node_16, ($$render) => {
          if (!invalid() && helperText()) $$render(consequent_7);
        });
      }
      var node_17 = sibling(node_16, 2);
      {
        var consequent_8 = ($$anchor3) => {
          var div_8 = root_1112();
          var text_4 = child(div_8, true);
          reset(div_8);
          template_effect(() => {
            set_attribute(div_8, "id", get(errorId));
            toggle_class(div_8, "bx--form-requirement", true);
            set_text(text_4, invalidText());
          });
          append($$anchor3, div_8);
        };
        if_block(node_17, ($$render) => {
          if (invalid()) $$render(consequent_8);
        });
      }
      var node_18 = sibling(node_17, 2);
      {
        var consequent_9 = ($$anchor3) => {
          var div_9 = root_1211();
          var text_5 = child(div_9, true);
          reset(div_9);
          template_effect(() => {
            set_attribute(div_9, "id", get(errorId));
            toggle_class(div_9, "bx--form-requirement", true);
            set_text(text_5, warnText());
          });
          append($$anchor3, div_9);
        };
        if_block(node_18, ($$render) => {
          if (!invalid() && warn()) $$render(consequent_9);
        });
      }
      template_effect(() => {
        set_attribute(div_6, "data-invalid", invalid() || void 0);
        toggle_class(div_6, "bx--select-input__wrapper", true);
        set_attribute(select_1, "id", id());
        set_attribute(select_1, "name", name());
        set_attribute(select_1, "aria-describedby", invalid() ? get(errorId) : void 0);
        select_1.disabled = disabled() || void 0;
        select_1.required = required() || void 0;
        set_attribute(select_1, "aria-invalid", invalid() || void 0);
        toggle_class(select_1, "bx--select-input", true);
        toggle_class(select_1, "bx--select-input--sm", strict_equals(size(), "sm"));
        toggle_class(select_1, "bx--select-input--xl", strict_equals(size(), "xl"));
      });
      event2("change", select_1, handleChange);
      event2("change", select_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("input", select_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("focus", select_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("blur", select_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, fragment_3);
    };
    if_block(node_9, ($$render) => {
      if (!inline()) $$render(consequent_10);
    });
  }
  reset(div_1);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--form-item", true);
    toggle_class(div_1, "bx--select--inline", inline());
    toggle_class(div_1, "bx--select--light", light());
    toggle_class(div_1, "bx--select--invalid", invalid());
    toggle_class(div_1, "bx--select--disabled", disabled());
    toggle_class(div_1, "bx--select--warning", warn());
  });
  append($$anchor, div);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Select = hmr(Select, () => Select[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select[HMR].source;
    set(Select[HMR].source, module.default[HMR].original);
  });
}
var Select_default = Select;
mark_module_end(Select);

// node_modules/carbon-components-svelte/src/Select/SelectItem.svelte
mark_module_start();
SelectItem[FILENAME] = "node_modules/carbon-components-svelte/src/Select/SelectItem.svelte";
var root88 = add_locations(template(`<option> </option>`), SelectItem[FILENAME], [[49, 0]]);
function SelectItem($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, SelectItem);
  let value = prop($$props, "value", 8, "");
  let text2 = prop($$props, "text", 8, "");
  let hidden = prop($$props, "hidden", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let className = prop($$props, "class", 8, void 0);
  let style = prop($$props, "style", 8, void 0);
  const id = "ccs-" + Math.random().toString(36);
  const ctx = getContext("Select") || getContext("TimePickerSelect");
  let selected = mutable_state(false);
  const unsubscribe = ctx.selectedValue.subscribe((currentValue) => {
    set(selected, strict_equals(currentValue, value()));
  });
  onMount(() => {
    return () => unsubscribe();
  });
  legacy_pre_effect(() => deep_read_state(value()), () => {
    var _a;
    (_a = ctx == null ? void 0 : ctx.setDefaultValue) == null ? void 0 : _a.call(ctx, id, value());
  });
  legacy_pre_effect_reset();
  init();
  var option = root88();
  var option_value = {};
  var text_1 = child(option, true);
  reset(option);
  template_effect(() => {
    if (option_value !== (option_value = value())) {
      option.value = null == (option.__value = value()) ? "" : value();
    }
    option.disabled = disabled();
    option.hidden = hidden();
    set_selected(option, get(selected));
    set_class(option, className());
    set_attribute(option, "style", style());
    toggle_class(option, "bx--select-option", true);
    set_text(text_1, text2() || value());
  });
  append($$anchor, option);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SelectItem = hmr(SelectItem, () => SelectItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SelectItem[HMR].source;
    set(SelectItem[HMR].source, module.default[HMR].original);
  });
}
var SelectItem_default = SelectItem;
mark_module_end(SelectItem);

// node_modules/carbon-components-svelte/src/Pagination/Pagination.svelte
mark_module_start();
Pagination[FILENAME] = "node_modules/carbon-components-svelte/src/Pagination/Pagination.svelte";
var root_166 = add_locations(template(`<label> </label> <!>`, 1), Pagination[FILENAME], [[100, 6]]);
var root_610 = add_locations(template(`<!> <span><!></span>`, 1), Pagination[FILENAME], [[152, 6]]);
var root89 = add_locations(template(`<div><div><!> <span><!></span></div> <div><!> <!> <!></div></div>`), Pagination[FILENAME], [
  [
    97,
    0,
    [[98, 2, [[123, 4]]], [135, 2]]
  ]
]);
function Pagination($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "page",
    "totalItems",
    "disabled",
    "forwardText",
    "backwardText",
    "itemsPerPageText",
    "itemText",
    "itemRangeText",
    "pageInputDisabled",
    "pageSizeInputDisabled",
    "pageSize",
    "pageSizes",
    "pagesUnknown",
    "pageText",
    "pageRangeText",
    "id"
  ]);
  push($$props, false, Pagination);
  const totalPages = mutable_state();
  const selectItems = mutable_state();
  const backButtonDisabled = mutable_state();
  const forwardButtonDisabled = mutable_state();
  let page = prop($$props, "page", 12, 1);
  let totalItems = prop($$props, "totalItems", 8, 0);
  let disabled = prop($$props, "disabled", 8, false);
  let forwardText = prop($$props, "forwardText", 8, "Next page");
  let backwardText = prop($$props, "backwardText", 8, "Previous page");
  let itemsPerPageText = prop($$props, "itemsPerPageText", 8, "Items per page:");
  let itemText = prop($$props, "itemText", 8, (min, max) => `${min}${max} item${strict_equals(max, 1) ? "" : "s"}`);
  let itemRangeText = prop($$props, "itemRangeText", 8, (min, max, total) => `${min}${max} of ${total} item${strict_equals(max, 1) ? "" : "s"}`);
  let pageInputDisabled = prop($$props, "pageInputDisabled", 8, false);
  let pageSizeInputDisabled = prop($$props, "pageSizeInputDisabled", 8, false);
  let pageSize = prop($$props, "pageSize", 12, 10);
  let pageSizes = prop($$props, "pageSizes", 24, () => [10]);
  let pagesUnknown = prop($$props, "pagesUnknown", 8, false);
  let pageText = prop($$props, "pageText", 8, (page2) => `page ${page2}`);
  let pageRangeText = prop($$props, "pageRangeText", 8, (current, total) => `of ${total} page${strict_equals(total, 1) ? "" : "s"}`);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  const dispatch = createEventDispatcher();
  afterUpdate(() => {
    if (page() > get(totalPages)) {
      page(get(totalPages));
    }
  });
  legacy_pre_effect(
    () => (deep_read_state(pageSize()), deep_read_state(page())),
    () => {
      dispatch("update", { pageSize: pageSize(), page: page() });
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(totalItems()), deep_read_state(pageSize())),
    () => {
      set(totalPages, Math.max(Math.ceil(totalItems() / pageSize()), 1));
    }
  );
  legacy_pre_effect(() => get(totalPages), () => {
    set(selectItems, Array.from({ length: get(totalPages) }, (_, i) => i));
  });
  legacy_pre_effect(
    () => (deep_read_state(disabled()), deep_read_state(page())),
    () => {
      set(backButtonDisabled, disabled() || strict_equals(page(), 1));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(disabled()), deep_read_state(page()), get(totalPages)),
    () => {
      set(forwardButtonDisabled, disabled() || strict_equals(page(), get(totalPages)));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root89();
  let attributes;
  var div_1 = child(div);
  toggle_class(div_1, "bx--pagination__left", true);
  var node = child(div_1);
  {
    var consequent = ($$anchor2) => {
      var fragment = root_166();
      var label = first_child(fragment);
      var text2 = child(label, true);
      reset(label);
      var node_1 = sibling(label, 2);
      {
        add_owner_effect(pageSize, Select_default);
        Select_default(node_1, {
          get id() {
            return `bx--pagination-select-${id() ?? ""}`;
          },
          class: "bx--select__item-count",
          hideLabel: true,
          noLabel: true,
          inline: true,
          get selected() {
            return pageSize();
          },
          set selected($$value) {
            pageSize($$value);
          },
          $$events: {
            change: () => {
              dispatch("change", { pageSize: pageSize() });
            }
          },
          children: wrap_snippet(Pagination, ($$anchor3, $$slotProps) => {
            var fragment_1 = comment();
            var node_2 = first_child(fragment_1);
            validate_each_keys(pageSizes, (size) => size);
            each(node_2, 3, pageSizes, (size) => size, ($$anchor4, size) => {
              var fragment_2 = comment();
              var node_3 = first_child(fragment_2);
              const expression = derived_safe_equal(() => get(size).toString());
              SelectItem_default(node_3, {
                get value() {
                  return get(size);
                },
                get text() {
                  return get(expression);
                }
              });
              append($$anchor4, fragment_2);
            });
            append($$anchor3, fragment_1);
          }),
          $$slots: { default: true },
          $$legacy: true
        });
      }
      template_effect(() => {
        set_attribute(label, "id", `bx--pagination-select-${id() ?? ""}-count-label`);
        set_attribute(label, "for", `bx--pagination-select-${id() ?? ""}`);
        toggle_class(label, "bx--pagination__text", true);
        set_text(text2, itemsPerPageText());
      });
      append($$anchor2, fragment);
    };
    if_block(node, ($$render) => {
      if (!pageSizeInputDisabled()) $$render(consequent);
    });
  }
  var span = sibling(node, 2);
  var node_4 = child(span);
  {
    var consequent_1 = ($$anchor2) => {
      var text_1 = text();
      template_effect(
        ($0) => set_text(text_1, $0),
        [
          () => itemText()(pageSize() * (page() - 1) + 1, page() * pageSize())
        ],
        derived_safe_equal
      );
      append($$anchor2, text_1);
    };
    var alternate = ($$anchor2) => {
      var text_2 = text();
      template_effect(
        ($0) => set_text(text_2, $0),
        [
          () => itemRangeText()(Math.min(pageSize() * (page() - 1) + 1, totalItems()), Math.min(page() * pageSize(), totalItems()), totalItems())
        ],
        derived_safe_equal
      );
      append($$anchor2, text_2);
    };
    if_block(node_4, ($$render) => {
      if (pagesUnknown()) $$render(consequent_1);
      else $$render(alternate, false);
    });
  }
  reset(span);
  reset(div_1);
  var div_2 = sibling(div_1, 2);
  toggle_class(div_2, "bx--pagination__right", true);
  var node_5 = child(div_2);
  {
    var consequent_3 = ($$anchor2) => {
      var fragment_5 = root_610();
      var node_6 = first_child(fragment_5);
      const expression_1 = derived_safe_equal(() => id() + 2);
      {
        add_owner_effect(page, Select_default);
        Select_default(node_6, {
          get id() {
            return `bx--pagination-select-${get(expression_1) ?? ""}`;
          },
          class: "bx--select__page-number",
          get labelText() {
            return `Page number, of ${get(totalPages) ?? ""} pages`;
          },
          inline: true,
          hideLabel: true,
          get selected() {
            return page();
          },
          set selected($$value) {
            page($$value);
          },
          $$events: {
            change: () => {
              dispatch("change", { page: page() });
            }
          },
          children: wrap_snippet(Pagination, ($$anchor3, $$slotProps) => {
            var fragment_6 = comment();
            var node_7 = first_child(fragment_6);
            validate_each_keys(() => get(selectItems), (size) => size);
            each(node_7, 3, () => get(selectItems), (size) => size, ($$anchor4, size) => {
              var fragment_7 = comment();
              var node_8 = first_child(fragment_7);
              const expression_2 = derived_safe_equal(() => get(size) + 1);
              const expression_3 = derived_safe_equal(() => (get(size) + 1).toString());
              SelectItem_default(node_8, {
                get value() {
                  return get(expression_2);
                },
                get text() {
                  return get(expression_3);
                }
              });
              append($$anchor4, fragment_7);
            });
            append($$anchor3, fragment_6);
          }),
          $$slots: { default: true },
          $$legacy: true
        });
      }
      var span_1 = sibling(node_6, 2);
      toggle_class(span_1, "bx--pagination__text", true);
      var node_9 = child(span_1);
      {
        var consequent_2 = ($$anchor3) => {
          var text_3 = text();
          template_effect(($0) => set_text(text_3, $0), [() => pageText()(page())], derived_safe_equal);
          append($$anchor3, text_3);
        };
        var alternate_1 = ($$anchor3) => {
          var text_4 = text();
          template_effect(
            ($0) => set_text(text_4, $0),
            [
              () => pageRangeText()(page(), get(totalPages))
            ],
            derived_safe_equal
          );
          append($$anchor3, text_4);
        };
        if_block(node_9, ($$render) => {
          if (pagesUnknown()) $$render(consequent_2);
          else $$render(alternate_1, false);
        });
      }
      reset(span_1);
      append($$anchor2, fragment_5);
    };
    if_block(node_5, ($$render) => {
      if (!pageInputDisabled()) $$render(consequent_3);
    });
  }
  var node_10 = sibling(node_5, 2);
  const expression_4 = derived_safe_equal(() => get(backButtonDisabled) ? "bx--pagination__button--no-index" : "");
  Button_default(node_10, {
    kind: "ghost",
    tooltipAlignment: "center",
    tooltipPosition: "top",
    icon: CaretLeft_default,
    get iconDescription() {
      return backwardText();
    },
    get disabled() {
      return get(backButtonDisabled);
    },
    get class() {
      return `bx--pagination__button bx--pagination__button--backward ${get(expression_4) ?? ""}`;
    },
    $$events: {
      click: () => {
        update_prop(page, -1);
        dispatch("click:button--previous", { page: page() });
        dispatch("change", { page: page() });
      }
    }
  });
  var node_11 = sibling(node_10, 2);
  const expression_5 = derived_safe_equal(() => get(forwardButtonDisabled) ? "bx--pagination__button--no-index" : "");
  Button_default(node_11, {
    kind: "ghost",
    tooltipAlignment: "end",
    tooltipPosition: "top",
    icon: CaretRight_default,
    get iconDescription() {
      return forwardText();
    },
    get disabled() {
      return get(forwardButtonDisabled);
    },
    get class() {
      return `bx--pagination__button bx--pagination__button--forward ${get(expression_5) ?? ""}`;
    },
    $$events: {
      click: () => {
        update_prop(page);
        dispatch("click:button--next", { page: page() });
        dispatch("change", { page: page() });
      }
    }
  });
  reset(div_2);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { id: id(), ...$$restProps });
    toggle_class(div, "bx--pagination", true);
    toggle_class(span, "bx--pagination__text", !pageSizeInputDisabled());
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pagination = hmr(Pagination, () => Pagination[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pagination[HMR].source;
    set(Pagination[HMR].source, module.default[HMR].original);
  });
}
var Pagination_default = Pagination;
mark_module_end(Pagination);

// node_modules/carbon-components-svelte/src/Pagination/PaginationSkeleton.svelte
mark_module_start();
PaginationSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/Pagination/PaginationSkeleton.svelte";
var root90 = add_locations(template(`<div><div><!> <!> <!></div> <div><!></div></div>`), PaginationSkeleton[FILENAME], [[7, 0, [[16, 2], [21, 2]]]]);
function PaginationSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, PaginationSkeleton);
  var div = root90();
  let attributes;
  var div_1 = child(div);
  toggle_class(div_1, "bx--pagination__left", true);
  var node = child(div_1);
  SkeletonText_default(node, { width: "70px" });
  var node_1 = sibling(node, 2);
  SkeletonText_default(node_1, { width: "35px" });
  var node_2 = sibling(node_1, 2);
  SkeletonText_default(node_2, { width: "105px" });
  reset(div_1);
  var div_2 = sibling(div_1, 2);
  toggle_class(div_2, "bx--pagination__right", true);
  toggle_class(div_2, "bx--pagination--inline", true);
  var node_3 = child(div_2);
  SkeletonText_default(node_3, { width: "70px" });
  reset(div_2);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--pagination", true);
    toggle_class(div, "bx--skeleton", true);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PaginationSkeleton = hmr(PaginationSkeleton, () => PaginationSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PaginationSkeleton[HMR].source;
    set(PaginationSkeleton[HMR].source, module.default[HMR].original);
  });
}
var PaginationSkeleton_default = PaginationSkeleton;
mark_module_end(PaginationSkeleton);

// node_modules/carbon-components-svelte/src/PaginationNav/PaginationItem.svelte
mark_module_start();
PaginationItem[FILENAME] = "node_modules/carbon-components-svelte/src/PaginationNav/PaginationItem.svelte";
var root91 = add_locations(template(`<li><button type="button"><span><!></span> </button></li>`), PaginationItem[FILENAME], [
  [9, 0, [[10, 2, [[18, 4]]]]]
]);
function PaginationItem($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, PaginationItem);
  let page = prop($$props, "page", 8, 1);
  let active = prop($$props, "active", 8, false);
  var li = root91();
  toggle_class(li, "bx--pagination-nav__list-item", true);
  var button = child(li);
  var span = child(button);
  toggle_class(span, "bx--pagination-nav__accessibility-label", true);
  var node = child(span);
  slot(node, $$props, "default", {}, null);
  reset(span);
  var text2 = sibling(span);
  reset(button);
  reset(li);
  template_effect(() => {
    set_attribute(button, "data-page", page());
    set_attribute(button, "aria-current", active() ? "page" : void 0);
    toggle_class(button, "bx--pagination-nav__page", true);
    toggle_class(button, "bx--pagination-nav__page--active", active());
    set_text(text2, ` ${page() ?? ""}`);
  });
  event2("click", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, li);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PaginationItem = hmr(PaginationItem, () => PaginationItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PaginationItem[HMR].source;
    set(PaginationItem[HMR].source, module.default[HMR].original);
  });
}
var PaginationItem_default = PaginationItem;
mark_module_end(PaginationItem);

// node_modules/carbon-components-svelte/src/PaginationNav/PaginationOverflow.svelte
mark_module_start();
PaginationOverflow[FILENAME] = "node_modules/carbon-components-svelte/src/PaginationNav/PaginationOverflow.svelte";
var root_227 = add_locations(template(`<option> </option>`), PaginationOverflow[FILENAME], [[37, 10]]);
var root_167 = add_locations(template(`<li><div><select aria-label="Select Page number"><option hidden></option><!></select> <div><!></div></div></li>`), PaginationOverflow[FILENAME], [
  [
    22,
    2,
    [
      [
        23,
        4,
        [[25, 6, [[35, 8]]], [42, 6]]
      ]
    ]
  ]
]);
function PaginationOverflow($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, PaginationOverflow);
  let fromIndex = prop($$props, "fromIndex", 8, 0);
  let count = prop($$props, "count", 8, 0);
  const dispatch = createEventDispatcher();
  let value = mutable_state("");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var li = root_167();
      toggle_class(li, "bx--pagination-nav__list-item", true);
      var div = child(li);
      toggle_class(div, "bx--pagination-nav__select", true);
      var select = child(div);
      init_select(select, () => get(value));
      var select_value;
      toggle_class(select, "bx--pagination-nav__page", true);
      toggle_class(select, "bx--pagination-nav__page--select", true);
      var option = child(select);
      option.value = null == (option.__value = "") ? "" : "";
      var node_1 = sibling(option);
      each(node_1, 1, () => Array.from({ length: count() }, (_, i) => i), index, ($$anchor3, i) => {
        var option_1 = root_227();
        var option_1_value = {};
        var text2 = child(option_1, true);
        reset(option_1);
        template_effect(() => {
          if (option_1_value !== (option_1_value = fromIndex() + get(i) + 1)) {
            option_1.value = null == (option_1.__value = fromIndex() + get(i) + 1) ? "" : fromIndex() + get(i) + 1;
          }
          set_attribute(option_1, "data-page", fromIndex() + get(i) + 1);
          set_text(text2, fromIndex() + get(i) + 1);
        });
        append($$anchor3, option_1);
      });
      reset(select);
      var div_1 = sibling(select, 2);
      toggle_class(div_1, "bx--pagination-nav__select-icon-wrapper", true);
      var node_2 = child(div_1);
      OverflowMenuHorizontal_default(node_2, { class: "bx--pagination-nav__select-icon" });
      reset(div_1);
      reset(div);
      reset(li);
      template_effect(() => {
        if (select_value !== (select_value = get(value))) {
          select.value = null == (select.__value = get(value)) ? "" : get(value), select_option(select, get(value));
        }
      });
      event2("change", select, ({ target }) => {
        set(value, "");
        dispatch("select", { index: Number(target.value) });
      });
      append($$anchor2, li);
    };
    var alternate = ($$anchor2) => {
      var fragment_1 = comment();
      var node_3 = first_child(fragment_1);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_4 = first_child(fragment_2);
          const expression = derived_safe_equal(() => fromIndex() + 1);
          PaginationItem_default(node_4, {
            get page() {
              return get(expression);
            },
            $$events: {
              click: () => {
                dispatch("select", { index: fromIndex() });
              }
            },
            children: wrap_snippet(PaginationOverflow, ($$anchor4, $$slotProps) => {
              next();
              var text_1 = text("Page");
              append($$anchor4, text_1);
            }),
            $$slots: { default: true }
          });
          append($$anchor3, fragment_2);
        };
        if_block(
          node_3,
          ($$render) => {
            if (strict_equals(count(), 1)) $$render(consequent_1);
          },
          true
        );
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (count() > 1) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PaginationOverflow = hmr(PaginationOverflow, () => PaginationOverflow[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PaginationOverflow[HMR].source;
    set(PaginationOverflow[HMR].source, module.default[HMR].original);
  });
}
var PaginationOverflow_default = PaginationOverflow;
mark_module_end(PaginationOverflow);

// node_modules/carbon-components-svelte/src/PaginationNav/PaginationNav.svelte
mark_module_start();
PaginationNav[FILENAME] = "node_modules/carbon-components-svelte/src/PaginationNav/PaginationNav.svelte";
var root92 = add_locations(template(`<nav><ul><li><!></li> <!> <!> <!> <!> <!> <li><!></li></ul> <div aria-live="polite" aria-atomic="true"> </div></nav>`), PaginationNav[FILENAME], [
  [
    79,
    0,
    [
      [80, 2, [[81, 4], [156, 4]]],
      [180, 2]
    ]
  ]
]);
function PaginationNav($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "page",
    "total",
    "shown",
    "loop",
    "forwardText",
    "backwardText",
    "tooltipPosition"
  ]);
  push($$props, false, PaginationNav);
  const fit = mutable_state();
  const startOffset = mutable_state();
  const items = mutable_state();
  let page = prop($$props, "page", 12, 1);
  let total = prop($$props, "total", 8, 10);
  let shown = prop($$props, "shown", 8, 10);
  let loop = prop($$props, "loop", 8, false);
  let forwardText = prop($$props, "forwardText", 8, "Next page");
  let backwardText = prop($$props, "backwardText", 8, "Previous page");
  let tooltipPosition = prop($$props, "tooltipPosition", 8, "bottom");
  const dispatch = createEventDispatcher();
  const MIN = 4;
  let front = mutable_state(0);
  let back = mutable_state(0);
  legacy_pre_effect(() => deep_read_state(shown()), () => {
    set(fit, shown() >= MIN ? shown() : MIN);
  });
  legacy_pre_effect(
    () => (get(fit), deep_read_state(page())),
    () => {
      set(startOffset, get(fit) <= MIN && page() > 1 ? 0 : 1);
    }
  );
  legacy_pre_effect(
    () => (get(fit), deep_read_state(total())),
    () => {
      if (get(fit) >= total()) {
        set(front, 0);
        set(back, 0);
      }
    }
  );
  legacy_pre_effect(
    () => (get(fit), deep_read_state(total()), get(front), deep_read_state(page()), get(back)),
    () => {
      if (get(fit) < total()) {
        const split = Math.ceil(get(fit) / 2) - 1;
        set(front, page() - split);
        set(back, total() - page() - (get(fit) - split) + 2);
        if (get(front) <= 1) {
          set(back, get(back) - (get(front) <= 0 ? Math.abs(get(front)) + 1 : 0));
          set(front, 0);
        }
        if (get(back) <= 1) {
          set(front, get(front) - (get(back) <= 0 ? Math.abs(get(back)) + 1 : 0));
          set(back, 0);
        }
      }
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(total()), get(startOffset), get(front), get(back)),
    () => {
      set(items, Array.from({ length: total() }).map((e, i) => i).slice(get(startOffset) + get(front), (get(back) + 1) * -1));
    }
  );
  legacy_pre_effect_reset();
  init();
  var nav = root92();
  let attributes;
  var ul = child(nav);
  toggle_class(ul, "bx--pagination-nav__list", true);
  var li = child(ul);
  toggle_class(li, "bx--pagination-nav__list-item", true);
  var node = child(li);
  const expression = derived_safe_equal(() => strict_equals(tooltipPosition(), "inside") ? "right" : strict_equals(tooltipPosition(), "outside") ? "left" : tooltipPosition());
  const expression_1 = derived_safe_equal(() => !loop() && strict_equals(page(), 1));
  Button_default(node, {
    kind: "ghost",
    tooltipAlignment: "center",
    get tooltipPosition() {
      return get(expression);
    },
    get iconDescription() {
      return backwardText();
    },
    get disabled() {
      return get(expression_1);
    },
    icon: CaretLeft_default,
    $$events: {
      click: () => {
        if (page() <= 1) {
          if (loop()) page(total());
        } else {
          update_prop(page, -1);
        }
        dispatch("click:button--previous", { page: page() });
        dispatch("change", { page: page() });
      }
    }
  });
  reset(li);
  var node_1 = sibling(li, 2);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_2 = first_child(fragment);
      const expression_2 = derived_safe_equal(() => strict_equals(page(), 1));
      PaginationItem_default(node_2, {
        page: 1,
        get active() {
          return get(expression_2);
        },
        $$events: {
          click: () => {
            page(1);
            dispatch("change", { page: page() });
          }
        },
        children: wrap_snippet(PaginationNav, ($$anchor3, $$slotProps) => {
          next();
          var text2 = text();
          template_effect(() => set_text(text2, strict_equals(page(), 1) ? "Active, Page" : "Page"));
          append($$anchor3, text2);
        }),
        $$slots: { default: true }
      });
      append($$anchor2, fragment);
    };
    if_block(node_1, ($$render) => {
      if (get(fit) > MIN || get(fit) <= MIN && page() <= 1) $$render(consequent);
    });
  }
  var node_3 = sibling(node_1, 2);
  PaginationOverflow_default(node_3, {
    get fromIndex() {
      return get(startOffset);
    },
    get count() {
      return get(front);
    },
    $$events: {
      select: ({ detail }) => {
        page(detail.index);
        dispatch("change", { page: page() });
      }
    }
  });
  var node_4 = sibling(node_3, 2);
  each(node_4, 1, () => get(items), index, ($$anchor2, item) => {
    var fragment_2 = comment();
    var node_5 = first_child(fragment_2);
    const expression_3 = derived_safe_equal(() => get(item) + 1);
    const expression_4 = derived_safe_equal(() => strict_equals(page(), get(item) + 1));
    PaginationItem_default(node_5, {
      get page() {
        return get(expression_3);
      },
      get active() {
        return get(expression_4);
      },
      $$events: {
        click: () => {
          page(get(item) + 1);
          dispatch("change", { page: page() });
        }
      },
      children: wrap_snippet(PaginationNav, ($$anchor3, $$slotProps) => {
        next();
        var text_1 = text();
        template_effect(() => set_text(text_1, strict_equals(page(), get(item)) ? "Active, Page" : "Page"));
        append($$anchor3, text_1);
      }),
      $$slots: { default: true }
    });
    append($$anchor2, fragment_2);
  });
  var node_6 = sibling(node_4, 2);
  const expression_5 = derived_safe_equal(() => total() - get(back) - 1);
  PaginationOverflow_default(node_6, {
    get fromIndex() {
      return get(expression_5);
    },
    get count() {
      return get(back);
    },
    $$events: {
      select: ({ detail }) => {
        page(detail.index);
        dispatch("change", { page: page() });
      }
    }
  });
  var node_7 = sibling(node_6, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_8 = first_child(fragment_4);
      const expression_6 = derived_safe_equal(() => strict_equals(page(), total()));
      PaginationItem_default(node_8, {
        get page() {
          return total();
        },
        get active() {
          return get(expression_6);
        },
        $$events: {
          click: () => {
            page(total());
            dispatch("change", { page: page() });
          }
        },
        children: wrap_snippet(PaginationNav, ($$anchor3, $$slotProps) => {
          next();
          var text_2 = text();
          template_effect(() => set_text(text_2, strict_equals(page(), total()) ? "Active, Page" : "Page"));
          append($$anchor3, text_2);
        }),
        $$slots: { default: true }
      });
      append($$anchor2, fragment_4);
    };
    if_block(node_7, ($$render) => {
      if (total() > 1) $$render(consequent_1);
    });
  }
  var li_1 = sibling(node_7, 2);
  toggle_class(li_1, "bx--pagination-nav__list-item", true);
  var node_9 = child(li_1);
  const expression_7 = derived_safe_equal(() => strict_equals(tooltipPosition(), "inside") ? "left" : strict_equals(tooltipPosition(), "outside") ? "right" : tooltipPosition());
  const expression_8 = derived_safe_equal(() => !loop() && strict_equals(page(), total()));
  Button_default(node_9, {
    kind: "ghost",
    tooltipAlignment: "center",
    get tooltipPosition() {
      return get(expression_7);
    },
    get iconDescription() {
      return forwardText();
    },
    get disabled() {
      return get(expression_8);
    },
    icon: CaretRight_default,
    $$events: {
      click: () => {
        if (page() >= total()) {
          if (loop()) page(1);
        } else {
          update_prop(page);
        }
        dispatch("click:button--next", { page: page() });
        dispatch("change", { page: page() });
      }
    }
  });
  reset(li_1);
  reset(ul);
  var div = sibling(ul, 2);
  toggle_class(div, "bx--pagination-nav__accessibility-label", true);
  var text_3 = child(div);
  reset(div);
  reset(nav);
  template_effect(() => {
    attributes = set_attributes(nav, attributes, { "aria-label": "pagination", ...$$restProps });
    toggle_class(nav, "bx--pagination-nav", true);
    set_text(text_3, `Page
    ${page() + 1}
    of
    ${total() ?? ""}`);
  });
  append($$anchor, nav);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PaginationNav = hmr(PaginationNav, () => PaginationNav[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PaginationNav[HMR].source;
    set(PaginationNav[HMR].source, module.default[HMR].original);
  });
}
var PaginationNav_default = PaginationNav;
mark_module_end(PaginationNav);

// node_modules/carbon-components-svelte/src/Popover/Popover.svelte
mark_module_start();
Popover[FILENAME] = "node_modules/carbon-components-svelte/src/Popover/Popover.svelte";
var root93 = add_locations(template(`<div><div><!></div></div>`), Popover[FILENAME], [[47, 0, [[70, 2]]]]);
function Popover($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "open",
    "closeOnOutsideClick",
    "caret",
    "align",
    "light",
    "highContrast",
    "relative"
  ]);
  push($$props, false, Popover);
  let open = prop($$props, "open", 12, false);
  let closeOnOutsideClick = prop($$props, "closeOnOutsideClick", 8, false);
  let caret = prop($$props, "caret", 8, false);
  let align = prop($$props, "align", 8, "top");
  let light = prop($$props, "light", 8, false);
  let highContrast = prop($$props, "highContrast", 8, false);
  let relative = prop($$props, "relative", 8, false);
  const dispatch = createEventDispatcher();
  let ref = mutable_state(null);
  init();
  var div = root93();
  event2("click", $window, (e) => {
    if (!open()) return;
    if (!get(ref).contains(e.target)) {
      dispatch("click:outside", { target: e.target });
      if (closeOnOutsideClick()) open(false);
    }
  });
  let attributes;
  var div_1 = child(div);
  toggle_class(div_1, "bx--popover-contents", true);
  var node = child(div_1);
  slot(node, $$props, "default", {}, null);
  reset(div_1);
  reset(div);
  bind_this(div, ($$value) => set(ref, $$value), () => get(ref));
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--popover", true);
    toggle_class(div, "bx--popover--caret", caret());
    toggle_class(div, "bx--popover--light", light());
    toggle_class(div, "bx--popover--high-contrast", highContrast());
    toggle_class(div, "bx--popover--top", strict_equals(align(), "top"));
    toggle_class(div, "bx--popover--top-left", strict_equals(align(), "top-left"));
    toggle_class(div, "bx--popover--top-right", strict_equals(align(), "top-right"));
    toggle_class(div, "bx--popover--bottom", strict_equals(align(), "bottom"));
    toggle_class(div, "bx--popover--bottom-left", strict_equals(align(), "bottom-left"));
    toggle_class(div, "bx--popover--bottom-right", strict_equals(align(), "bottom-right"));
    toggle_class(div, "bx--popover--left", strict_equals(align(), "left"));
    toggle_class(div, "bx--popover--left-bottom", strict_equals(align(), "left-bottom"));
    toggle_class(div, "bx--popover--left-top", strict_equals(align(), "left-top"));
    toggle_class(div, "bx--popover--right", strict_equals(align(), "right"));
    toggle_class(div, "bx--popover--right-bottom", strict_equals(align(), "right-bottom"));
    toggle_class(div, "bx--popover--right-top", strict_equals(align(), "right-top"));
    toggle_class(div, "bx--popover--open", open());
    toggle_class(div, "bx--popover--relative", relative());
    set_style(div, "position", relative() ? "relative" : void 0);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover = hmr(Popover, () => Popover[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover[HMR].source;
    set(Popover[HMR].source, module.default[HMR].original);
  });
}
var Popover_default = Popover;
mark_module_end(Popover);

// node_modules/carbon-components-svelte/src/ProgressBar/ProgressBar.svelte
mark_module_start();
ProgressBar[FILENAME] = "node_modules/carbon-components-svelte/src/ProgressBar/ProgressBar.svelte";
var root_313 = add_locations(template(`<div> </div>`), ProgressBar[FILENAME], [[106, 4]]);
var root94 = add_locations(template(`<div><label><!> <!></label> <div role="progressbar"><div></div></div> <!></div>`), ProgressBar[FILENAME], [
  [
    64,
    0,
    [[75, 2], [90, 2, [[100, 4]]]]
  ]
]);
function ProgressBar($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "value",
    "max",
    "kind",
    "status",
    "size",
    "labelText",
    "hideLabel",
    "helperText",
    "id"
  ]);
  push($$props, false, ProgressBar);
  const indeterminate = mutable_state();
  let value = prop($$props, "value", 8, void 0);
  let max = prop($$props, "max", 8, 100);
  let kind = prop($$props, "kind", 8, "default");
  let status = prop($$props, "status", 8, "active");
  let size = prop($$props, "size", 8, "md");
  let labelText = prop($$props, "labelText", 8, "");
  let hideLabel = prop($$props, "hideLabel", 8, false);
  let helperText = prop($$props, "helperText", 8, "");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  const statusIcons = { error: ErrorFilled_default, finished: CheckmarkFilled_default };
  let helperId = "ccs-" + Math.random().toString(36);
  let capped = mutable_state();
  legacy_pre_effect(
    () => (deep_read_state(value()), deep_read_state(status())),
    () => {
      set(indeterminate, strict_equals(value(), void 0) && strict_equals(status(), "active"));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(status()), deep_read_state(value()), deep_read_state(max())),
    () => {
      if (strict_equals(status(), "error") || value() < 0) {
        set(capped, 0);
      } else if (value() > max()) {
        set(capped, max());
      } else {
        set(capped, value());
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root94();
  let attributes;
  var label = child(div);
  var node = child(label);
  slot(node, $$props, "labelText", {}, ($$anchor2) => {
    var text2 = text();
    template_effect(() => set_text(text2, labelText()));
    append($$anchor2, text2);
  });
  var node_1 = sibling(node, 2);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      component(node_2, () => statusIcons[status()], ($$anchor3, $$component) => {
        $$component($$anchor3, { class: "bx--progress-bar__status-icon" });
      });
      append($$anchor2, fragment_1);
    };
    if_block(node_1, ($$render) => {
      if (strict_equals(status(), "error") || strict_equals(status(), "finished")) $$render(consequent);
    });
  }
  reset(label);
  var div_1 = sibling(label, 2);
  var div_2 = child(div_1);
  toggle_class(div_2, "bx--progress-bar__bar", true);
  reset(div_1);
  var node_3 = sibling(div_1, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var div_3 = root_313();
      set_attribute(div_3, "id", helperId);
      toggle_class(div_3, "bx--progress-bar__helper-text", true);
      var text_1 = child(div_3, true);
      reset(div_3);
      template_effect(() => set_text(text_1, helperText()));
      append($$anchor2, div_3);
    };
    if_block(node_3, ($$render) => {
      if (helperText()) $$render(consequent_1);
    });
  }
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--progress-bar", true);
    toggle_class(div, "bx--progress-bar--indeterminate", get(indeterminate));
    toggle_class(div, "bx--progress-bar--big", strict_equals(size(), "md"));
    toggle_class(div, "bx--progress-bar--small", strict_equals(size(), "sm"));
    toggle_class(div, "bx--progress-bar--inline", strict_equals(kind(), "inline"));
    toggle_class(div, "bx--progress-bar--indented", strict_equals(kind(), "indented"));
    toggle_class(div, "bx--progress-bar--error", strict_equals(status(), "error"));
    toggle_class(div, "bx--progress-bar--finished", strict_equals(status(), "finished"));
    set_attribute(label, "for", id());
    toggle_class(label, "bx--progress-bar__label", true);
    toggle_class(label, "bx--visually-hidden", hideLabel());
    set_attribute(div_1, "id", id());
    set_attribute(div_1, "aria-busy", strict_equals(status(), "active"));
    set_attribute(div_1, "aria-valuemin", get(indeterminate) ? void 0 : 0);
    set_attribute(div_1, "aria-valuemax", get(indeterminate) ? void 0 : max());
    set_attribute(div_1, "aria-valuenow", get(indeterminate) ? void 0 : get(capped));
    set_attribute(div_1, "aria-describedby", helperText() ? helperId : null);
    toggle_class(div_1, "bx--progress-bar__track", true);
    set_style(div_2, "transform", strict_equals(status(), "active") && `scaleX(${get(capped) / max()})`);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ProgressBar = hmr(ProgressBar, () => ProgressBar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ProgressBar[HMR].source;
    set(ProgressBar[HMR].source, module.default[HMR].original);
  });
}
var ProgressBar_default = ProgressBar;
mark_module_end(ProgressBar);

// node_modules/carbon-components-svelte/src/ProgressIndicator/ProgressIndicator.svelte
mark_module_start();
ProgressIndicator[FILENAME] = "node_modules/carbon-components-svelte/src/ProgressIndicator/ProgressIndicator.svelte";
var root95 = add_locations(template(`<ul><!></ul>`), ProgressIndicator[FILENAME], [[68, 0]]);
function ProgressIndicator($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "currentIndex",
    "vertical",
    "spaceEqually",
    "preventChangeOnClick"
  ]);
  push($$props, false, ProgressIndicator);
  const [$$stores, $$cleanup] = setup_stores();
  const $stepsById = () => (validate_store(stepsById, "stepsById"), store_get(stepsById, "$stepsById", $$stores));
  let currentIndex = prop($$props, "currentIndex", 12, 0);
  let vertical = prop($$props, "vertical", 8, false);
  let spaceEqually = prop($$props, "spaceEqually", 8, false);
  let preventChangeOnClick = prop($$props, "preventChangeOnClick", 8, false);
  const dispatch = createEventDispatcher();
  const steps = writable([]);
  const stepsById = derived2(steps, (steps2) => steps2.reduce((a, c) => ({ ...a, [c.id]: c }), {}));
  const preventChangeOnClickStore = writable(preventChangeOnClick());
  setContext("ProgressIndicator", {
    steps,
    stepsById,
    preventChangeOnClick: { subscribe: preventChangeOnClickStore.subscribe },
    add: (step) => {
      steps.update((_) => {
        if (step.id in $stepsById()) {
          return _.map((_step) => {
            if (strict_equals(_step.id, step.id)) return { ..._step, ...step };
            return _step;
          });
        }
        return [
          ..._,
          {
            ...step,
            index: _.length,
            current: strict_equals(_.length, currentIndex()),
            complete: step.complete
          }
        ];
      });
    },
    change: (index2) => {
      if (preventChangeOnClick()) return;
      currentIndex(index2);
      dispatch("change", index2);
    }
  });
  legacy_pre_effect(() => deep_read_state(currentIndex()), () => {
    steps.update((_) => _.map((step, i) => ({
      ...step,
      current: strict_equals(i, currentIndex())
    })));
  });
  legacy_pre_effect(
    () => deep_read_state(preventChangeOnClick()),
    () => {
      preventChangeOnClickStore.set(preventChangeOnClick());
    }
  );
  legacy_pre_effect_reset();
  init();
  var ul = root95();
  let attributes;
  var node = child(ul);
  slot(node, $$props, "default", {}, null);
  reset(ul);
  template_effect(() => {
    attributes = set_attributes(ul, attributes, { ...$$restProps });
    toggle_class(ul, "bx--progress", true);
    toggle_class(ul, "bx--progress--vertical", vertical());
    toggle_class(ul, "bx--progress--space-equal", spaceEqually() && !vertical());
  });
  event2("click", ul, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", ul, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", ul, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", ul, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, ul);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  ProgressIndicator = hmr(ProgressIndicator, () => ProgressIndicator[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ProgressIndicator[HMR].source;
    set(ProgressIndicator[HMR].source, module.default[HMR].original);
  });
}
var ProgressIndicator_default = ProgressIndicator;
mark_module_end(ProgressIndicator);

// node_modules/carbon-components-svelte/src/ProgressIndicator/ProgressIndicatorSkeleton.svelte
mark_module_start();
ProgressIndicatorSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/ProgressIndicator/ProgressIndicatorSkeleton.svelte";
var root_168 = add_locations(template(`<li><div><svg><path d="M 7, 7 m -7, 0 a 7,7 0 1,0 14,0 a 7,7 0 1,0 -14,0"></path></svg> <p></p> <span></span></div></li>`), ProgressIndicatorSkeleton[FILENAME], [
  [
    22,
    4,
    [
      [
        26,
        6,
        [
          [30, 8, [[31, 10]]],
          [33, 8],
          [34, 8]
        ]
      ]
    ]
  ]
]);
var root96 = add_locations(template(`<ul></ul>`), ProgressIndicatorSkeleton[FILENAME], [[11, 0]]);
function ProgressIndicatorSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["vertical", "count"]);
  push($$props, false, ProgressIndicatorSkeleton);
  let vertical = prop($$props, "vertical", 8, false);
  let count = prop($$props, "count", 8, 4);
  var ul = root96();
  let attributes;
  validate_each_keys(() => Array.from({ length: count() }, (_, i) => i), (item) => item);
  each(ul, 7, () => Array.from({ length: count() }, (_, i) => i), (item) => item, ($$anchor2, item) => {
    var li = root_168();
    toggle_class(li, "bx--progress-step", true);
    toggle_class(li, "bx--progress-step--incomplete", true);
    var div = child(li);
    toggle_class(div, "bx--progress-step-button", true);
    toggle_class(div, "bx--progress-step-button--unclickable", true);
    var p = sibling(child(div), 2);
    toggle_class(p, "bx--progress-label", true);
    var span = sibling(p, 2);
    toggle_class(span, "bx--progress-line", true);
    reset(div);
    reset(li);
    append($$anchor2, li);
  });
  reset(ul);
  template_effect(() => {
    attributes = set_attributes(ul, attributes, { ...$$restProps });
    toggle_class(ul, "bx--progress", true);
    toggle_class(ul, "bx--progress--vertical", vertical());
    toggle_class(ul, "bx--skeleton", true);
  });
  event2("click", ul, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", ul, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", ul, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", ul, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, ul);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ProgressIndicatorSkeleton = hmr(ProgressIndicatorSkeleton, () => ProgressIndicatorSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ProgressIndicatorSkeleton[HMR].source;
    set(ProgressIndicatorSkeleton[HMR].source, module.default[HMR].original);
  });
}
var ProgressIndicatorSkeleton_default = ProgressIndicatorSkeleton;
mark_module_end(ProgressIndicatorSkeleton);

// node_modules/carbon-components-svelte/src/icons/CheckmarkOutline.svelte
mark_module_start();
CheckmarkOutline[FILENAME] = "node_modules/carbon-components-svelte/src/icons/CheckmarkOutline.svelte";
var root_169 = add_locations(ns_template(`<title> </title>`), CheckmarkOutline[FILENAME], [[24, 13]]);
var root97 = add_locations(ns_template(`<svg><!><path d="M14 21.414L9 16.413 10.413 15 14 18.586 21.585 11 23 12.415 14 21.414z"></path><path d="M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,26A12,12,0,1,1,28,16,12,12,0,0,1,16,28Z"></path></svg>`), CheckmarkOutline[FILENAME], [[14, 0, [[25, 2], [27, 10]]]]);
function CheckmarkOutline($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, CheckmarkOutline);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root97();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_169();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next(2);
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CheckmarkOutline = hmr(CheckmarkOutline, () => CheckmarkOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CheckmarkOutline[HMR].source;
    set(CheckmarkOutline[HMR].source, module.default[HMR].original);
  });
}
var CheckmarkOutline_default = CheckmarkOutline;
mark_module_end(CheckmarkOutline);

// node_modules/carbon-components-svelte/src/icons/Warning.svelte
mark_module_start();
Warning[FILENAME] = "node_modules/carbon-components-svelte/src/icons/Warning.svelte";
var root_170 = add_locations(ns_template(`<title> </title>`), Warning[FILENAME], [[24, 13]]);
var root98 = add_locations(ns_template(`<svg><!><path d="M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,26A12,12,0,1,1,28,16,12,12,0,0,1,16,28Z"></path><path d="M15 8H17V19H15zM16 22a1.5 1.5 0 101.5 1.5A1.5 1.5 0 0016 22z"></path></svg>`), Warning[FILENAME], [[14, 0, [[25, 2], [27, 10]]]]);
function Warning($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, Warning);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root98();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_170();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next(2);
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Warning = hmr(Warning, () => Warning[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Warning[HMR].source;
    set(Warning[HMR].source, module.default[HMR].original);
  });
}
var Warning_default = Warning;
mark_module_end(Warning);

// node_modules/carbon-components-svelte/src/icons/CircleDash.svelte
mark_module_start();
CircleDash[FILENAME] = "node_modules/carbon-components-svelte/src/icons/CircleDash.svelte";
var root_171 = add_locations(ns_template(`<title> </title>`), CircleDash[FILENAME], [[24, 13]]);
var root99 = add_locations(ns_template(`<svg><!><path d="M7.7 4.7a14.7 14.7 0 00-3 3.1L6.3 9A13.26 13.26 0 018.9 6.3zM4.6 12.3l-1.9-.6A12.51 12.51 0 002 16H4A11.48 11.48 0 014.6 12.3zM2.7 20.4a14.4 14.4 0 002 3.9l1.6-1.2a12.89 12.89 0 01-1.7-3.3zM7.8 27.3a14.4 14.4 0 003.9 2l.6-1.9A12.89 12.89 0 019 25.7zM11.7 2.7l.6 1.9A11.48 11.48 0 0116 4V2A12.51 12.51 0 0011.7 2.7zM24.2 27.3a15.18 15.18 0 003.1-3.1L25.7 23A11.53 11.53 0 0123 25.7zM27.4 19.7l1.9.6A15.47 15.47 0 0030 16H28A11.48 11.48 0 0127.4 19.7zM29.2 11.6a14.4 14.4 0 00-2-3.9L25.6 8.9a12.89 12.89 0 011.7 3.3zM24.1 4.6a14.4 14.4 0 00-3.9-2l-.6 1.9a12.89 12.89 0 013.3 1.7zM20.3 29.3l-.6-1.9A11.48 11.48 0 0116 28v2A21.42 21.42 0 0020.3 29.3z"></path></svg>`), CircleDash[FILENAME], [[14, 0, [[25, 2]]]]);
function CircleDash($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, CircleDash);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root99();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_171();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next();
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CircleDash = hmr(CircleDash, () => CircleDash[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CircleDash[HMR].source;
    set(CircleDash[HMR].source, module.default[HMR].original);
  });
}
var CircleDash_default = CircleDash;
mark_module_end(CircleDash);

// node_modules/carbon-components-svelte/src/icons/Incomplete.svelte
mark_module_start();
Incomplete[FILENAME] = "node_modules/carbon-components-svelte/src/icons/Incomplete.svelte";
var root_173 = add_locations(ns_template(`<title> </title>`), Incomplete[FILENAME], [[24, 13]]);
var root100 = add_locations(ns_template(`<svg><!><path d="M23.7642 6.8593l1.2851-1.5315A13.976 13.976 0 0020.8672 2.887l-.6836 1.8776A11.9729 11.9729 0 0123.7642 6.8593zM27.81 14l1.9677-.4128A13.8888 13.8888 0 0028.14 9.0457L26.4087 10A12.52 12.52 0 0127.81 14zM20.1836 27.2354l.6836 1.8776a13.976 13.976 0 004.1821-2.4408l-1.2851-1.5315A11.9729 11.9729 0 0120.1836 27.2354zM26.4087 22L28.14 23a14.14 14.14 0 001.6382-4.5872L27.81 18.0659A12.1519 12.1519 0 0126.4087 22zM16 30V2a14 14 0 000 28z"></path></svg>`), Incomplete[FILENAME], [[14, 0, [[25, 2]]]]);
function Incomplete($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, Incomplete);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root100();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_173();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next();
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Incomplete = hmr(Incomplete, () => Incomplete[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Incomplete[HMR].source;
    set(Incomplete[HMR].source, module.default[HMR].original);
  });
}
var Incomplete_default = Incomplete;
mark_module_end(Incomplete);

// node_modules/carbon-components-svelte/src/ProgressIndicator/ProgressStep.svelte
mark_module_start();
ProgressStep[FILENAME] = "node_modules/carbon-components-svelte/src/ProgressIndicator/ProgressStep.svelte";
var root_79 = add_locations(template(`<p> </p>`), ProgressStep[FILENAME], [[99, 8]]);
var root_85 = add_locations(template(`<p> </p>`), ProgressStep[FILENAME], [[102, 8]]);
var root101 = add_locations(template(`<li><button type="button"><!> <div><!> <!></div> <span></span></button></li>`), ProgressStep[FILENAME], [
  [
    55,
    0,
    [[64, 2, [[97, 4], [105, 4]]]]
  ]
]);
function ProgressStep($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "complete",
    "current",
    "disabled",
    "invalid",
    "description",
    "label",
    "secondaryLabel",
    "id"
  ]);
  push($$props, false, ProgressStep);
  const [$$stores, $$cleanup] = setup_stores();
  const $preventChangeOnClick = () => (validate_store(preventChangeOnClick, "preventChangeOnClick"), store_get(preventChangeOnClick, "$preventChangeOnClick", $$stores));
  let complete = prop($$props, "complete", 12, false);
  let current = prop($$props, "current", 12, false);
  let disabled = prop($$props, "disabled", 8, false);
  let invalid = prop($$props, "invalid", 8, false);
  let description = prop($$props, "description", 8, "");
  let label = prop($$props, "label", 8, "");
  let secondaryLabel = prop($$props, "secondaryLabel", 8, "");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let step = mutable_state({});
  const {
    stepsById,
    add,
    change,
    preventChangeOnClick
  } = getContext("ProgressIndicator");
  const unsubscribe = stepsById.subscribe((value) => {
    if (value[id()]) {
      set(step, value[id()]);
      current(get(step).current);
      complete(get(step).complete);
    }
  });
  onMount(() => {
    return () => {
      unsubscribe();
    };
  });
  legacy_pre_effect(
    () => (deep_read_state(id()), deep_read_state(complete()), deep_read_state(disabled())),
    () => {
      add({
        id: id(),
        complete: complete(),
        disabled: disabled()
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var li = root101();
  let attributes;
  var button = child(li);
  var node = child(button);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      Warning_default(node_1, {
        class: "bx--progress__warning",
        get title() {
          return description();
        }
      });
      append($$anchor2, fragment);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          Incomplete_default(node_3, {
            get title() {
              return description();
            }
          });
          append($$anchor3, fragment_2);
        };
        var alternate_1 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          {
            var consequent_2 = ($$anchor4) => {
              var fragment_4 = comment();
              var node_5 = first_child(fragment_4);
              CheckmarkOutline_default(node_5, {
                get title() {
                  return description();
                }
              });
              append($$anchor4, fragment_4);
            };
            var alternate = ($$anchor4) => {
              var fragment_5 = comment();
              var node_6 = first_child(fragment_5);
              CircleDash_default(node_6, {
                get title() {
                  return description();
                }
              });
              append($$anchor4, fragment_5);
            };
            if_block(
              node_4,
              ($$render) => {
                if (complete()) $$render(consequent_2);
                else $$render(alternate, false);
              },
              true
            );
          }
          append($$anchor3, fragment_3);
        };
        if_block(
          node_2,
          ($$render) => {
            if (current()) $$render(consequent_1);
            else $$render(alternate_1, false);
          },
          true
        );
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (invalid()) $$render(consequent);
      else $$render(alternate_2, false);
    });
  }
  var div = sibling(node, 2);
  toggle_class(div, "bx--progress-text", true);
  var node_7 = child(div);
  slot(node_7, $$props, "default", { props: { class: "bx--progress-label" } }, ($$anchor2) => {
    var p = root_79();
    toggle_class(p, "bx--progress-label", true);
    var text2 = child(p, true);
    reset(p);
    template_effect(() => set_text(text2, label()));
    append($$anchor2, p);
  });
  var node_8 = sibling(node_7, 2);
  {
    var consequent_3 = ($$anchor2) => {
      var p_1 = root_85();
      toggle_class(p_1, "bx--progress-optional", true);
      var text_1 = child(p_1, true);
      reset(p_1);
      template_effect(() => set_text(text_1, secondaryLabel()));
      append($$anchor2, p_1);
    };
    if_block(node_8, ($$render) => {
      if (secondaryLabel()) $$render(consequent_3);
    });
  }
  reset(div);
  var span = sibling(div, 2);
  toggle_class(span, "bx--progress-line", true);
  reset(button);
  reset(li);
  template_effect(() => {
    attributes = set_attributes(li, attributes, { id: id(), ...$$restProps });
    toggle_class(li, "bx--progress-step", true);
    toggle_class(li, "bx--progress-step--current", current());
    toggle_class(li, "bx--progress-step--complete", complete());
    toggle_class(li, "bx--progress-step--incomplete", !complete() && !current());
    toggle_class(li, "bx--progress-step--disabled", disabled());
    button.disabled = disabled();
    set_attribute(button, "aria-disabled", disabled());
    set_attribute(button, "tabindex", !current() && !disabled() ? "0" : "-1");
    toggle_class(button, "bx--progress-step-button", true);
    toggle_class(button, "bx--progress-step-button--unclickable", current() || $preventChangeOnClick());
  });
  event2("click", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", button, () => {
    if (!get(step).complete) return;
    change(get(step).index);
  });
  event2("mouseover", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", button, (e) => {
    if (!get(step).complete) return;
    if (strict_equals(e.key, " ") || strict_equals(e.key, "Enter")) {
      change(get(step).index);
    }
  });
  append($$anchor, li);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  ProgressStep = hmr(ProgressStep, () => ProgressStep[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ProgressStep[HMR].source;
    set(ProgressStep[HMR].source, module.default[HMR].original);
  });
}
var ProgressStep_default = ProgressStep;
mark_module_end(ProgressStep);

// node_modules/carbon-components-svelte/src/RadioButton/RadioButtonSkeleton.svelte
mark_module_start();
RadioButtonSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/RadioButton/RadioButtonSkeleton.svelte";
var root102 = add_locations(template(`<div><div></div> <span></span></div>`), RadioButtonSkeleton[FILENAME], [[3, 0, [[11, 2], [12, 2]]]]);
function RadioButtonSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, RadioButtonSkeleton);
  var div = root102();
  let attributes;
  var div_1 = child(div);
  toggle_class(div_1, "bx--radio-button", true);
  toggle_class(div_1, "bx--skeleton", true);
  var span = sibling(div_1, 2);
  toggle_class(span, "bx--radio-button__label", true);
  toggle_class(span, "bx--skeleton", true);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--radio-button-wrapper", true);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  RadioButtonSkeleton = hmr(RadioButtonSkeleton, () => RadioButtonSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RadioButtonSkeleton[HMR].source;
    set(RadioButtonSkeleton[HMR].source, module.default[HMR].original);
  });
}
var RadioButtonSkeleton_default = RadioButtonSkeleton;
mark_module_end(RadioButtonSkeleton);

// node_modules/carbon-components-svelte/src/RadioButtonGroup/RadioButtonGroup.svelte
mark_module_start();
RadioButtonGroup[FILENAME] = "node_modules/carbon-components-svelte/src/RadioButtonGroup/RadioButtonGroup.svelte";
var root_174 = add_locations(template(`<legend><!></legend>`), RadioButtonGroup[FILENAME], [[114, 6]]);
var root103 = add_locations(template(`<div><fieldset><!> <!></fieldset></div>`), RadioButtonGroup[FILENAME], [[97, 0, [[106, 2]]]]);
function RadioButtonGroup($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "selected",
    "disabled",
    "required",
    "name",
    "legendText",
    "hideLegend",
    "labelPosition",
    "orientation",
    "id"
  ]);
  push($$props, false, RadioButtonGroup);
  const [$$stores, $$cleanup] = setup_stores();
  const $selectedValue = () => (validate_store(selectedValue, "selectedValue"), store_get(selectedValue, "$selectedValue", $$stores));
  const $groupName = () => (validate_store(groupName, "groupName"), store_get(groupName, "$groupName", $$stores));
  const $groupRequired = () => (validate_store(groupRequired, "groupRequired"), store_get(groupRequired, "$groupRequired", $$stores));
  let selected = prop($$props, "selected", 12, void 0);
  let disabled = prop($$props, "disabled", 8, false);
  let required = prop($$props, "required", 8, void 0);
  let name = prop($$props, "name", 8, void 0);
  let legendText = prop($$props, "legendText", 8, "");
  let hideLegend = prop($$props, "hideLegend", 8, false);
  let labelPosition = prop($$props, "labelPosition", 8, "right");
  let orientation = prop($$props, "orientation", 8, "horizontal");
  let id = prop($$props, "id", 8, void 0);
  const dispatch = createEventDispatcher();
  const selectedValue = writable(selected());
  const groupName = writable(name());
  const groupRequired = writable(required());
  setContext("RadioButtonGroup", {
    selectedValue,
    groupName: readonly(groupName),
    groupRequired: readonly(groupRequired),
    add: ({ checked, value }) => {
      if (checked) {
        selectedValue.set(value);
      }
    },
    update: (value) => {
      selected(value);
    }
  });
  onMount(() => {
    store_set(selectedValue, selected());
  });
  beforeUpdate(() => {
    store_set(selectedValue, selected());
  });
  selectedValue.subscribe((value) => {
    selected(value);
    dispatch("change", value);
  });
  legacy_pre_effect(() => deep_read_state(name()), () => {
    store_set(groupName, name());
  });
  legacy_pre_effect(() => deep_read_state(required()), () => {
    store_set(groupRequired, required());
  });
  legacy_pre_effect_reset();
  init();
  var div = root103();
  let attributes;
  var fieldset = child(div);
  var node = child(fieldset);
  {
    var consequent = ($$anchor2) => {
      var legend = root_174();
      toggle_class(legend, "bx--label", true);
      var node_1 = child(legend);
      slot(node_1, $$props, "legendText", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, legendText()));
        append($$anchor3, text2);
      });
      reset(legend);
      template_effect(() => toggle_class(legend, "bx--visually-hidden", hideLegend()));
      append($$anchor2, legend);
    };
    if_block(node, ($$render) => {
      if (legendText() || $$slots.legendText) $$render(consequent);
    });
  }
  var node_2 = sibling(node, 2);
  slot(node_2, $$props, "default", {}, null);
  reset(fieldset);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { id: id(), ...$$restProps });
    toggle_class(div, "bx--form-item", true);
    fieldset.disabled = disabled();
    toggle_class(fieldset, "bx--radio-button-group", true);
    toggle_class(fieldset, "bx--radio-button-group--vertical", strict_equals(orientation(), "vertical"));
    toggle_class(fieldset, "bx--radio-button-group--label-left", strict_equals(labelPosition(), "left"));
    toggle_class(fieldset, "bx--radio-button-group--label-right", strict_equals(labelPosition(), "right"));
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  RadioButtonGroup = hmr(RadioButtonGroup, () => RadioButtonGroup[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RadioButtonGroup[HMR].source;
    set(RadioButtonGroup[HMR].source, module.default[HMR].original);
  });
}
var RadioButtonGroup_default = RadioButtonGroup;
mark_module_end(RadioButtonGroup);

// node_modules/carbon-components-svelte/src/UnorderedList/UnorderedList.svelte
mark_module_start();
UnorderedList[FILENAME] = "node_modules/carbon-components-svelte/src/UnorderedList/UnorderedList.svelte";
var root104 = add_locations(template(`<ul><!></ul>`), UnorderedList[FILENAME], [[11, 0]]);
function UnorderedList($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["nested", "expressive"]);
  push($$props, false, UnorderedList);
  let nested = prop($$props, "nested", 8, false);
  let expressive = prop($$props, "expressive", 8, false);
  var ul = root104();
  let attributes;
  var node = child(ul);
  slot(node, $$props, "default", {}, null);
  reset(ul);
  template_effect(() => {
    attributes = set_attributes(ul, attributes, { ...$$restProps });
    toggle_class(ul, "bx--list--unordered", true);
    toggle_class(ul, "bx--list--nested", nested());
    toggle_class(ul, "bx--list--expressive", expressive());
  });
  event2("click", ul, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", ul, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", ul, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", ul, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, ul);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UnorderedList = hmr(UnorderedList, () => UnorderedList[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UnorderedList[HMR].source;
    set(UnorderedList[HMR].source, module.default[HMR].original);
  });
}
var UnorderedList_default = UnorderedList;
mark_module_end(UnorderedList);

// node_modules/carbon-components-svelte/src/RecursiveList/RecursiveListItem.svelte
mark_module_start();
RecursiveListItem[FILENAME] = "node_modules/carbon-components-svelte/src/RecursiveList/RecursiveListItem.svelte";
var root_314 = add_locations(template(`<a> </a>`), RecursiveListItem[FILENAME], [[16, 12]]);
var root_175 = add_locations(template(`<!> <!> <!> <!>`, 1), RecursiveListItem[FILENAME], []);
function RecursiveListItem($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, RecursiveListItem);
  let text2 = prop($$props, "text", 8, "");
  let href = prop($$props, "href", 8, "");
  let html2 = prop($$props, "html", 8, "");
  var fragment = comment();
  var node = first_child(fragment);
  ListItem_default(node, {
    children: wrap_snippet(RecursiveListItem, ($$anchor2, $$slotProps) => {
      var fragment_1 = root_175();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var text_1 = text();
          template_effect(() => set_text(text_1, text2()));
          append($$anchor3, text_1);
        };
        if_block(node_1, ($$render) => {
          if (text2() && !href()) $$render(consequent);
        });
      }
      var node_2 = sibling(node_1, 2);
      {
        var consequent_1 = ($$anchor3) => {
          var a = root_314();
          var text_2 = child(a, true);
          reset(a);
          template_effect(() => {
            set_attribute(a, "href", href());
            toggle_class(a, "bx--link", true);
            set_text(text_2, text2() || href());
          });
          append($$anchor3, a);
        };
        if_block(node_2, ($$render) => {
          if (href()) $$render(consequent_1);
        });
      }
      var node_3 = sibling(node_2, 2);
      {
        var consequent_2 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          html(node_4, html2, false, false);
          append($$anchor3, fragment_3);
        };
        if_block(node_3, ($$render) => {
          if (!text2() && html2()) $$render(consequent_2);
        });
      }
      var node_5 = sibling(node_3, 2);
      slot(node_5, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  RecursiveListItem = hmr(RecursiveListItem, () => RecursiveListItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RecursiveListItem[HMR].source;
    set(RecursiveListItem[HMR].source, module.default[HMR].original);
  });
}
var RecursiveListItem_default = RecursiveListItem;
mark_module_end(RecursiveListItem);

// node_modules/carbon-components-svelte/src/RecursiveList/RecursiveList.svelte
mark_module_start();
RecursiveList[FILENAME] = "node_modules/carbon-components-svelte/src/RecursiveList/RecursiveList.svelte";
function RecursiveList($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["children", "type"]);
  push($$props, false, RecursiveList);
  let children = prop($$props, "children", 24, () => []);
  let type = prop($$props, "type", 8, "unordered");
  var fragment = comment();
  var node = first_child(fragment);
  const expression = derived_safe_equal(() => strict_equals(type(), "ordered-native"));
  component(node, () => strict_equals(type(), "unordered") ? UnorderedList_default : OrderedList_default, ($$anchor2, $$component) => {
    $$component($$anchor2, spread_props(
      {
        get native() {
          return get(expression);
        }
      },
      () => $$restProps,
      {
        children: wrap_snippet(RecursiveList, ($$anchor3, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          each(node_1, 1, children, index, ($$anchor4, child2) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            {
              var consequent = ($$anchor5) => {
                var fragment_3 = comment();
                var node_3 = first_child(fragment_3);
                RecursiveListItem_default(node_3, spread_props(() => get(child2), {
                  children: wrap_snippet(RecursiveList, ($$anchor6, $$slotProps2) => {
                    var fragment_4 = comment();
                    var node_4 = first_child(fragment_4);
                    RecursiveList(node_4, spread_props(() => get(child2), {
                      get type() {
                        return type();
                      },
                      nested: true
                    }));
                    append($$anchor6, fragment_4);
                  }),
                  $$slots: { default: true }
                }));
                append($$anchor5, fragment_3);
              };
              var alternate = ($$anchor5) => {
                var fragment_5 = comment();
                var node_5 = first_child(fragment_5);
                RecursiveListItem_default(node_5, spread_props(() => get(child2)));
                append($$anchor5, fragment_5);
              };
              if_block(node_2, ($$render) => {
                if (Array.isArray(get(child2).children)) $$render(consequent);
                else $$render(alternate, false);
              });
            }
            append($$anchor4, fragment_2);
          });
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      }
    ));
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  RecursiveList = hmr(RecursiveList, () => RecursiveList[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RecursiveList[HMR].source;
    set(RecursiveList[HMR].source, module.default[HMR].original);
  });
}
var RecursiveList_default = RecursiveList;
mark_module_end(RecursiveList);

// node_modules/carbon-components-svelte/src/Select/SelectSkeleton.svelte
mark_module_start();
SelectSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/Select/SelectSkeleton.svelte";
var root_176 = add_locations(template(`<span></span>`), SelectSkeleton[FILENAME], [[17, 4]]);
var root105 = add_locations(template(`<div><!> <div><div></div></div></div>`), SelectSkeleton[FILENAME], [
  [8, 0, [[19, 2, [[20, 4]]]]]
]);
function SelectSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["hideLabel"]);
  push($$props, false, SelectSkeleton);
  let hideLabel = prop($$props, "hideLabel", 8, false);
  var div = root105();
  let attributes;
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var span = root_176();
      toggle_class(span, "bx--label", true);
      toggle_class(span, "bx--skeleton", true);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if (!hideLabel()) $$render(consequent);
    });
  }
  var div_1 = sibling(node, 2);
  toggle_class(div_1, "bx--select", true);
  toggle_class(div_1, "bx--skeleton", true);
  var div_2 = child(div_1);
  toggle_class(div_2, "bx--select-input", true);
  reset(div_1);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--form-item", true);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SelectSkeleton = hmr(SelectSkeleton, () => SelectSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SelectSkeleton[HMR].source;
    set(SelectSkeleton[HMR].source, module.default[HMR].original);
  });
}
var SelectSkeleton_default = SelectSkeleton;
mark_module_end(SelectSkeleton);

// node_modules/carbon-components-svelte/src/Select/SelectItemGroup.svelte
mark_module_start();
SelectItemGroup[FILENAME] = "node_modules/carbon-components-svelte/src/Select/SelectItemGroup.svelte";
var root106 = add_locations(template(`<optgroup><!></optgroup>`), SelectItemGroup[FILENAME], [[9, 0]]);
function SelectItemGroup($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["disabled", "label"]);
  push($$props, false, SelectItemGroup);
  let disabled = prop($$props, "disabled", 8, false);
  let label = prop($$props, "label", 8, "Provide label");
  var optgroup = root106();
  let attributes;
  var node = child(optgroup);
  slot(node, $$props, "default", {}, null);
  reset(optgroup);
  template_effect(() => {
    attributes = set_attributes(optgroup, attributes, {
      label: label(),
      disabled: disabled(),
      ...$$restProps
    });
    toggle_class(optgroup, "bx--select-optgroup", true);
  });
  append($$anchor, optgroup);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SelectItemGroup = hmr(SelectItemGroup, () => SelectItemGroup[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SelectItemGroup[HMR].source;
    set(SelectItemGroup[HMR].source, module.default[HMR].original);
  });
}
var SelectItemGroup_default = SelectItemGroup;
mark_module_end(SelectItemGroup);

// node_modules/carbon-components-svelte/src/SkeletonPlaceholder/SkeletonPlaceholder.svelte
mark_module_start();
SkeletonPlaceholder[FILENAME] = "node_modules/carbon-components-svelte/src/SkeletonPlaceholder/SkeletonPlaceholder.svelte";
var root107 = add_locations(template(`<div></div>`), SkeletonPlaceholder[FILENAME], [[3, 0]]);
function SkeletonPlaceholder($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, SkeletonPlaceholder);
  var div = root107();
  let attributes;
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--skeleton__placeholder", true);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SkeletonPlaceholder = hmr(SkeletonPlaceholder, () => SkeletonPlaceholder[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SkeletonPlaceholder[HMR].source;
    set(SkeletonPlaceholder[HMR].source, module.default[HMR].original);
  });
}
var SkeletonPlaceholder_default = SkeletonPlaceholder;
mark_module_end(SkeletonPlaceholder);

// node_modules/carbon-components-svelte/src/Slider/Slider.svelte
mark_module_start();
Slider[FILENAME] = "node_modules/carbon-components-svelte/src/Slider/Slider.svelte";
var root108 = add_locations(template(`<div><label><!></label> <div><span> </span> <div role="presentation" tabindex="-1"><div role="slider" tabindex="0"></div> <div></div> <div></div></div> <span> </span> <input></div></div>`), Slider[FILENAME], [
  [
    147,
    0,
    [
      [155, 2],
      [
        166,
        2,
        [
          [167, 4],
          [
            168,
            4,
            [[191, 6], [202, 6], [203, 6]]
          ],
          [208, 4],
          [209, 4]
        ]
      ]
    ]
  ]
]);
function Slider($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "value",
    "max",
    "maxLabel",
    "min",
    "minLabel",
    "step",
    "stepMultiplier",
    "required",
    "inputType",
    "disabled",
    "light",
    "hideTextInput",
    "fullWidth",
    "id",
    "invalid",
    "labelText",
    "hideLabel",
    "name",
    "ref"
  ]);
  push($$props, false, Slider);
  const labelId = mutable_state();
  const range = mutable_state();
  const left = mutable_state();
  let value = prop($$props, "value", 12, 0);
  let max = prop($$props, "max", 8, 100);
  let maxLabel = prop($$props, "maxLabel", 8, "");
  let min = prop($$props, "min", 8, 0);
  let minLabel = prop($$props, "minLabel", 8, "");
  let step = prop($$props, "step", 8, 1);
  let stepMultiplier = prop($$props, "stepMultiplier", 8, 4);
  let required = prop($$props, "required", 8, false);
  let inputType = prop($$props, "inputType", 8, "number");
  let disabled = prop($$props, "disabled", 8, false);
  let light = prop($$props, "light", 8, false);
  let hideTextInput = prop($$props, "hideTextInput", 8, false);
  let fullWidth = prop($$props, "fullWidth", 8, false);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let invalid = prop($$props, "invalid", 8, false);
  let labelText = prop($$props, "labelText", 8, "");
  let hideLabel = prop($$props, "hideLabel", 8, false);
  let name = prop($$props, "name", 8, "");
  let ref = prop($$props, "ref", 12, null);
  const dispatch = createEventDispatcher();
  let trackRef = mutable_state(null);
  let dragging = mutable_state(false);
  let holding = mutable_state(false);
  function startDragging() {
    set(dragging, true);
  }
  function startHolding() {
    set(holding, true);
  }
  function stopHolding() {
    set(holding, false);
    set(dragging, false);
  }
  function move() {
    if (get(holding)) {
      startDragging();
    }
  }
  function calcValue(e) {
    if (disabled()) return;
    const offsetX = e.touches ? e.touches[0].clientX : e.clientX;
    const { left: left2, width } = get(trackRef).getBoundingClientRect();
    let nextValue = min() + Math.round((max() - min()) * ((offsetX - left2) / width) / step()) * step();
    if (nextValue <= min()) {
      nextValue = min();
    } else if (nextValue >= max()) {
      nextValue = max();
    }
    value(nextValue);
    dispatch("input", value());
  }
  legacy_pre_effect(() => deep_read_state(id()), () => {
    set(labelId, `label-${id()}`);
  });
  legacy_pre_effect(
    () => (deep_read_state(max()), deep_read_state(min())),
    () => {
      set(range, max() - min());
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(value()), deep_read_state(min()), deep_read_state(max()), get(dragging), get(holding), deep_read_state(disabled())),
    () => {
      if (value() <= min()) {
        value(min());
      } else if (value() >= max()) {
        value(max());
      }
      if (get(dragging)) {
        calcValue(event);
        set(dragging, false);
      }
      if (!get(holding) && !disabled()) {
        dispatch("change", value());
      }
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(value()), deep_read_state(min()), get(range)),
    () => {
      set(left, (value() - min()) / get(range) * 100);
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root108();
  event2("mousemove", $window, move);
  event2("touchmove", $window, move);
  event2("mouseup", $window, stopHolding);
  event2("touchend", $window, stopHolding);
  event2("touchcancel", $window, stopHolding);
  let attributes;
  var label = child(div);
  var node = child(label);
  slot(node, $$props, "labelText", {}, ($$anchor2) => {
    var text2 = text();
    template_effect(() => set_text(text2, labelText()));
    append($$anchor2, text2);
  });
  reset(label);
  var div_1 = sibling(label, 2);
  toggle_class(div_1, "bx--slider-container", true);
  var span = child(div_1);
  toggle_class(span, "bx--slider__range-label", true);
  var text_1 = child(span, true);
  reset(span);
  var div_2 = sibling(span, 2);
  toggle_class(div_2, "bx--slider", true);
  var div_3 = child(div_2);
  var div_4 = sibling(div_3, 2);
  toggle_class(div_4, "bx--slider__track", true);
  bind_this(div_4, ($$value) => set(trackRef, $$value), () => get(trackRef));
  var div_5 = sibling(div_4, 2);
  toggle_class(div_5, "bx--slider__filled-track", true);
  reset(div_2);
  bind_this(div_2, ($$value) => ref($$value), () => ref());
  var span_1 = sibling(div_2, 2);
  toggle_class(span_1, "bx--slider__range-label", true);
  var text_2 = child(span_1, true);
  reset(span_1);
  var input = sibling(span_1, 2);
  remove_input_defaults(input);
  reset(div_1);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--form-item", true);
    set_attribute(label, "for", id());
    set_attribute(label, "id", get(labelId));
    toggle_class(label, "bx--label", true);
    toggle_class(label, "bx--label--disabled", disabled());
    toggle_class(label, "bx--visually-hidden", hideLabel());
    set_style(div_1, "width", fullWidth() && "100%");
    set_text(text_1, minLabel() || min());
    toggle_class(div_2, "bx--slider--disabled", disabled());
    set_style(div_2, "max-width", fullWidth() ? "none" : void 0);
    set_attribute(div_3, "aria-valuemax", max());
    set_attribute(div_3, "aria-valuemin", min());
    set_attribute(div_3, "aria-valuenow", value());
    set_attribute(div_3, "aria-labelledby", get(labelId));
    set_attribute(div_3, "id", id());
    toggle_class(div_3, "bx--slider__thumb", true);
    set_style(div_3, "left", `${get(left) ?? ""}%`);
    set_style(div_5, "transform", `translate(0, -50%) scaleX(${get(left) / 100})`);
    set_text(text_2, maxLabel() || max());
    set_attribute(input, "type", hideTextInput() ? "hidden" : inputType());
    set_attribute(input, "id", `input-${id() ?? ""}`);
    set_attribute(input, "name", name());
    set_value(input, value());
    set_attribute(input, "aria-labelledby", $$sanitized_props["aria-label"] ? void 0 : get(labelId));
    set_attribute(input, "aria-label", $$sanitized_props["aria-label"] || "Slider number input");
    input.disabled = disabled();
    input.required = required();
    set_attribute(input, "min", min());
    set_attribute(input, "max", max());
    set_attribute(input, "step", step());
    set_attribute(input, "data-invalid", invalid() || null);
    set_attribute(input, "aria-invalid", invalid() || null);
    toggle_class(input, "bx--text-input", true);
    toggle_class(input, "bx--slider-text-input", true);
    toggle_class(input, "bx--text-input--light", light());
    toggle_class(input, "bx--text-input--invalid", invalid());
  });
  event2("mousedown", div_2, startDragging);
  event2("mousedown", div_2, startHolding);
  event2("touchstart", div_2, startHolding);
  event2("keydown", div_2, ({ shiftKey, key }) => {
    const keys = {
      ArrowDown: -1,
      ArrowLeft: -1,
      ArrowRight: 1,
      ArrowUp: 1
    };
    if (keys[key]) {
      value(value() + step() * (shiftKey ? get(range) / step() / stepMultiplier() : 1) * keys[key]);
    }
  });
  event2("change", input, ({ target }) => {
    value(Number(target.value));
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Slider = hmr(Slider, () => Slider[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Slider[HMR].source;
    set(Slider[HMR].source, module.default[HMR].original);
  });
}
var Slider_default = Slider;
mark_module_end(Slider);

// node_modules/carbon-components-svelte/src/Slider/SliderSkeleton.svelte
mark_module_start();
SliderSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/Slider/SliderSkeleton.svelte";
var root_177 = add_locations(template(`<span></span>`), SliderSkeleton[FILENAME], [[17, 4]]);
var root109 = add_locations(template(`<div><!> <div><span></span> <div><div></div> <div></div> <div></div></div> <span></span></div></div>`), SliderSkeleton[FILENAME], [
  [
    8,
    0,
    [
      [
        19,
        2,
        [
          [20, 4],
          [
            21,
            4,
            [[22, 6], [23, 6], [24, 6]]
          ],
          [26, 4]
        ]
      ]
    ]
  ]
]);
function SliderSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["hideLabel"]);
  push($$props, false, SliderSkeleton);
  let hideLabel = prop($$props, "hideLabel", 8, false);
  var div = root109();
  let attributes;
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var span = root_177();
      toggle_class(span, "bx--label", true);
      toggle_class(span, "bx--skeleton", true);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if (!hideLabel()) $$render(consequent);
    });
  }
  var div_1 = sibling(node, 2);
  toggle_class(div_1, "bx--slider-container", true);
  toggle_class(div_1, "bx--skeleton", true);
  var span_1 = child(div_1);
  toggle_class(span_1, "bx--slider__range-label", true);
  var div_2 = sibling(span_1, 2);
  toggle_class(div_2, "bx--slider", true);
  var div_3 = child(div_2);
  toggle_class(div_3, "bx--slider__track", true);
  var div_4 = sibling(div_3, 2);
  toggle_class(div_4, "bx--slider__filled-track", true);
  var div_5 = sibling(div_4, 2);
  toggle_class(div_5, "bx--slider__thumb", true);
  reset(div_2);
  var span_2 = sibling(div_2, 2);
  toggle_class(span_2, "bx--slider__range-label", true);
  reset(div_1);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--form-item", true);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SliderSkeleton = hmr(SliderSkeleton, () => SliderSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SliderSkeleton[HMR].source;
    set(SliderSkeleton[HMR].source, module.default[HMR].original);
  });
}
var SliderSkeleton_default = SliderSkeleton;
mark_module_end(SliderSkeleton);

// node_modules/carbon-components-svelte/src/StructuredList/StructuredList.svelte
mark_module_start();
StructuredList[FILENAME] = "node_modules/carbon-components-svelte/src/StructuredList/StructuredList.svelte";
var root110 = add_locations(template(`<div><!></div>`), StructuredList[FILENAME], [[40, 0]]);
function StructuredList($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "selected",
    "condensed",
    "flush",
    "selection"
  ]);
  push($$props, false, StructuredList);
  const [$$stores, $$cleanup] = setup_stores();
  const $selectedValue = () => (validate_store(selectedValue, "selectedValue"), store_get(selectedValue, "$selectedValue", $$stores));
  let selected = prop($$props, "selected", 12, void 0);
  let condensed = prop($$props, "condensed", 8, false);
  let flush = prop($$props, "flush", 8, false);
  let selection = prop($$props, "selection", 8, false);
  const dispatch = createEventDispatcher();
  const selectedValue = writable(selected());
  setContext("StructuredListWrapper", {
    selectedValue,
    update: (value) => {
      selectedValue.set(value);
    }
  });
  legacy_pre_effect(() => $selectedValue(), () => {
    selected($selectedValue());
  });
  legacy_pre_effect(() => $selectedValue(), () => {
    dispatch("change", $selectedValue());
  });
  legacy_pre_effect_reset();
  init();
  var div = root110();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { role: "table", ...$$restProps });
    toggle_class(div, "bx--structured-list", true);
    toggle_class(div, "bx--structured-list--selection", selection());
    toggle_class(div, "bx--structured-list--condensed", condensed());
    toggle_class(div, "bx--structured-list--flush", flush());
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  StructuredList = hmr(StructuredList, () => StructuredList[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StructuredList[HMR].source;
    set(StructuredList[HMR].source, module.default[HMR].original);
  });
}
var StructuredList_default = StructuredList;
mark_module_end(StructuredList);

// node_modules/carbon-components-svelte/src/StructuredList/StructuredListSkeleton.svelte
mark_module_start();
StructuredListSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/StructuredList/StructuredListSkeleton.svelte";
var root_178 = add_locations(template(`<div><div></div> <div></div> <div></div></div>`), StructuredListSkeleton[FILENAME], [
  [
    29,
    6,
    [[30, 8], [31, 8], [32, 8]]
  ]
]);
var root111 = add_locations(template(`<div><div><div><div><span></span></div> <div><span></span></div> <div><span></span></div></div></div> <div></div></div>`), StructuredListSkeleton[FILENAME], [
  [
    8,
    0,
    [
      [
        17,
        2,
        [
          [
            18,
            4,
            [
              [22, 6, [[22, 49]]],
              [23, 6, [[23, 49]]],
              [24, 6, [[24, 49]]]
            ]
          ]
        ]
      ],
      [27, 2]
    ]
  ]
]);
function StructuredListSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["rows"]);
  push($$props, false, StructuredListSkeleton);
  let rows = prop($$props, "rows", 8, 5);
  var div = root111();
  let attributes;
  var div_1 = child(div);
  toggle_class(div_1, "bx--structured-list-thead", true);
  var div_2 = child(div_1);
  toggle_class(div_2, "bx--structured-list-row", true);
  toggle_class(div_2, "bx--structured-list-row--header-row", true);
  var div_3 = child(div_2);
  toggle_class(div_3, "bx--structured-list-th", true);
  var div_4 = sibling(div_3, 2);
  toggle_class(div_4, "bx--structured-list-th", true);
  var div_5 = sibling(div_4, 2);
  toggle_class(div_5, "bx--structured-list-th", true);
  reset(div_2);
  reset(div_1);
  var div_6 = sibling(div_1, 2);
  toggle_class(div_6, "bx--structured-list-tbody", true);
  validate_each_keys(() => Array.from({ length: rows() }, (_, i) => i), (row) => row);
  each(div_6, 7, () => Array.from({ length: rows() }, (_, i) => i), (row) => row, ($$anchor2, row) => {
    var div_7 = root_178();
    toggle_class(div_7, "bx--structured-list-row", true);
    var div_8 = child(div_7);
    toggle_class(div_8, "bx--structured-list-td", true);
    var div_9 = sibling(div_8, 2);
    toggle_class(div_9, "bx--structured-list-td", true);
    var div_10 = sibling(div_9, 2);
    toggle_class(div_10, "bx--structured-list-td", true);
    reset(div_7);
    append($$anchor2, div_7);
  });
  reset(div_6);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--skeleton", true);
    toggle_class(div, "bx--structured-list", true);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  StructuredListSkeleton = hmr(StructuredListSkeleton, () => StructuredListSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StructuredListSkeleton[HMR].source;
    set(StructuredListSkeleton[HMR].source, module.default[HMR].original);
  });
}
var StructuredListSkeleton_default = StructuredListSkeleton;
mark_module_end(StructuredListSkeleton);

// node_modules/carbon-components-svelte/src/StructuredList/StructuredListBody.svelte
mark_module_start();
StructuredListBody[FILENAME] = "node_modules/carbon-components-svelte/src/StructuredList/StructuredListBody.svelte";
var root112 = add_locations(template(`<div><!></div>`), StructuredListBody[FILENAME], [[3, 0]]);
function StructuredListBody($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, StructuredListBody);
  var div = root112();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { role: "rowgroup", ...$$restProps });
    toggle_class(div, "bx--structured-list-tbody", true);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  StructuredListBody = hmr(StructuredListBody, () => StructuredListBody[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StructuredListBody[HMR].source;
    set(StructuredListBody[HMR].source, module.default[HMR].original);
  });
}
var StructuredListBody_default = StructuredListBody;
mark_module_end(StructuredListBody);

// node_modules/carbon-components-svelte/src/StructuredList/StructuredListHead.svelte
mark_module_start();
StructuredListHead[FILENAME] = "node_modules/carbon-components-svelte/src/StructuredList/StructuredListHead.svelte";
var root113 = add_locations(template(`<div><!></div>`), StructuredListHead[FILENAME], [[3, 0]]);
function StructuredListHead($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, StructuredListHead);
  var div = root113();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { role: "rowgroup", ...$$restProps });
    toggle_class(div, "bx--structured-list-thead", true);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  StructuredListHead = hmr(StructuredListHead, () => StructuredListHead[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StructuredListHead[HMR].source;
    set(StructuredListHead[HMR].source, module.default[HMR].original);
  });
}
var StructuredListHead_default = StructuredListHead;
mark_module_end(StructuredListHead);

// node_modules/carbon-components-svelte/src/StructuredList/StructuredListCell.svelte
mark_module_start();
StructuredListCell[FILENAME] = "node_modules/carbon-components-svelte/src/StructuredList/StructuredListCell.svelte";
var root114 = add_locations(template(`<div><!></div>`), StructuredListCell[FILENAME], [[10, 0]]);
function StructuredListCell($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["head", "noWrap"]);
  push($$props, false, StructuredListCell);
  let head2 = prop($$props, "head", 8, false);
  let noWrap = prop($$props, "noWrap", 8, false);
  var div = root114();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, {
      role: head2() ? "columnheader" : "cell",
      ...$$restProps
    });
    toggle_class(div, "bx--structured-list-th", head2());
    toggle_class(div, "bx--structured-list-td", !head2());
    toggle_class(div, "bx--structured-list-content--nowrap", noWrap());
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  StructuredListCell = hmr(StructuredListCell, () => StructuredListCell[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StructuredListCell[HMR].source;
    set(StructuredListCell[HMR].source, module.default[HMR].original);
  });
}
var StructuredListCell_default = StructuredListCell;
mark_module_end(StructuredListCell);

// node_modules/carbon-components-svelte/src/StructuredList/StructuredListRow.svelte
mark_module_start();
StructuredListRow[FILENAME] = "node_modules/carbon-components-svelte/src/StructuredList/StructuredListRow.svelte";
var root_179 = add_locations(template(`<label><!></label>`), StructuredListRow[FILENAME], [[17, 2]]);
var root_228 = add_locations(template(`<div><!></div>`), StructuredListRow[FILENAME], [[32, 2]]);
function StructuredListRow($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["head", "label", "tabindex"]);
  push($$props, false, StructuredListRow);
  let head2 = prop($$props, "head", 8, false);
  let label = prop($$props, "label", 8, false);
  let tabindex = prop($$props, "tabindex", 8, "0");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var label_1 = root_179();
      let attributes;
      var node_1 = child(label_1);
      slot(node_1, $$props, "default", {}, null);
      reset(label_1);
      template_effect(() => {
        attributes = set_attributes(label_1, attributes, { tabindex: tabindex(), ...$$restProps });
        toggle_class(label_1, "bx--structured-list-row", true);
        toggle_class(label_1, "bx--structured-list-row--header-row", head2());
      });
      event2("click", label_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseover", label_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseenter", label_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseleave", label_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("keydown", label_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, label_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_228();
      let attributes_1;
      var node_2 = child(div);
      slot(node_2, $$props, "default", {}, null);
      reset(div);
      template_effect(() => {
        attributes_1 = set_attributes(div, attributes_1, { role: "row", ...$$restProps });
        toggle_class(div, "bx--structured-list-row", true);
        toggle_class(div, "bx--structured-list-row--header-row", head2());
      });
      event2("click", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseover", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseenter", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event2("mouseleave", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if (label()) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  StructuredListRow = hmr(StructuredListRow, () => StructuredListRow[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StructuredListRow[HMR].source;
    set(StructuredListRow[HMR].source, module.default[HMR].original);
  });
}
var StructuredListRow_default = StructuredListRow;
mark_module_end(StructuredListRow);

// node_modules/carbon-components-svelte/src/StructuredList/StructuredListInput.svelte
mark_module_start();
StructuredListInput[FILENAME] = "node_modules/carbon-components-svelte/src/StructuredList/StructuredListInput.svelte";
var root115 = add_locations(template(`<input>`), StructuredListInput[FILENAME], [[31, 0]]);
function StructuredListInput($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "checked",
    "title",
    "value",
    "id",
    "name",
    "ref"
  ]);
  push($$props, false, StructuredListInput);
  const [$$stores, $$cleanup] = setup_stores();
  const $selectedValue = () => (validate_store(selectedValue, "selectedValue"), store_get(selectedValue, "$selectedValue", $$stores));
  let checked = prop($$props, "checked", 12, false);
  let title = prop($$props, "title", 8, "title");
  let value = prop($$props, "value", 8, "value");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let name = prop($$props, "name", 8, "");
  let ref = prop($$props, "ref", 12, null);
  const { selectedValue, update: update2 } = getContext("StructuredListWrapper");
  if (checked()) {
    update2(value());
  }
  legacy_pre_effect(
    () => ($selectedValue(), deep_read_state(value())),
    () => {
      checked(strict_equals($selectedValue(), value()));
    }
  );
  legacy_pre_effect_reset();
  init();
  var input = root115();
  remove_input_defaults(input);
  let attributes;
  bind_this(input, ($$value) => ref($$value), () => ref());
  template_effect(() => {
    attributes = set_attributes(input, attributes, {
      type: "radio",
      tabindex: "-1",
      checked: checked(),
      id: id(),
      name: name(),
      title: title(),
      value: value(),
      ...$$restProps
    });
    toggle_class(input, "bx--structured-list-input", true);
  });
  event2("change", input, () => {
    update2(value());
  });
  append($$anchor, input);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  StructuredListInput = hmr(StructuredListInput, () => StructuredListInput[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StructuredListInput[HMR].source;
    set(StructuredListInput[HMR].source, module.default[HMR].original);
  });
}
var StructuredListInput_default = StructuredListInput;
mark_module_end(StructuredListInput);

// node_modules/carbon-components-svelte/src/Tabs/Tabs.svelte
mark_module_start();
Tabs[FILENAME] = "node_modules/carbon-components-svelte/src/Tabs/Tabs.svelte";
var root116 = add_locations(template(`<div><div role="listbox" tabindex="0"><a tabindex="-1"><!></a> <!></div> <ul role="tablist"><!></ul></div> <!>`, 1), Tabs[FILENAME], [
  [
    126,
    0,
    [
      [132, 2, [[145, 4]]],
      [159, 2]
    ]
  ]
]);
function Tabs($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "selected",
    "type",
    "autoWidth",
    "iconDescription",
    "triggerHref"
  ]);
  push($$props, false, Tabs);
  const [$$stores, $$cleanup] = setup_stores();
  const $tabsById = () => (validate_store(tabsById, "tabsById"), store_get(tabsById, "$tabsById", $$stores));
  const $tabs = () => (validate_store(tabs, "tabs"), store_get(tabs, "$tabs", $$stores));
  const $content = () => (validate_store(content, "content"), store_get(content, "$content", $$stores));
  const $selectedTab = () => (validate_store(selectedTab, "selectedTab"), store_get(selectedTab, "$selectedTab", $$stores));
  const currentTab = mutable_state();
  const currentContent = mutable_state();
  let selected = prop($$props, "selected", 12, 0);
  let type = prop($$props, "type", 8, "default");
  let autoWidth = prop($$props, "autoWidth", 8, false);
  let iconDescription = prop($$props, "iconDescription", 8, "Show menu options");
  let triggerHref = prop($$props, "triggerHref", 8, "#");
  const dispatch = createEventDispatcher();
  const tabs = writable([]);
  const tabsById = derived2(tabs, (_) => _.reduce((a, c) => ({ ...a, [c.id]: c }), {}));
  const useAutoWidth = writable(autoWidth());
  const selectedTab = writable(void 0);
  const content = writable([]);
  const contentById = derived2(content, (_) => _.reduce((a, c) => ({ ...a, [c.id]: c }), {}));
  const selectedContent = writable(void 0);
  let refTabList = mutable_state(null);
  setContext("Tabs", {
    tabs,
    contentById,
    selectedTab,
    selectedContent,
    useAutoWidth,
    add: (data) => {
      tabs.update((_) => [..._, { ...data, index: _.length }]);
    },
    addContent: (data) => {
      content.update((_) => [..._, { ...data, index: _.length }]);
    },
    update: (id) => {
      set(currentIndex, $tabsById()[id].index);
    },
    change: async (direction) => {
      var _a;
      let index2 = get(currentIndex) + direction;
      if (index2 < 0) {
        index2 = $tabs().length - 1;
      } else if (index2 >= $tabs().length) {
        index2 = 0;
      }
      let disabled = $tabs()[index2].disabled;
      while (disabled) {
        index2 = index2 + direction;
        if (index2 < 0) {
          index2 = $tabs().length - 1;
        } else if (index2 >= $tabs().length) {
          index2 = 0;
        }
        disabled = $tabs()[index2].disabled;
      }
      set(currentIndex, index2);
      await tick();
      const activeTab = (_a = get(refTabList)) == null ? void 0 : _a.querySelectorAll("[role='tab']")[get(currentIndex)];
      activeTab == null ? void 0 : activeTab.focus();
    }
  });
  afterUpdate(() => {
    selected(get(currentIndex));
    if (prevIndex > -1 && strict_equals(prevIndex, get(currentIndex), false)) {
      dispatch("change", get(currentIndex));
    }
    prevIndex = get(currentIndex);
  });
  let dropdownHidden = mutable_state(true);
  let currentIndex = mutable_state(selected());
  let prevIndex = -1;
  legacy_pre_effect(() => deep_read_state(selected()), () => {
    set(currentIndex, selected());
  });
  legacy_pre_effect(() => ($tabs(), get(currentIndex)), () => {
    set(currentTab, $tabs()[get(currentIndex)] || void 0);
  });
  legacy_pre_effect(() => ($content(), get(currentIndex)), () => {
    set(currentContent, $content()[get(currentIndex)] || void 0);
  });
  legacy_pre_effect(
    () => (get(currentTab), get(currentContent)),
    () => {
      if (get(currentTab)) {
        selectedTab.set(get(currentTab).id);
      }
      if (get(currentContent)) {
        selectedContent.set(get(currentContent).id);
      }
    }
  );
  legacy_pre_effect(() => $selectedTab(), () => {
    if ($selectedTab()) {
      set(dropdownHidden, true);
    }
  });
  legacy_pre_effect(() => deep_read_state(autoWidth()), () => {
    useAutoWidth.set(autoWidth());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = root116();
  var div = first_child(fragment);
  let attributes;
  var div_1 = child(div);
  var a_1 = child(div_1);
  var node = child(a_1);
  {
    var consequent = ($$anchor2) => {
      var text2 = text();
      template_effect(() => set_text(text2, get(currentTab).label));
      append($$anchor2, text2);
    };
    if_block(node, ($$render) => {
      if (get(currentTab)) $$render(consequent);
    });
  }
  reset(a_1);
  var node_1 = sibling(a_1, 2);
  ChevronDown_default(node_1, {
    "aria-hidden": "true",
    get title() {
      return iconDescription();
    }
  });
  reset(div_1);
  var ul = sibling(div_1, 2);
  toggle_class(ul, "bx--tabs__nav", true);
  var node_2 = child(ul);
  slot(node_2, $$props, "default", {}, null);
  reset(ul);
  bind_this(ul, ($$value) => set(refTabList, $$value), () => get(refTabList));
  reset(div);
  var node_3 = sibling(div, 2);
  slot(node_3, $$props, "content", {}, null);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { role: "navigation", ...$$restProps });
    toggle_class(div, "bx--tabs", true);
    toggle_class(div, "bx--tabs--container", strict_equals(type(), "container"));
    set_attribute(div_1, "aria-label", $$sanitized_props["aria-label"] || "listbox");
    toggle_class(div_1, "bx--tabs-trigger", true);
    set_attribute(a_1, "href", triggerHref());
    toggle_class(a_1, "bx--tabs-trigger-text", true);
    toggle_class(ul, "bx--tabs__nav--hidden", get(dropdownHidden));
  });
  event2("click", a_1, preventDefault(function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  }));
  event2("click", a_1, preventDefault(stopPropagation(() => {
    set(dropdownHidden, !get(dropdownHidden));
  })));
  event2("click", div_1, () => {
    set(dropdownHidden, !get(dropdownHidden));
  });
  event2("keypress", div_1, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keypress", div_1, () => {
    set(dropdownHidden, !get(dropdownHidden));
  });
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Tabs = hmr(Tabs, () => Tabs[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tabs[HMR].source;
    set(Tabs[HMR].source, module.default[HMR].original);
  });
}
var Tabs_default = Tabs;
mark_module_end(Tabs);

// node_modules/carbon-components-svelte/src/Tabs/Tab.svelte
mark_module_start();
Tab[FILENAME] = "node_modules/carbon-components-svelte/src/Tabs/Tab.svelte";
var root117 = add_locations(template(`<li><a role="tab"><!></a></li>`), Tab[FILENAME], [[33, 0, [[61, 2]]]]);
function Tab($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "label",
    "href",
    "disabled",
    "tabindex",
    "id",
    "ref"
  ]);
  push($$props, false, Tab);
  const [$$stores, $$cleanup] = setup_stores();
  const $selectedTab = () => (validate_store(selectedTab, "selectedTab"), store_get(selectedTab, "$selectedTab", $$stores));
  const $useAutoWidth = () => (validate_store(useAutoWidth, "useAutoWidth"), store_get(useAutoWidth, "$useAutoWidth", $$stores));
  const selected = mutable_state();
  let label = prop($$props, "label", 8, "");
  let href = prop($$props, "href", 8, "#");
  let disabled = prop($$props, "disabled", 8, false);
  let tabindex = prop($$props, "tabindex", 8, "0");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let ref = prop($$props, "ref", 12, null);
  const {
    selectedTab,
    useAutoWidth,
    add,
    update: update2,
    change
  } = getContext("Tabs");
  add({
    id: id(),
    label: label(),
    disabled: disabled()
  });
  legacy_pre_effect(
    () => ($selectedTab(), deep_read_state(id())),
    () => {
      set(selected, strict_equals($selectedTab(), id()));
    }
  );
  legacy_pre_effect_reset();
  init();
  var li = root117();
  let attributes;
  var a = child(li);
  var node = child(a);
  slot(node, $$props, "default", {}, ($$anchor2) => {
    var text2 = text();
    template_effect(() => set_text(text2, label()));
    append($$anchor2, text2);
  });
  reset(a);
  bind_this(a, ($$value) => ref($$value), () => ref());
  reset(li);
  template_effect(() => {
    attributes = set_attributes(li, attributes, {
      tabindex: "-1",
      role: "presentation",
      ...$$restProps
    });
    toggle_class(li, "bx--tabs__nav-item", true);
    toggle_class(li, "bx--tabs__nav-item--disabled", disabled());
    toggle_class(li, "bx--tabs__nav-item--selected", get(selected));
    set_attribute(a, "tabindex", disabled() ? "-1" : tabindex());
    set_attribute(a, "aria-selected", get(selected));
    set_attribute(a, "aria-disabled", disabled());
    set_attribute(a, "id", id());
    set_attribute(a, "href", href());
    toggle_class(a, "bx--tabs__nav-link", true);
    set_style(a, "width", $useAutoWidth() ? "auto" : void 0);
  });
  event2("click", li, preventDefault(function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  }));
  event2("click", li, preventDefault(() => {
    if (!disabled()) {
      update2(id());
    }
  }));
  event2("mouseover", li, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", li, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", li, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", li, ({ key }) => {
    if (!disabled()) {
      if (strict_equals(key, "ArrowRight")) {
        change(1);
      } else if (strict_equals(key, "ArrowLeft")) {
        change(-1);
      } else if (strict_equals(key, " ") || strict_equals(key, "Enter")) {
        update2(id());
      }
    }
  });
  append($$anchor, li);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Tab = hmr(Tab, () => Tab[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tab[HMR].source;
    set(Tab[HMR].source, module.default[HMR].original);
  });
}
var Tab_default = Tab;
mark_module_end(Tab);

// node_modules/carbon-components-svelte/src/Tabs/TabContent.svelte
mark_module_start();
TabContent[FILENAME] = "node_modules/carbon-components-svelte/src/Tabs/TabContent.svelte";
var root118 = add_locations(template(`<div><!></div>`), TabContent[FILENAME], [[16, 0]]);
function TabContent($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["id"]);
  push($$props, false, TabContent);
  const [$$stores, $$cleanup] = setup_stores();
  const $selectedContent = () => (validate_store(selectedContent, "selectedContent"), store_get(selectedContent, "$selectedContent", $$stores));
  const $contentById = () => (validate_store(contentById, "contentById"), store_get(contentById, "$contentById", $$stores));
  const $tabs = () => (validate_store(tabs, "tabs"), store_get(tabs, "$tabs", $$stores));
  const selected = mutable_state();
  const index2 = mutable_state();
  const tabId = mutable_state();
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  const {
    selectedContent,
    addContent,
    tabs,
    contentById
  } = getContext("Tabs");
  addContent({ id: id() });
  legacy_pre_effect(
    () => ($selectedContent(), deep_read_state(id())),
    () => {
      set(selected, strict_equals($selectedContent(), id()));
    }
  );
  legacy_pre_effect(
    () => ($contentById(), deep_read_state(id())),
    () => {
      set(index2, $contentById()[id()].index);
    }
  );
  legacy_pre_effect(() => ($tabs(), get(index2)), () => {
    set(tabId, $tabs()[get(index2)].id);
  });
  legacy_pre_effect_reset();
  init();
  var div = root118();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, {
      role: "tabpanel",
      "aria-labelledby": get(tabId),
      "aria-hidden": !get(selected),
      hidden: get(selected) ? void 0 : "",
      id: id(),
      ...$$restProps
    });
    toggle_class(div, "bx--tab-content", true);
  });
  append($$anchor, div);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  TabContent = hmr(TabContent, () => TabContent[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TabContent[HMR].source;
    set(TabContent[HMR].source, module.default[HMR].original);
  });
}
var TabContent_default = TabContent;
mark_module_end(TabContent);

// node_modules/carbon-components-svelte/src/Tabs/TabsSkeleton.svelte
mark_module_start();
TabsSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/Tabs/TabsSkeleton.svelte";
var root_180 = add_locations(template(`<li><div><span></span></div></li>`), TabsSkeleton[FILENAME], [
  [27, 6, [[28, 8, [[29, 10]]]]]
]);
var root119 = add_locations(template(`<div><ul></ul></div>`), TabsSkeleton[FILENAME], [[14, 0, [[25, 2]]]]);
function TabsSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["count", "type"]);
  push($$props, false, TabsSkeleton);
  let count = prop($$props, "count", 8, 4);
  let type = prop($$props, "type", 8, "default");
  var div = root119();
  let attributes;
  var ul = child(div);
  toggle_class(ul, "bx--tabs--scrollable__nav", true);
  each(ul, 5, () => Array.from({ length: count() }, (_, i) => i), index, ($$anchor2, item) => {
    var li = root_180();
    toggle_class(li, "bx--tabs--scrollable__nav-item", true);
    var div_1 = child(li);
    toggle_class(div_1, "bx--tabs__nav-link", true);
    reset(li);
    append($$anchor2, li);
  });
  reset(ul);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--tabs", true);
    toggle_class(div, "bx--skeleton", true);
    toggle_class(div, "bx--tabs--scrollable", true);
    toggle_class(div, "bx--tabs--scrollable--container", strict_equals(type(), "container"));
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TabsSkeleton = hmr(TabsSkeleton, () => TabsSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TabsSkeleton[HMR].source;
    set(TabsSkeleton[HMR].source, module.default[HMR].original);
  });
}
var TabsSkeleton_default = TabsSkeleton;
mark_module_end(TabsSkeleton);

// node_modules/carbon-components-svelte/src/Tag/TagSkeleton.svelte
mark_module_start();
TagSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/Tag/TagSkeleton.svelte";
var root120 = add_locations(template(`<span></span>`), TagSkeleton[FILENAME], [[8, 0]]);
function TagSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size"]);
  push($$props, false, TagSkeleton);
  let size = prop($$props, "size", 8, "default");
  var span = root120();
  let attributes;
  template_effect(() => {
    attributes = set_attributes(span, attributes, { ...$$restProps });
    toggle_class(span, "bx--tag", true);
    toggle_class(span, "bx--tag--sm", strict_equals(size(), "sm"));
    toggle_class(span, "bx--skeleton", true);
  });
  event2("click", span, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", span, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", span, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", span, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, span);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TagSkeleton = hmr(TagSkeleton, () => TagSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TagSkeleton[HMR].source;
    set(TagSkeleton[HMR].source, module.default[HMR].original);
  });
}
var TagSkeleton_default = TagSkeleton;
mark_module_end(TagSkeleton);

// node_modules/carbon-components-svelte/src/Tag/Tag.svelte
mark_module_start();
Tag[FILENAME] = "node_modules/carbon-components-svelte/src/Tag/Tag.svelte";
var root_49 = add_locations(template(`<span> </span>`), Tag[FILENAME], [[77, 6]]);
var root_315 = add_locations(template(`<div><!> <button type="button"><!></button></div>`), Tag[FILENAME], [[55, 2, [[79, 4]]]]);
var root_710 = add_locations(template(`<div><!></div>`), Tag[FILENAME], [[126, 6]]);
var root_611 = add_locations(template(`<button><!> <span><!></span></button>`), Tag[FILENAME], [[97, 2, [[132, 4]]]]);
var root_106 = add_locations(template(`<div><!></div>`), Tag[FILENAME], [[162, 6]]);
var root_93 = add_locations(template(`<div><!> <span><!></span></div>`), Tag[FILENAME], [[138, 2, [[168, 4]]]]);
function Tag($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "type",
    "size",
    "filter",
    "disabled",
    "interactive",
    "skeleton",
    "title",
    "icon",
    "id"
  ]);
  push($$props, false, Tag);
  let type = prop($$props, "type", 8, void 0);
  let size = prop($$props, "size", 8, "default");
  let filter = prop($$props, "filter", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let interactive = prop($$props, "interactive", 8, false);
  let skeleton = prop($$props, "skeleton", 8, false);
  let title = prop($$props, "title", 8, "Clear filter");
  let icon = prop($$props, "icon", 8, void 0);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  const dispatch = createEventDispatcher();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      TagSkeleton_default(node_1, spread_props(
        {
          get size() {
            return size();
          }
        },
        () => $$restProps,
        {
          $$events: {
            click($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            mouseover($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            mouseenter($$arg) {
              bubble_event.call(this, $$props, $$arg);
            },
            mouseleave($$arg) {
              bubble_event.call(this, $$props, $$arg);
            }
          }
        }
      ));
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      {
        var consequent_1 = ($$anchor3) => {
          var div = root_315();
          let attributes;
          var node_3 = child(div);
          slot(node_3, $$props, "default", { props: { class: "bx--tag__label" } }, ($$anchor4) => {
            var span = root_49();
            toggle_class(span, "bx--tag__label", true);
            var text2 = child(span, true);
            reset(span);
            template_effect(() => set_text(text2, type()));
            append($$anchor4, span);
          });
          var button = sibling(node_3, 2);
          var node_4 = child(button);
          Close_default(node_4, {});
          reset(button);
          reset(div);
          template_effect(() => {
            attributes = set_attributes(div, attributes, {
              "aria-label": title(),
              id: id(),
              ...$$restProps
            });
            toggle_class(div, "bx--tag", true);
            toggle_class(div, "bx--tag--disabled", disabled());
            toggle_class(div, "bx--tag--filter", filter());
            toggle_class(div, "bx--tag--sm", strict_equals(size(), "sm"));
            toggle_class(div, "bx--tag--red", strict_equals(type(), "red"));
            toggle_class(div, "bx--tag--magenta", strict_equals(type(), "magenta"));
            toggle_class(div, "bx--tag--purple", strict_equals(type(), "purple"));
            toggle_class(div, "bx--tag--blue", strict_equals(type(), "blue"));
            toggle_class(div, "bx--tag--cyan", strict_equals(type(), "cyan"));
            toggle_class(div, "bx--tag--teal", strict_equals(type(), "teal"));
            toggle_class(div, "bx--tag--green", strict_equals(type(), "green"));
            toggle_class(div, "bx--tag--gray", strict_equals(type(), "gray"));
            toggle_class(div, "bx--tag--cool-gray", strict_equals(type(), "cool-gray"));
            toggle_class(div, "bx--tag--warm-gray", strict_equals(type(), "warm-gray"));
            toggle_class(div, "bx--tag--high-contrast", strict_equals(type(), "high-contrast"));
            toggle_class(div, "bx--tag--outline", strict_equals(type(), "outline"));
            set_attribute(button, "aria-labelledby", id());
            button.disabled = disabled();
            set_attribute(button, "title", title());
            toggle_class(button, "bx--tag__close-icon", true);
          });
          event2("click", button, stopPropagation(function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          }));
          event2("click", button, stopPropagation(() => {
            dispatch("close");
          }));
          event2("mouseover", button, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event2("mouseenter", button, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event2("mouseleave", button, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          append($$anchor3, div);
        };
        var alternate_1 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_5 = first_child(fragment_3);
          {
            var consequent_3 = ($$anchor4) => {
              var button_1 = root_611();
              let attributes_1;
              var node_6 = child(button_1);
              {
                var consequent_2 = ($$anchor5) => {
                  var div_1 = root_710();
                  toggle_class(div_1, "bx--tag__custom-icon", true);
                  var node_7 = child(div_1);
                  slot(node_7, $$props, "icon", {}, ($$anchor6) => {
                    var fragment_4 = comment();
                    var node_8 = first_child(fragment_4);
                    component(node_8, icon, ($$anchor7, $$component) => {
                      $$component($$anchor7, {});
                    });
                    append($$anchor6, fragment_4);
                  });
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                if_block(node_6, ($$render) => {
                  if ($$slots.icon || icon()) $$render(consequent_2);
                });
              }
              var span_1 = sibling(node_6, 2);
              var node_9 = child(span_1);
              slot(node_9, $$props, "default", {}, null);
              reset(span_1);
              reset(button_1);
              template_effect(() => {
                attributes_1 = set_attributes(button_1, attributes_1, {
                  type: "button",
                  id: id(),
                  disabled: disabled(),
                  "aria-disabled": disabled(),
                  tabindex: disabled() ? "-1" : void 0,
                  ...$$restProps
                });
                toggle_class(button_1, "bx--tag", true);
                toggle_class(button_1, "bx--tag--interactive", true);
                toggle_class(button_1, "bx--tag--disabled", disabled());
                toggle_class(button_1, "bx--tag--sm", strict_equals(size(), "sm"));
                toggle_class(button_1, "bx--tag--red", strict_equals(type(), "red"));
                toggle_class(button_1, "bx--tag--magenta", strict_equals(type(), "magenta"));
                toggle_class(button_1, "bx--tag--purple", strict_equals(type(), "purple"));
                toggle_class(button_1, "bx--tag--blue", strict_equals(type(), "blue"));
                toggle_class(button_1, "bx--tag--cyan", strict_equals(type(), "cyan"));
                toggle_class(button_1, "bx--tag--teal", strict_equals(type(), "teal"));
                toggle_class(button_1, "bx--tag--green", strict_equals(type(), "green"));
                toggle_class(button_1, "bx--tag--gray", strict_equals(type(), "gray"));
                toggle_class(button_1, "bx--tag--cool-gray", strict_equals(type(), "cool-gray"));
                toggle_class(button_1, "bx--tag--warm-gray", strict_equals(type(), "warm-gray"));
                toggle_class(button_1, "bx--tag--high-contrast", strict_equals(type(), "high-contrast"));
                toggle_class(button_1, "bx--tag--outline", strict_equals(type(), "outline"));
              });
              event2("click", button_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("mouseover", button_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("mouseenter", button_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("mouseleave", button_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              append($$anchor4, button_1);
            };
            var alternate = ($$anchor4) => {
              var div_2 = root_93();
              let attributes_2;
              var node_10 = child(div_2);
              {
                var consequent_4 = ($$anchor5) => {
                  var div_3 = root_106();
                  toggle_class(div_3, "bx--tag__custom-icon", true);
                  var node_11 = child(div_3);
                  slot(node_11, $$props, "icon", {}, ($$anchor6) => {
                    var fragment_5 = comment();
                    var node_12 = first_child(fragment_5);
                    component(node_12, icon, ($$anchor7, $$component) => {
                      $$component($$anchor7, {});
                    });
                    append($$anchor6, fragment_5);
                  });
                  reset(div_3);
                  append($$anchor5, div_3);
                };
                if_block(node_10, ($$render) => {
                  if ($$slots.icon || icon()) $$render(consequent_4);
                });
              }
              var span_2 = sibling(node_10, 2);
              var node_13 = child(span_2);
              slot(node_13, $$props, "default", {}, null);
              reset(span_2);
              reset(div_2);
              template_effect(() => {
                attributes_2 = set_attributes(div_2, attributes_2, { id: id(), ...$$restProps });
                toggle_class(div_2, "bx--tag", true);
                toggle_class(div_2, "bx--tag--disabled", disabled());
                toggle_class(div_2, "bx--tag--sm", strict_equals(size(), "sm"));
                toggle_class(div_2, "bx--tag--red", strict_equals(type(), "red"));
                toggle_class(div_2, "bx--tag--magenta", strict_equals(type(), "magenta"));
                toggle_class(div_2, "bx--tag--purple", strict_equals(type(), "purple"));
                toggle_class(div_2, "bx--tag--blue", strict_equals(type(), "blue"));
                toggle_class(div_2, "bx--tag--cyan", strict_equals(type(), "cyan"));
                toggle_class(div_2, "bx--tag--teal", strict_equals(type(), "teal"));
                toggle_class(div_2, "bx--tag--green", strict_equals(type(), "green"));
                toggle_class(div_2, "bx--tag--gray", strict_equals(type(), "gray"));
                toggle_class(div_2, "bx--tag--cool-gray", strict_equals(type(), "cool-gray"));
                toggle_class(div_2, "bx--tag--warm-gray", strict_equals(type(), "warm-gray"));
                toggle_class(div_2, "bx--tag--high-contrast", strict_equals(type(), "high-contrast"));
                toggle_class(div_2, "bx--tag--outline", strict_equals(type(), "outline"));
              });
              event2("click", div_2, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("mouseover", div_2, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("mouseenter", div_2, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event2("mouseleave", div_2, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              append($$anchor4, div_2);
            };
            if_block(
              node_5,
              ($$render) => {
                if (interactive()) $$render(consequent_3);
                else $$render(alternate, false);
              },
              true
            );
          }
          append($$anchor3, fragment_3);
        };
        if_block(
          node_2,
          ($$render) => {
            if (filter()) $$render(consequent_1);
            else $$render(alternate_1, false);
          },
          true
        );
      }
      append($$anchor2, fragment_2);
    };
    if_block(node, ($$render) => {
      if (skeleton()) $$render(consequent);
      else $$render(alternate_2, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tag = hmr(Tag, () => Tag[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tag[HMR].source;
    set(Tag[HMR].source, module.default[HMR].original);
  });
}
var Tag_default = Tag;
mark_module_end(Tag);

// node_modules/carbon-components-svelte/src/TextArea/TextArea.svelte
mark_module_start();
TextArea[FILENAME] = "node_modules/carbon-components-svelte/src/TextArea/TextArea.svelte";
var root_316 = add_locations(template(`<div> </div>`), TextArea[FILENAME], [[87, 8]]);
var root_181 = add_locations(template(`<div><label><!></label> <!></div>`), TextArea[FILENAME], [[75, 4, [[76, 6]]]]);
var root_58 = add_locations(template(`<div> </div>`), TextArea[FILENAME], [[126, 4]]);
var root_612 = add_locations(template(`<div> </div>`), TextArea[FILENAME], [[134, 4]]);
var root121 = add_locations(template(`<div><!> <div><!> <textarea></textarea></div> <!> <!></div>`), TextArea[FILENAME], [
  [67, 0, [[93, 2, [[100, 4]]]]]
]);
function TextArea($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "value",
    "placeholder",
    "cols",
    "rows",
    "maxCount",
    "light",
    "disabled",
    "readonly",
    "helperText",
    "labelText",
    "hideLabel",
    "invalid",
    "invalidText",
    "id",
    "name",
    "ref"
  ]);
  push($$props, false, TextArea);
  const errorId = mutable_state();
  let value = prop($$props, "value", 12, "");
  let placeholder = prop($$props, "placeholder", 8, "");
  let cols = prop($$props, "cols", 8, 50);
  let rows = prop($$props, "rows", 8, 4);
  let maxCount = prop($$props, "maxCount", 8, void 0);
  let light = prop($$props, "light", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let readonly2 = prop($$props, "readonly", 8, false);
  let helperText = prop($$props, "helperText", 8, "");
  let labelText = prop($$props, "labelText", 8, "");
  let hideLabel = prop($$props, "hideLabel", 8, false);
  let invalid = prop($$props, "invalid", 8, false);
  let invalidText = prop($$props, "invalidText", 8, "");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let name = prop($$props, "name", 8, void 0);
  let ref = prop($$props, "ref", 12, null);
  legacy_pre_effect(() => deep_read_state(id()), () => {
    set(errorId, `error-${id()}`);
  });
  legacy_pre_effect_reset();
  init();
  var div = root121();
  toggle_class(div, "bx--form-item", true);
  var node = child(div);
  {
    var consequent_1 = ($$anchor2) => {
      var div_1 = root_181();
      toggle_class(div_1, "bx--text-area__label-wrapper", true);
      var label = child(div_1);
      var node_1 = child(label);
      slot(node_1, $$props, "labelText", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, labelText()));
        append($$anchor3, text2);
      });
      reset(label);
      var node_2 = sibling(label, 2);
      {
        var consequent = ($$anchor3) => {
          var div_2 = root_316();
          toggle_class(div_2, "bx--label", true);
          var text_1 = child(div_2);
          reset(div_2);
          template_effect(() => {
            toggle_class(div_2, "bx--label--disabled", disabled());
            set_text(text_1, `${value().length ?? ""}/${maxCount() ?? ""}`);
          });
          append($$anchor3, div_2);
        };
        if_block(node_2, ($$render) => {
          if (maxCount()) $$render(consequent);
        });
      }
      reset(div_1);
      template_effect(() => {
        set_attribute(label, "for", id());
        toggle_class(label, "bx--label", true);
        toggle_class(label, "bx--visually-hidden", hideLabel());
        toggle_class(label, "bx--label--disabled", disabled());
      });
      append($$anchor2, div_1);
    };
    if_block(node, ($$render) => {
      if ((labelText() || $$slots.labelText) && !hideLabel()) $$render(consequent_1);
    });
  }
  var div_3 = sibling(node, 2);
  var node_3 = child(div_3);
  {
    var consequent_2 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_4 = first_child(fragment_1);
      WarningFilled_default(node_4, { class: "bx--text-area__invalid-icon" });
      append($$anchor2, fragment_1);
    };
    if_block(node_3, ($$render) => {
      if (invalid()) $$render(consequent_2);
    });
  }
  var textarea = sibling(node_3, 2);
  remove_textarea_child(textarea);
  let attributes;
  bind_this(textarea, ($$value) => ref($$value), () => ref());
  reset(div_3);
  var node_5 = sibling(div_3, 2);
  {
    var consequent_3 = ($$anchor2) => {
      var div_4 = root_58();
      toggle_class(div_4, "bx--form__helper-text", true);
      var text_2 = child(div_4, true);
      reset(div_4);
      template_effect(() => {
        toggle_class(div_4, "bx--form__helper-text--disabled", disabled());
        set_text(text_2, helperText());
      });
      append($$anchor2, div_4);
    };
    if_block(node_5, ($$render) => {
      if (!invalid() && helperText()) $$render(consequent_3);
    });
  }
  var node_6 = sibling(node_5, 2);
  {
    var consequent_4 = ($$anchor2) => {
      var div_5 = root_612();
      var text_3 = child(div_5, true);
      reset(div_5);
      template_effect(() => {
        set_attribute(div_5, "id", get(errorId));
        toggle_class(div_5, "bx--form-requirement", true);
        set_text(text_3, invalidText());
      });
      append($$anchor2, div_5);
    };
    if_block(node_6, ($$render) => {
      if (invalid()) $$render(consequent_4);
    });
  }
  reset(div);
  template_effect(() => {
    set_attribute(div_3, "data-invalid", invalid() || void 0);
    toggle_class(div_3, "bx--text-area__wrapper", true);
    attributes = set_attributes(textarea, attributes, {
      "aria-invalid": invalid() || void 0,
      "aria-describedby": invalid() ? get(errorId) : void 0,
      disabled: disabled(),
      id: id(),
      name: name(),
      cols: cols(),
      rows: rows(),
      placeholder: placeholder(),
      readonly: readonly2(),
      maxlength: maxCount() ?? void 0,
      ...$$restProps
    });
    toggle_class(textarea, "bx--text-area", true);
    toggle_class(textarea, "bx--text-area--light", light());
    toggle_class(textarea, "bx--text-area--invalid", invalid());
  });
  bind_value(textarea, value);
  event2("change", textarea, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("input", textarea, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", textarea, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keyup", textarea, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("focus", textarea, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("blur", textarea, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("paste", textarea, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TextArea = hmr(TextArea, () => TextArea[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TextArea[HMR].source;
    set(TextArea[HMR].source, module.default[HMR].original);
  });
}
var TextArea_default = TextArea;
mark_module_end(TextArea);

// node_modules/carbon-components-svelte/src/TextArea/TextAreaSkeleton.svelte
mark_module_start();
TextAreaSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/TextArea/TextAreaSkeleton.svelte";
var root_182 = add_locations(template(`<span></span>`), TextAreaSkeleton[FILENAME], [[17, 4]]);
var root122 = add_locations(template(`<div><!> <div></div></div>`), TextAreaSkeleton[FILENAME], [[8, 0, [[19, 2]]]]);
function TextAreaSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["hideLabel"]);
  push($$props, false, TextAreaSkeleton);
  let hideLabel = prop($$props, "hideLabel", 8, false);
  var div = root122();
  let attributes;
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var span = root_182();
      toggle_class(span, "bx--label", true);
      toggle_class(span, "bx--skeleton", true);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if (!hideLabel()) $$render(consequent);
    });
  }
  var div_1 = sibling(node, 2);
  toggle_class(div_1, "bx--skeleton", true);
  toggle_class(div_1, "bx--text-area", true);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--form-item", true);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TextAreaSkeleton = hmr(TextAreaSkeleton, () => TextAreaSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TextAreaSkeleton[HMR].source;
    set(TextAreaSkeleton[HMR].source, module.default[HMR].original);
  });
}
var TextAreaSkeleton_default = TextAreaSkeleton;
mark_module_end(TextAreaSkeleton);

// node_modules/carbon-components-svelte/src/TextInput/TextInput.svelte
mark_module_start();
TextInput[FILENAME] = "node_modules/carbon-components-svelte/src/TextInput/TextInput.svelte";
var root_229 = add_locations(template(`<label><!></label>`), TextInput[FILENAME], [[121, 8]]);
var root_410 = add_locations(template(`<div> </div>`), TextInput[FILENAME], [[136, 8]]);
var root_183 = add_locations(template(`<div><!> <!></div>`), TextInput[FILENAME], [[119, 4]]);
var root_59 = add_locations(template(`<label><!></label>`), TextInput[FILENAME], [[147, 4]]);
var root_86 = add_locations(template(`<!> <!>`, 1), TextInput[FILENAME], []);
var root_1113 = add_locations(template(`<hr>`), TextInput[FILENAME], [[219, 8]]);
var root_1212 = add_locations(template(`<div> </div>`), TextInput[FILENAME], [[222, 8]]);
var root_1310 = add_locations(template(`<div> </div>`), TextInput[FILENAME], [[227, 8]]);
var root_1410 = add_locations(template(`<div> </div>`), TextInput[FILENAME], [[231, 6]]);
var root_1510 = add_locations(template(`<div> </div>`), TextInput[FILENAME], [[241, 6]]);
var root_1610 = add_locations(template(`<div> </div>`), TextInput[FILENAME], [[246, 6]]);
var root123 = add_locations(template(`<div><!> <!> <div><div><!> <input> <!> <!> <!></div> <!> <!> <!></div></div>`), TextInput[FILENAME], [
  [
    107,
    0,
    [
      [
        161,
        2,
        [[165, 4, [[184, 6]]]]
      ]
    ]
  ]
]);
function TextInput($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "size",
    "value",
    "placeholder",
    "light",
    "disabled",
    "helperText",
    "id",
    "name",
    "labelText",
    "hideLabel",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "ref",
    "required",
    "inline",
    "readonly"
  ]);
  push($$props, false, TextInput);
  const error = mutable_state();
  const helperId = mutable_state();
  const errorId = mutable_state();
  const warnId = mutable_state();
  let size = prop($$props, "size", 8, void 0);
  let value = prop($$props, "value", 12, "");
  let placeholder = prop($$props, "placeholder", 8, "");
  let light = prop($$props, "light", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let helperText = prop($$props, "helperText", 8, "");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let name = prop($$props, "name", 8, void 0);
  let labelText = prop($$props, "labelText", 8, "");
  let hideLabel = prop($$props, "hideLabel", 8, false);
  let invalid = prop($$props, "invalid", 8, false);
  let invalidText = prop($$props, "invalidText", 8, "");
  let warn = prop($$props, "warn", 8, false);
  let warnText = prop($$props, "warnText", 8, "");
  let ref = prop($$props, "ref", 12, null);
  let required = prop($$props, "required", 8, false);
  let inline = prop($$props, "inline", 8, false);
  let readonly2 = prop($$props, "readonly", 8, false);
  const ctx = getContext("Form");
  const dispatch = createEventDispatcher();
  function parse(raw) {
    if (strict_equals($$restProps.type, "number", false)) return raw;
    return equals(raw, "", false) ? Number(raw) : null;
  }
  const onInput = (e) => {
    value(parse(e.target.value));
    dispatch("input", value());
  };
  const onChange = (e) => {
    dispatch("change", parse(e.target.value));
  };
  const isFluid = !!ctx && ctx.isFluid;
  legacy_pre_effect(
    () => (deep_read_state(invalid()), deep_read_state(readonly2())),
    () => {
      set(error, invalid() && !readonly2());
    }
  );
  legacy_pre_effect(() => deep_read_state(id()), () => {
    set(helperId, `helper-${id()}`);
  });
  legacy_pre_effect(() => deep_read_state(id()), () => {
    set(errorId, `error-${id()}`);
  });
  legacy_pre_effect(() => deep_read_state(id()), () => {
    set(warnId, `warn-${id()}`);
  });
  legacy_pre_effect_reset();
  init();
  var div = root123();
  toggle_class(div, "bx--form-item", true);
  toggle_class(div, "bx--text-input-wrapper", true);
  var node = child(div);
  {
    var consequent_2 = ($$anchor2) => {
      var div_1 = root_183();
      toggle_class(div_1, "bx--text-input__label-helper-wrapper", true);
      var node_1 = child(div_1);
      {
        var consequent = ($$anchor3) => {
          var label = root_229();
          var node_2 = child(label);
          slot(node_2, $$props, "labelText", {}, ($$anchor4) => {
            var text2 = text();
            template_effect(() => set_text(text2, labelText()));
            append($$anchor4, text2);
          });
          reset(label);
          template_effect(() => {
            set_attribute(label, "for", id());
            toggle_class(label, "bx--label", true);
            toggle_class(label, "bx--visually-hidden", hideLabel());
            toggle_class(label, "bx--label--disabled", disabled());
            toggle_class(label, "bx--label--inline", inline());
            toggle_class(label, "bx--label--inline--sm", strict_equals(size(), "sm"));
            toggle_class(label, "bx--label--inline--xl", strict_equals(size(), "xl"));
          });
          append($$anchor3, label);
        };
        if_block(node_1, ($$render) => {
          if (labelText()) $$render(consequent);
        });
      }
      var node_3 = sibling(node_1, 2);
      {
        var consequent_1 = ($$anchor3) => {
          var div_2 = root_410();
          toggle_class(div_2, "bx--form__helper-text", true);
          var text_1 = child(div_2, true);
          reset(div_2);
          template_effect(() => {
            toggle_class(div_2, "bx--form__helper-text--disabled", disabled());
            toggle_class(div_2, "bx--form__helper-text--inline", inline());
            set_text(text_1, helperText());
          });
          append($$anchor3, div_2);
        };
        if_block(node_3, ($$render) => {
          if (!isFluid && helperText()) $$render(consequent_1);
        });
      }
      reset(div_1);
      append($$anchor2, div_1);
    };
    if_block(node, ($$render) => {
      if (inline()) $$render(consequent_2);
    });
  }
  var node_4 = sibling(node, 2);
  {
    var consequent_3 = ($$anchor2) => {
      var label_1 = root_59();
      var node_5 = child(label_1);
      slot(node_5, $$props, "labelText", {}, ($$anchor3) => {
        var text_2 = text();
        template_effect(() => set_text(text_2, labelText()));
        append($$anchor3, text_2);
      });
      reset(label_1);
      template_effect(() => {
        set_attribute(label_1, "for", id());
        toggle_class(label_1, "bx--label", true);
        toggle_class(label_1, "bx--visually-hidden", hideLabel());
        toggle_class(label_1, "bx--label--disabled", disabled());
        toggle_class(label_1, "bx--label--inline", inline());
        toggle_class(label_1, "bx--label--inline-sm", inline() && strict_equals(size(), "sm"));
        toggle_class(label_1, "bx--label--inline-xl", inline() && strict_equals(size(), "xl"));
      });
      append($$anchor2, label_1);
    };
    if_block(node_4, ($$render) => {
      if (!inline() && (labelText() || $$slots.labelText)) $$render(consequent_3);
    });
  }
  var div_3 = sibling(node_4, 2);
  toggle_class(div_3, "bx--text-input__field-outer-wrapper", true);
  var div_4 = child(div_3);
  var node_6 = child(div_4);
  {
    var consequent_4 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_7 = first_child(fragment_2);
      EditOff_default(node_7, { class: "bx--text-input__readonly-icon" });
      append($$anchor2, fragment_2);
    };
    var alternate = ($$anchor2) => {
      var fragment_3 = root_86();
      var node_8 = first_child(fragment_3);
      {
        var consequent_5 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_9 = first_child(fragment_4);
          WarningFilled_default(node_9, { class: "bx--text-input__invalid-icon" });
          append($$anchor3, fragment_4);
        };
        if_block(node_8, ($$render) => {
          if (invalid()) $$render(consequent_5);
        });
      }
      var node_10 = sibling(node_8, 2);
      {
        var consequent_6 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_11 = first_child(fragment_5);
          WarningAltFilled_default(node_11, {
            class: "bx--text-input__invalid-icon\n            bx--text-input__invalid-icon--warning"
          });
          append($$anchor3, fragment_5);
        };
        if_block(node_10, ($$render) => {
          if (!invalid() && warn()) $$render(consequent_6);
        });
      }
      append($$anchor2, fragment_3);
    };
    if_block(node_6, ($$render) => {
      if (readonly2()) $$render(consequent_4);
      else $$render(alternate, false);
    });
  }
  var input = sibling(node_6, 2);
  remove_input_defaults(input);
  let attributes;
  bind_this(input, ($$value) => ref($$value), () => ref());
  var node_12 = sibling(input, 2);
  {
    var consequent_7 = ($$anchor2) => {
      var hr = root_1113();
      toggle_class(hr, "bx--text-input__divider", true);
      append($$anchor2, hr);
    };
    if_block(node_12, ($$render) => {
      if (isFluid) $$render(consequent_7);
    });
  }
  var node_13 = sibling(node_12, 2);
  {
    var consequent_8 = ($$anchor2) => {
      var div_5 = root_1212();
      var text_3 = child(div_5, true);
      reset(div_5);
      template_effect(() => {
        set_attribute(div_5, "id", get(errorId));
        toggle_class(div_5, "bx--form-requirement", true);
        set_text(text_3, invalidText());
      });
      append($$anchor2, div_5);
    };
    if_block(node_13, ($$render) => {
      if (isFluid && !inline() && invalid()) $$render(consequent_8);
    });
  }
  var node_14 = sibling(node_13, 2);
  {
    var consequent_9 = ($$anchor2) => {
      var div_6 = root_1310();
      var text_4 = child(div_6, true);
      reset(div_6);
      template_effect(() => {
        set_attribute(div_6, "id", get(warnId));
        toggle_class(div_6, "bx--form-requirement", true);
        set_text(text_4, warnText());
      });
      append($$anchor2, div_6);
    };
    if_block(node_14, ($$render) => {
      if (isFluid && !inline() && warn()) $$render(consequent_9);
    });
  }
  reset(div_4);
  var node_15 = sibling(div_4, 2);
  {
    var consequent_10 = ($$anchor2) => {
      var div_7 = root_1410();
      var text_5 = child(div_7, true);
      reset(div_7);
      template_effect(() => {
        set_attribute(div_7, "id", get(helperId));
        toggle_class(div_7, "bx--form__helper-text", true);
        toggle_class(div_7, "bx--form__helper-text--disabled", disabled());
        toggle_class(div_7, "bx--form__helper-text--inline", inline());
        set_text(text_5, helperText());
      });
      append($$anchor2, div_7);
    };
    if_block(node_15, ($$render) => {
      if (!invalid() && !warn() && !isFluid && !inline() && helperText()) $$render(consequent_10);
    });
  }
  var node_16 = sibling(node_15, 2);
  {
    var consequent_11 = ($$anchor2) => {
      var div_8 = root_1510();
      var text_6 = child(div_8, true);
      reset(div_8);
      template_effect(() => {
        set_attribute(div_8, "id", get(errorId));
        toggle_class(div_8, "bx--form-requirement", true);
        set_text(text_6, invalidText());
      });
      append($$anchor2, div_8);
    };
    if_block(node_16, ($$render) => {
      if (!isFluid && invalid()) $$render(consequent_11);
    });
  }
  var node_17 = sibling(node_16, 2);
  {
    var consequent_12 = ($$anchor2) => {
      var div_9 = root_1610();
      var text_7 = child(div_9, true);
      reset(div_9);
      template_effect(() => {
        set_attribute(div_9, "id", get(warnId));
        toggle_class(div_9, "bx--form-requirement", true);
        set_text(text_7, warnText());
      });
      append($$anchor2, div_9);
    };
    if_block(node_17, ($$render) => {
      if (!isFluid && !invalid() && warn()) $$render(consequent_12);
    });
  }
  reset(div_3);
  reset(div);
  template_effect(() => {
    toggle_class(div, "bx--text-input-wrapper--inline", inline());
    toggle_class(div, "bx--text-input-wrapper--light", light());
    toggle_class(div, "bx--text-input-wrapper--readonly", readonly2());
    toggle_class(div_3, "bx--text-input__field-outer-wrapper--inline", inline());
    set_attribute(div_4, "data-invalid", get(error) || void 0);
    set_attribute(div_4, "data-warn", warn() || void 0);
    toggle_class(div_4, "bx--text-input__field-wrapper", true);
    toggle_class(div_4, "bx--text-input__field-wrapper--warning", !invalid() && warn());
    attributes = set_attributes(input, attributes, {
      "data-invalid": get(error) || void 0,
      "aria-invalid": get(error) || void 0,
      "data-warn": warn() || void 0,
      "aria-describedby": get(error) ? get(errorId) : warn() ? get(warnId) : helperText() ? get(helperId) : void 0,
      disabled: disabled(),
      id: id(),
      name: name(),
      placeholder: placeholder(),
      required: required(),
      readonly: readonly2(),
      ...$$restProps
    });
    toggle_class(input, "bx--text-input", true);
    toggle_class(input, "bx--text-input--light", light());
    toggle_class(input, "bx--text-input--invalid", get(error));
    toggle_class(input, "bx--text-input--warning", warn());
    toggle_class(input, "bx--text-input--sm", strict_equals(size(), "sm"));
    toggle_class(input, "bx--text-input--xl", strict_equals(size(), "xl"));
  });
  bind_value(input, value);
  event2("change", input, onChange);
  event2("input", input, onInput);
  event2("keydown", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keyup", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("focus", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("blur", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("paste", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TextInput = hmr(TextInput, () => TextInput[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TextInput[HMR].source;
    set(TextInput[HMR].source, module.default[HMR].original);
  });
}
var TextInput_default = TextInput;
mark_module_end(TextInput);

// node_modules/carbon-components-svelte/src/TextInput/TextInputSkeleton.svelte
mark_module_start();
TextInputSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/TextInput/TextInputSkeleton.svelte";
var root_184 = add_locations(template(`<span></span>`), TextInputSkeleton[FILENAME], [[17, 4]]);
var root124 = add_locations(template(`<div><!> <div></div></div>`), TextInputSkeleton[FILENAME], [[8, 0, [[19, 2]]]]);
function TextInputSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["hideLabel"]);
  push($$props, false, TextInputSkeleton);
  let hideLabel = prop($$props, "hideLabel", 8, false);
  var div = root124();
  let attributes;
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var span = root_184();
      toggle_class(span, "bx--label", true);
      toggle_class(span, "bx--skeleton", true);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if (!hideLabel()) $$render(consequent);
    });
  }
  var div_1 = sibling(node, 2);
  toggle_class(div_1, "bx--skeleton", true);
  toggle_class(div_1, "bx--text-input", true);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--form-item", true);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TextInputSkeleton = hmr(TextInputSkeleton, () => TextInputSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TextInputSkeleton[HMR].source;
    set(TextInputSkeleton[HMR].source, module.default[HMR].original);
  });
}
var TextInputSkeleton_default = TextInputSkeleton;
mark_module_end(TextInputSkeleton);

// node_modules/carbon-components-svelte/src/icons/View.svelte
mark_module_start();
View[FILENAME] = "node_modules/carbon-components-svelte/src/icons/View.svelte";
var root_185 = add_locations(ns_template(`<title> </title>`), View[FILENAME], [[24, 13]]);
var root125 = add_locations(ns_template(`<svg><!><path d="M30.94,15.66A16.69,16.69,0,0,0,16,5,16.69,16.69,0,0,0,1.06,15.66a1,1,0,0,0,0,.68A16.69,16.69,0,0,0,16,27,16.69,16.69,0,0,0,30.94,16.34,1,1,0,0,0,30.94,15.66ZM16,25c-5.3,0-10.9-3.93-12.93-9C5.1,10.93,10.7,7,16,7s10.9,3.93,12.93,9C26.9,21.07,21.3,25,16,25Z"></path><path d="M16,10a6,6,0,1,0,6,6A6,6,0,0,0,16,10Zm0,10a4,4,0,1,1,4-4A4,4,0,0,1,16,20Z"></path></svg>`), View[FILENAME], [[14, 0, [[25, 2], [27, 10]]]]);
function View($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, View);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root125();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_185();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next(2);
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  View = hmr(View, () => View[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = View[HMR].source;
    set(View[HMR].source, module.default[HMR].original);
  });
}
var View_default = View;
mark_module_end(View);

// node_modules/carbon-components-svelte/src/icons/ViewOff.svelte
mark_module_start();
ViewOff[FILENAME] = "node_modules/carbon-components-svelte/src/icons/ViewOff.svelte";
var root_186 = add_locations(ns_template(`<title> </title>`), ViewOff[FILENAME], [[24, 13]]);
var root126 = add_locations(ns_template(`<svg><!><path d="M5.24,22.51l1.43-1.42A14.06,14.06,0,0,1,3.07,16C5.1,10.93,10.7,7,16,7a12.38,12.38,0,0,1,4,.72l1.55-1.56A14.72,14.72,0,0,0,16,5,16.69,16.69,0,0,0,1.06,15.66a1,1,0,0,0,0,.68A16,16,0,0,0,5.24,22.51Z"></path><path d="M12 15.73a4 4 0 013.7-3.7l1.81-1.82a6 6 0 00-7.33 7.33zM30.94 15.66A16.4 16.4 0 0025.2 8.22L30 3.41 28.59 2 2 28.59 3.41 30l5.1-5.1A15.29 15.29 0 0016 27 16.69 16.69 0 0030.94 16.34 1 1 0 0030.94 15.66zM20 16a4 4 0 01-6 3.44L19.44 14A4 4 0 0120 16zm-4 9a13.05 13.05 0 01-6-1.58l2.54-2.54a6 6 0 008.35-8.35l2.87-2.87A14.54 14.54 0 0128.93 16C26.9 21.07 21.3 25 16 25z"></path></svg>`), ViewOff[FILENAME], [[14, 0, [[25, 2], [27, 10]]]]);
function ViewOff($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, ViewOff);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root126();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_186();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next(2);
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ViewOff = hmr(ViewOff, () => ViewOff[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ViewOff[HMR].source;
    set(ViewOff[HMR].source, module.default[HMR].original);
  });
}
var ViewOff_default = ViewOff;
mark_module_end(ViewOff);

// node_modules/carbon-components-svelte/src/TextInput/PasswordInput.svelte
mark_module_start();
PasswordInput[FILENAME] = "node_modules/carbon-components-svelte/src/TextInput/PasswordInput.svelte";
var root_317 = add_locations(template(`<div> </div>`), PasswordInput[FILENAME], [[126, 6]]);
var root_187 = add_locations(template(`<label><!></label> <!>`, 1), PasswordInput[FILENAME], [[112, 4]]);
var root_411 = add_locations(template(`<label><!></label>`), PasswordInput[FILENAME], [[137, 4]]);
var root_87 = add_locations(template(`<hr class="bx--text-input__divider"> <div class="bx--form-requirement"> </div>`, 1), PasswordInput[FILENAME], [[206, 8], [207, 8]]);
var root_107 = add_locations(template(`<span><!></span>`), PasswordInput[FILENAME], [[233, 12]]);
var root_94 = add_locations(template(`<button type="button"><!> <!></button>`), PasswordInput[FILENAME], [[212, 8]]);
var root_1511 = add_locations(template(`<div> </div>`), PasswordInput[FILENAME], [[248, 6]]);
var root_1611 = add_locations(template(`<div> </div>`), PasswordInput[FILENAME], [[253, 6]]);
var root_1710 = add_locations(template(`<div> </div>`), PasswordInput[FILENAME], [[262, 6]]);
var root127 = add_locations(template(`<div><!> <!> <div><div><!> <!> <input> <!> <!></div> <!> <!> <!></div></div>`), PasswordInput[FILENAME], [
  [
    100,
    0,
    [
      [
        151,
        2,
        [[155, 4, [[169, 6]]]]
      ]
    ]
  ]
]);
function PasswordInput($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "size",
    "value",
    "type",
    "placeholder",
    "hidePasswordLabel",
    "showPasswordLabel",
    "tooltipAlignment",
    "tooltipPosition",
    "light",
    "disabled",
    "helperText",
    "labelText",
    "hideLabel",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "inline",
    "id",
    "name",
    "ref"
  ]);
  push($$props, false, PasswordInput);
  const helperId = mutable_state();
  const errorId = mutable_state();
  const warnId = mutable_state();
  let size = prop($$props, "size", 8, void 0);
  let value = prop($$props, "value", 12, "");
  let type = prop($$props, "type", 12, "password");
  let placeholder = prop($$props, "placeholder", 8, "");
  let hidePasswordLabel = prop($$props, "hidePasswordLabel", 8, "Hide password");
  let showPasswordLabel = prop($$props, "showPasswordLabel", 8, "Show password");
  let tooltipAlignment = prop($$props, "tooltipAlignment", 8, "center");
  let tooltipPosition = prop($$props, "tooltipPosition", 8, "bottom");
  let light = prop($$props, "light", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let helperText = prop($$props, "helperText", 8, "");
  let labelText = prop($$props, "labelText", 8, "");
  let hideLabel = prop($$props, "hideLabel", 8, false);
  let invalid = prop($$props, "invalid", 8, false);
  let invalidText = prop($$props, "invalidText", 8, "");
  let warn = prop($$props, "warn", 8, false);
  let warnText = prop($$props, "warnText", 8, "");
  let inline = prop($$props, "inline", 8, false);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let name = prop($$props, "name", 8, void 0);
  let ref = prop($$props, "ref", 12, null);
  const ctx = getContext("Form");
  const isFluid = !!ctx && ctx.isFluid;
  legacy_pre_effect(() => deep_read_state(id()), () => {
    set(helperId, `helper-${id()}`);
  });
  legacy_pre_effect(() => deep_read_state(id()), () => {
    set(errorId, `error-${id()}`);
  });
  legacy_pre_effect(() => deep_read_state(id()), () => {
    set(warnId, `warn-${id()}`);
  });
  legacy_pre_effect_reset();
  init();
  var div = root127();
  toggle_class(div, "bx--form-item", true);
  toggle_class(div, "bx--text-input-wrapper", true);
  toggle_class(div, "bx--password-input-wrapper", !isFluid);
  var node = child(div);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment = root_187();
      var label = first_child(fragment);
      var node_1 = child(label);
      slot(node_1, $$props, "labelText", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, labelText()));
        append($$anchor3, text2);
      });
      reset(label);
      var node_2 = sibling(label, 2);
      {
        var consequent = ($$anchor3) => {
          var div_1 = root_317();
          var text_1 = child(div_1, true);
          reset(div_1);
          template_effect(() => {
            set_attribute(div_1, "id", get(helperId));
            toggle_class(div_1, "bx--form__helper-text", true);
            toggle_class(div_1, "bx--form__helper-text--disabled", disabled());
            toggle_class(div_1, "bx--form__helper-text--inline", inline());
            set_text(text_1, helperText());
          });
          append($$anchor3, div_1);
        };
        if_block(node_2, ($$render) => {
          if (!isFluid && helperText()) $$render(consequent);
        });
      }
      template_effect(() => {
        set_attribute(label, "for", id());
        toggle_class(label, "bx--label", true);
        toggle_class(label, "bx--visually-hidden", hideLabel());
        toggle_class(label, "bx--label--disabled", disabled());
        toggle_class(label, "bx--label--inline", inline());
        toggle_class(label, "bx--label--inline--sm", inline() && strict_equals(size(), "sm"));
        toggle_class(label, "bx--label--inline--xl", inline() && strict_equals(size(), "xl"));
      });
      append($$anchor2, fragment);
    };
    if_block(node, ($$render) => {
      if (inline()) $$render(consequent_1);
    });
  }
  var node_3 = sibling(node, 2);
  {
    var consequent_2 = ($$anchor2) => {
      var label_1 = root_411();
      var node_4 = child(label_1);
      slot(node_4, $$props, "labelText", {}, ($$anchor3) => {
        var text_2 = text();
        template_effect(() => set_text(text_2, labelText()));
        append($$anchor3, text_2);
      });
      reset(label_1);
      template_effect(() => {
        set_attribute(label_1, "for", id());
        toggle_class(label_1, "bx--label", true);
        toggle_class(label_1, "bx--visually-hidden", hideLabel());
        toggle_class(label_1, "bx--label--disabled", disabled());
        toggle_class(label_1, "bx--label--inline", inline());
        toggle_class(label_1, "bx--label--inline--sm", inline() && strict_equals(size(), "sm"));
        toggle_class(label_1, "bx--label--inline--xl", inline() && strict_equals(size(), "xl"));
      });
      append($$anchor2, label_1);
    };
    if_block(node_3, ($$render) => {
      if (!inline() && (labelText() || $$slots.labelText)) $$render(consequent_2);
    });
  }
  var div_2 = sibling(node_3, 2);
  toggle_class(div_2, "bx--text-input__field-outer-wrapper", true);
  var div_3 = child(div_2);
  var node_5 = child(div_3);
  {
    var consequent_3 = ($$anchor2) => {
      var fragment_3 = comment();
      var node_6 = first_child(fragment_3);
      WarningFilled_default(node_6, { class: "bx--text-input__invalid-icon" });
      append($$anchor2, fragment_3);
    };
    if_block(node_5, ($$render) => {
      if (invalid()) $$render(consequent_3);
    });
  }
  var node_7 = sibling(node_5, 2);
  {
    var consequent_4 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_8 = first_child(fragment_4);
      WarningAltFilled_default(node_8, {
        class: "bx--text-input__invalid-icon\n            bx--text-input__invalid-icon--warning"
      });
      append($$anchor2, fragment_4);
    };
    if_block(node_7, ($$render) => {
      if (!invalid() && warn()) $$render(consequent_4);
    });
  }
  var input = sibling(node_7, 2);
  remove_input_defaults(input);
  let attributes;
  bind_this(input, ($$value) => ref($$value), () => ref());
  var node_9 = sibling(input, 2);
  {
    var consequent_5 = ($$anchor2) => {
      var fragment_5 = root_87();
      var div_4 = sibling(first_child(fragment_5), 2);
      var text_3 = child(div_4, true);
      reset(div_4);
      template_effect(() => {
        set_attribute(div_4, "id", get(errorId));
        set_text(text_3, invalidText());
      });
      append($$anchor2, fragment_5);
    };
    if_block(node_9, ($$render) => {
      if (isFluid && invalid()) $$render(consequent_5);
    });
  }
  var node_10 = sibling(node_9, 2);
  {
    var consequent_9 = ($$anchor2) => {
      var button = root_94();
      var node_11 = child(button);
      {
        var consequent_7 = ($$anchor3) => {
          var span = root_107();
          toggle_class(span, "bx--assistive-text", true);
          var node_12 = child(span);
          {
            var consequent_6 = ($$anchor4) => {
              var text_4 = text();
              template_effect(() => set_text(text_4, hidePasswordLabel()));
              append($$anchor4, text_4);
            };
            var alternate = ($$anchor4) => {
              var text_5 = text();
              template_effect(() => set_text(text_5, showPasswordLabel()));
              append($$anchor4, text_5);
            };
            if_block(node_12, ($$render) => {
              if (strict_equals(type(), "text")) $$render(consequent_6);
              else $$render(alternate, false);
            });
          }
          reset(span);
          append($$anchor3, span);
        };
        if_block(node_11, ($$render) => {
          if (!disabled()) $$render(consequent_7);
        });
      }
      var node_13 = sibling(node_11, 2);
      {
        var consequent_8 = ($$anchor3) => {
          var fragment_8 = comment();
          var node_14 = first_child(fragment_8);
          ViewOff_default(node_14, { class: "bx--icon-visibility-off" });
          append($$anchor3, fragment_8);
        };
        var alternate_1 = ($$anchor3) => {
          var fragment_9 = comment();
          var node_15 = first_child(fragment_9);
          View_default(node_15, { class: "bx--icon-visibility-on" });
          append($$anchor3, fragment_9);
        };
        if_block(node_13, ($$render) => {
          if (strict_equals(type(), "text")) $$render(consequent_8);
          else $$render(alternate_1, false);
        });
      }
      reset(button);
      template_effect(() => {
        button.disabled = disabled();
        toggle_class(button, "bx--text-input--password__visibility__toggle", true);
        toggle_class(button, "bx--btn", true);
        toggle_class(button, "bx--btn--icon-only", true);
        toggle_class(button, "bx--btn--disabled", disabled());
        toggle_class(button, "bx--tooltip__trigger", true);
        toggle_class(button, "bx--tooltip--a11y", true);
        toggle_class(button, "bx--tooltip--top", strict_equals(tooltipPosition(), "top"));
        toggle_class(button, "bx--tooltip--right", strict_equals(tooltipPosition(), "right"));
        toggle_class(button, "bx--tooltip--bottom", strict_equals(tooltipPosition(), "bottom"));
        toggle_class(button, "bx--tooltip--left", strict_equals(tooltipPosition(), "left"));
        toggle_class(button, "bx--tooltip--align-start", strict_equals(tooltipAlignment(), "start"));
        toggle_class(button, "bx--tooltip--align-center", strict_equals(tooltipAlignment(), "center"));
        toggle_class(button, "bx--tooltip--align-end", strict_equals(tooltipAlignment(), "end"));
      });
      event2("click", button, () => {
        type(strict_equals(type(), "password") ? "text" : "password");
      });
      append($$anchor2, button);
    };
    if_block(node_10, ($$render) => {
      if (!(isFluid && invalid())) $$render(consequent_9);
    });
  }
  reset(div_3);
  var node_16 = sibling(div_3, 2);
  {
    var consequent_10 = ($$anchor2) => {
      var div_5 = root_1511();
      var text_6 = child(div_5, true);
      reset(div_5);
      template_effect(() => {
        set_attribute(div_5, "id", get(errorId));
        toggle_class(div_5, "bx--form-requirement", true);
        set_text(text_6, invalidText());
      });
      append($$anchor2, div_5);
    };
    if_block(node_16, ($$render) => {
      if (!isFluid && invalid()) $$render(consequent_10);
    });
  }
  var node_17 = sibling(node_16, 2);
  {
    var consequent_11 = ($$anchor2) => {
      var div_6 = root_1611();
      toggle_class(div_6, "bx--form__helper-text", true);
      var text_7 = child(div_6, true);
      reset(div_6);
      template_effect(() => {
        toggle_class(div_6, "bx--form__helper-text--disabled", disabled());
        toggle_class(div_6, "bx--form__helper-text--inline", inline());
        set_text(text_7, helperText());
      });
      append($$anchor2, div_6);
    };
    if_block(node_17, ($$render) => {
      if (!invalid() && !warn() && !isFluid && !inline() && helperText()) $$render(consequent_11);
    });
  }
  var node_18 = sibling(node_17, 2);
  {
    var consequent_12 = ($$anchor2) => {
      var div_7 = root_1710();
      var text_8 = child(div_7, true);
      reset(div_7);
      template_effect(() => {
        set_attribute(div_7, "id", get(warnId));
        toggle_class(div_7, "bx--form-requirement", true);
        set_text(text_8, warnText());
      });
      append($$anchor2, div_7);
    };
    if_block(node_18, ($$render) => {
      if (!isFluid && !invalid() && warn()) $$render(consequent_12);
    });
  }
  reset(div_2);
  reset(div);
  template_effect(() => {
    toggle_class(div, "bx--text-input-wrapper--light", light());
    toggle_class(div, "bx--text-input-wrapper--inline", inline());
    toggle_class(div_2, "bx--text-input__field-outer-wrapper--inline", inline());
    set_attribute(div_3, "data-invalid", invalid() || void 0);
    toggle_class(div_3, "bx--text-input__field-wrapper", true);
    toggle_class(div_3, "bx--text-input__field-wrapper--warning", warn());
    attributes = set_attributes(input, attributes, {
      "data-invalid": invalid() || void 0,
      "aria-invalid": invalid() || void 0,
      "aria-describedby": invalid() ? get(errorId) : warn() ? get(warnId) : helperText() ? get(helperId) : void 0,
      id: id(),
      name: name(),
      placeholder: placeholder(),
      type: type(),
      value: value() ?? "",
      disabled: disabled(),
      ...$$restProps
    });
    toggle_class(input, "bx--text-input", true);
    toggle_class(input, "bx--password-input", true);
    toggle_class(input, "bx--text-input--light", light());
    toggle_class(input, "bx--text-input--invalid", invalid());
    toggle_class(input, "bx--text-input--warning", warn());
    toggle_class(input, "bx--text-input--sm", strict_equals(size(), "sm"));
    toggle_class(input, "bx--text-input--xl", strict_equals(size(), "xl"));
  });
  event2("change", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("input", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("input", input, ({ target }) => {
    value(target.value);
  });
  event2("keydown", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keyup", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("focus", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("blur", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("paste", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PasswordInput = hmr(PasswordInput, () => PasswordInput[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PasswordInput[HMR].source;
    set(PasswordInput[HMR].source, module.default[HMR].original);
  });
}
var PasswordInput_default = PasswordInput;
mark_module_end(PasswordInput);

// node_modules/carbon-components-svelte/src/Toggle/Toggle.svelte
mark_module_start();
Toggle[FILENAME] = "node_modules/carbon-components-svelte/src/Toggle/Toggle.svelte";
var root128 = add_locations(template(`<div><input role="switch" type="checkbox"> <label><span><!></span> <span><span aria-hidden="true"><!></span> <span aria-hidden="true"><!></span></span></label></div>`), Toggle[FILENAME], [
  [
    48,
    0,
    [
      [58, 2],
      [
        81,
        2,
        [
          [86, 4],
          [91, 4, [[95, 6], [100, 6]]]
        ]
      ]
    ]
  ]
]);
function Toggle($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "size",
    "toggled",
    "disabled",
    "labelA",
    "labelB",
    "labelText",
    "hideLabel",
    "id",
    "name"
  ]);
  push($$props, false, Toggle);
  let size = prop($$props, "size", 8, "default");
  let toggled = prop($$props, "toggled", 12, false);
  let disabled = prop($$props, "disabled", 8, false);
  let labelA = prop($$props, "labelA", 8, "Off");
  let labelB = prop($$props, "labelB", 8, "On");
  let labelText = prop($$props, "labelText", 8, "");
  let hideLabel = prop($$props, "hideLabel", 8, false);
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let name = prop($$props, "name", 8, void 0);
  const dispatch = createEventDispatcher();
  legacy_pre_effect(() => deep_read_state(toggled()), () => {
    dispatch("toggle", { toggled: toggled() });
  });
  legacy_pre_effect_reset();
  init();
  var div = root128();
  let attributes;
  var input = child(div);
  remove_input_defaults(input);
  var label = sibling(input, 2);
  var span = child(label);
  var node = child(span);
  slot(node, $$props, "labelText", {}, ($$anchor2) => {
    var text2 = text();
    template_effect(() => set_text(text2, labelText()));
    append($$anchor2, text2);
  });
  reset(span);
  var span_1 = sibling(span, 2);
  toggle_class(span_1, "bx--toggle__switch", true);
  var span_2 = child(span_1);
  toggle_class(span_2, "bx--toggle__text--off", true);
  var node_1 = child(span_2);
  slot(node_1, $$props, "labelA", {}, ($$anchor2) => {
    var text_1 = text();
    template_effect(() => set_text(text_1, labelA()));
    append($$anchor2, text_1);
  });
  reset(span_2);
  var span_3 = sibling(span_2, 2);
  toggle_class(span_3, "bx--toggle__text--on", true);
  var node_2 = child(span_3);
  slot(node_2, $$props, "labelB", {}, ($$anchor2) => {
    var text_2 = text();
    template_effect(() => set_text(text_2, labelB()));
    append($$anchor2, text_2);
  });
  reset(span_3);
  reset(span_1);
  reset(label);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--form-item", true);
    set_style(div, "user-select", "none");
    set_checked(input, toggled());
    input.disabled = disabled();
    set_attribute(input, "id", id());
    set_attribute(input, "name", name());
    toggle_class(input, "bx--toggle-input", true);
    toggle_class(input, "bx--toggle-input--small", strict_equals(size(), "sm"));
    set_attribute(label, "aria-label", labelText() ? void 0 : $$sanitized_props["aria-label"] || "Toggle");
    set_attribute(label, "for", id());
    toggle_class(label, "bx--toggle-input__label", true);
    toggle_class(span, "bx--visually-hidden", hideLabel());
    set_style(span_1, "margin-top", hideLabel() ? 0 : void 0);
  });
  event2("change", input, () => {
    toggled(!toggled());
  });
  event2("change", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keyup", input, (e) => {
    if (strict_equals(e.key, " ") || strict_equals(e.key, "Enter")) {
      e.preventDefault();
      toggled(!toggled());
    }
  });
  event2("keyup", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("focus", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("blur", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toggle = hmr(Toggle, () => Toggle[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toggle[HMR].source;
    set(Toggle[HMR].source, module.default[HMR].original);
  });
}
var Toggle_default = Toggle;
mark_module_end(Toggle);

// node_modules/carbon-components-svelte/src/Theme/Theme.svelte
mark_module_start();
Theme[FILENAME] = "node_modules/carbon-components-svelte/src/Theme/Theme.svelte";
var root129 = add_locations(template(`<!> <!> <!>`, 1), Theme[FILENAME], []);
function Theme($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Theme);
  let theme = prop($$props, "theme", 12, "white");
  let tokens = prop($$props, "tokens", 24, () => ({}));
  let persist = prop($$props, "persist", 8, false);
  let persistKey = prop($$props, "persistKey", 8, "theme");
  let render = prop($$props, "render", 8, void 0);
  let toggle = prop($$props, "toggle", 24, () => ({
    themes: ["white", "g100"],
    labelA: "",
    labelB: "",
    labelText: "Dark mode",
    hideLabel: false
  }));
  const themes = {
    white: "White",
    g10: "Gray 10",
    g80: "Gray 80",
    g90: "Gray 90",
    g100: "Gray 100"
  };
  const themeKeys = Object.keys(themes);
  let select = prop($$props, "select", 24, () => ({
    themes: themeKeys,
    labelText: "Themes",
    hideLabel: false
  }));
  const dispatch = createEventDispatcher();
  legacy_pre_effect(
    () => (deep_read_state(tokens()), deep_read_state(theme())),
    () => {
      if (strict_equals(typeof window, "undefined", false)) {
        Object.entries(tokens()).forEach(([token, value]) => {
          document.documentElement.style.setProperty(`--cds-${token}`, value);
        });
        if (theme() in themes) {
          document.documentElement.setAttribute("theme", theme());
          dispatch("update", { theme: theme() });
        } else {
          console.warn(...log_if_contains_state("warn", `[Theme.svelte] invalid theme "${theme()}". Value must be one of: ${JSON.stringify(Object.keys(themes))}`));
        }
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = root129();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        add_owner_effect(theme, LocalStorage_default);
        LocalStorage_default(node_1, {
          get key() {
            return persistKey();
          },
          get value() {
            return theme();
          },
          set value($$value) {
            theme($$value);
          },
          $$legacy: true
        });
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (persist()) $$render(consequent);
    });
  }
  var node_2 = sibling(node, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      const expression = derived_safe_equal(() => strict_equals(theme(), toggle().themes[1]));
      Toggle_default(node_3, spread_props(toggle, {
        get toggled() {
          return get(expression);
        },
        $$events: {
          toggle: ({ detail }) => {
            theme(detail.toggled ? toggle().themes[1] : toggle().themes[0]);
          }
        }
      }));
      append($$anchor2, fragment_2);
    };
    var alternate = ($$anchor2) => {
      var fragment_3 = comment();
      var node_4 = first_child(fragment_3);
      {
        var consequent_2 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          {
            add_owner_effect(theme, Select_default);
            Select_default(node_5, spread_props(select, {
              get selected() {
                return theme();
              },
              set selected($$value) {
                theme($$value);
              },
              children: wrap_snippet(Theme, ($$anchor4, $$slotProps) => {
                var fragment_5 = comment();
                var node_6 = first_child(fragment_5);
                validate_each_keys(() => select().themes, (theme2) => theme2);
                each(node_6, 1, () => select().themes, (theme2) => theme2, ($$anchor5, theme2, $$index, $$array) => {
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  SelectItem_default(node_7, {
                    get value() {
                      return get(theme2);
                    },
                    get text() {
                      return themes[get(theme2)];
                    }
                  });
                  append($$anchor5, fragment_6);
                });
                append($$anchor4, fragment_5);
              }),
              $$slots: { default: true },
              $$legacy: true
            }));
          }
          append($$anchor3, fragment_4);
        };
        if_block(
          node_4,
          ($$render) => {
            if (strict_equals(render(), "select")) $$render(consequent_2);
          },
          true
        );
      }
      append($$anchor2, fragment_3);
    };
    if_block(node_2, ($$render) => {
      if (strict_equals(render(), "toggle")) $$render(consequent_1);
      else $$render(alternate, false);
    });
  }
  var node_8 = sibling(node_2, 2);
  slot(
    node_8,
    $$props,
    "default",
    {
      get theme() {
        return theme();
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Theme = hmr(Theme, () => Theme[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Theme[HMR].source;
    set(Theme[HMR].source, module.default[HMR].original);
  });
}
var Theme_default = Theme;
mark_module_end(Theme);

// node_modules/carbon-components-svelte/src/Tile/Tile.svelte
mark_module_start();
Tile[FILENAME] = "node_modules/carbon-components-svelte/src/Tile/Tile.svelte";
var root130 = add_locations(template(`<div><!></div>`), Tile[FILENAME], [[8, 0]]);
function Tile($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["light"]);
  push($$props, false, Tile);
  let light = prop($$props, "light", 8, false);
  var div = root130();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--tile", true);
    toggle_class(div, "bx--tile--light", light());
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tile = hmr(Tile, () => Tile[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tile[HMR].source;
    set(Tile[HMR].source, module.default[HMR].original);
  });
}
var Tile_default = Tile;
mark_module_end(Tile);

// node_modules/carbon-components-svelte/src/Tile/ClickableTile.svelte
mark_module_start();
ClickableTile[FILENAME] = "node_modules/carbon-components-svelte/src/Tile/ClickableTile.svelte";
function ClickableTile($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["clicked", "light", "disabled", "href"]);
  push($$props, false, ClickableTile);
  let clicked = prop($$props, "clicked", 12, false);
  let light = prop($$props, "light", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let href = prop($$props, "href", 8, void 0);
  init();
  var fragment = comment();
  var node = first_child(fragment);
  const expression = derived_safe_equal(() => clicked() && "bx--tile--is-clicked");
  const expression_1 = derived_safe_equal(() => light() && "bx--tile--light");
  const expression_2 = derived_safe_equal(() => $$restProps.class);
  Link_default(node, spread_props(() => $$restProps, {
    get disabled() {
      return disabled();
    },
    get class() {
      return `bx--tile bx--tile--clickable ${get(expression) ?? ""} ${get(expression_1) ?? ""} ${get(expression_2) ?? ""}`;
    },
    get href() {
      return href();
    },
    $$events: {
      click: [
        function($$arg) {
          bubble_event.call(this, $$props, $$arg);
        },
        () => {
          clicked(!clicked());
        }
      ],
      keydown: [
        function($$arg) {
          bubble_event.call(this, $$props, $$arg);
        },
        ({ key }) => {
          if (strict_equals(key, " ") || strict_equals(key, "Enter")) {
            clicked(!clicked());
          }
        }
      ],
      mouseover($$arg) {
        bubble_event.call(this, $$props, $$arg);
      },
      mouseenter($$arg) {
        bubble_event.call(this, $$props, $$arg);
      },
      mouseleave($$arg) {
        bubble_event.call(this, $$props, $$arg);
      }
    },
    children: wrap_snippet(ClickableTile, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ClickableTile = hmr(ClickableTile, () => ClickableTile[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClickableTile[HMR].source;
    set(ClickableTile[HMR].source, module.default[HMR].original);
  });
}
var ClickableTile_default = ClickableTile;
mark_module_end(ClickableTile);

// node_modules/carbon-components-svelte/src/Tile/ExpandableTile.svelte
mark_module_start();
ExpandableTile[FILENAME] = "node_modules/carbon-components-svelte/src/Tile/ExpandableTile.svelte";
var root131 = add_locations(template(`<button><div><div><span><!></span></div> <div><span> </span> <!></div> <div><span><!></span></div></div></button>`), ExpandableTile[FILENAME], [
  [
    66,
    0,
    [
      [
        88,
        2,
        [
          [89, 4, [[90, 6]]],
          [94, 4, [[95, 6]]],
          [98, 4, [[99, 6]]]
        ]
      ]
    ]
  ]
]);
function ExpandableTile($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "expanded",
    "light",
    "tileMaxHeight",
    "tilePadding",
    "tileCollapsedIconText",
    "tileExpandedIconText",
    "tileExpandedLabel",
    "tileCollapsedLabel",
    "tabindex",
    "id",
    "ref"
  ]);
  push($$props, false, ExpandableTile);
  let expanded = prop($$props, "expanded", 12, false);
  let light = prop($$props, "light", 8, false);
  let tileMaxHeight = prop($$props, "tileMaxHeight", 12, 0);
  let tilePadding = prop($$props, "tilePadding", 12, 0);
  let tileCollapsedIconText = prop($$props, "tileCollapsedIconText", 8, "Interact to expand Tile");
  let tileExpandedIconText = prop($$props, "tileExpandedIconText", 8, "Interact to collapse Tile");
  let tileExpandedLabel = prop($$props, "tileExpandedLabel", 8, "");
  let tileCollapsedLabel = prop($$props, "tileCollapsedLabel", 8, "");
  let tabindex = prop($$props, "tabindex", 8, "0");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let ref = prop($$props, "ref", 12, null);
  let refAbove = mutable_state(null);
  onMount(() => {
    const resizeObserver = new ResizeObserver(([elem]) => {
      tileMaxHeight(elem.contentRect.height);
    });
    resizeObserver.observe(get(refAbove));
    return () => {
      resizeObserver.disconnect();
    };
  });
  afterUpdate(() => {
    if (strict_equals(tileMaxHeight(), 0)) {
      tileMaxHeight(get(refAbove).getBoundingClientRect().height);
    }
    const style = getComputedStyle(ref());
    tilePadding(parseInt(style.getPropertyValue("padding-top"), 10) + parseInt(style.getPropertyValue("padding-bottom"), 10));
  });
  init();
  var button = root131();
  let attributes;
  var div = child(button);
  var div_1 = child(div);
  toggle_class(div_1, "bx--tile-content", true);
  var span = child(div_1);
  toggle_class(span, "bx--tile-content__above-the-fold", true);
  var node = child(span);
  slot(node, $$props, "above", {}, null);
  reset(span);
  reset(div_1);
  bind_this(div_1, ($$value) => set(refAbove, $$value), () => get(refAbove));
  var div_2 = sibling(div_1, 2);
  toggle_class(div_2, "bx--tile__chevron", true);
  var span_1 = child(div_2);
  var text2 = child(span_1, true);
  reset(span_1);
  var node_1 = sibling(span_1, 2);
  ChevronDown_default(node_1, {});
  reset(div_2);
  var div_3 = sibling(div_2, 2);
  toggle_class(div_3, "bx--tile-content", true);
  var span_2 = child(div_3);
  toggle_class(span_2, "bx--tile-content__below-the-fold", true);
  var node_2 = child(span_2);
  slot(node_2, $$props, "below", {}, null);
  reset(span_2);
  reset(div_3);
  reset(div);
  reset(button);
  bind_this(button, ($$value) => ref($$value), () => ref());
  template_effect(() => {
    attributes = set_attributes(button, attributes, {
      type: "button",
      id: id(),
      "aria-expanded": expanded(),
      tabindex: tabindex(),
      title: expanded() ? tileExpandedIconText() : tileCollapsedIconText(),
      ...$$restProps
    });
    toggle_class(button, "bx--tile", true);
    toggle_class(button, "bx--tile--expandable", true);
    toggle_class(button, "bx--tile--is-expanded", expanded());
    toggle_class(button, "bx--tile--light", light());
    set_style(button, "max-height", expanded() ? "none" : `${tileMaxHeight() + tilePadding()}px`);
    set_text(text2, expanded() ? tileExpandedLabel() : tileCollapsedLabel());
  });
  event2("click", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", button, () => {
    expanded(!expanded());
  });
  event2("keypress", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, button);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ExpandableTile = hmr(ExpandableTile, () => ExpandableTile[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ExpandableTile[HMR].source;
    set(ExpandableTile[HMR].source, module.default[HMR].original);
  });
}
var ExpandableTile_default = ExpandableTile;
mark_module_end(ExpandableTile);

// node_modules/carbon-components-svelte/src/Tile/SelectableTile.svelte
mark_module_start();
SelectableTile[FILENAME] = "node_modules/carbon-components-svelte/src/Tile/SelectableTile.svelte";
var root132 = add_locations(template(`<input type="checkbox" tabindex="-1">  <label><span><!></span> <span><!></span></label>`, 1), SelectableTile[FILENAME], [
  [48, 0],
  [63, 0, [[89, 2], [92, 2]]]
]);
function SelectableTile($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "selected",
    "light",
    "disabled",
    "title",
    "value",
    "tabindex",
    "iconDescription",
    "id",
    "name",
    "ref"
  ]);
  push($$props, false, SelectableTile);
  let selected = prop($$props, "selected", 12, false);
  let light = prop($$props, "light", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let title = prop($$props, "title", 8, "title");
  let value = prop($$props, "value", 8, "value");
  let tabindex = prop($$props, "tabindex", 8, "0");
  let iconDescription = prop($$props, "iconDescription", 8, "Tile checkmark");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let name = prop($$props, "name", 8, "");
  let ref = prop($$props, "ref", 12, null);
  const dispatch = createEventDispatcher();
  legacy_pre_effect(
    () => (deep_read_state(disabled()), deep_read_state(selected()), deep_read_state(id())),
    () => {
      if (!disabled()) dispatch(selected() ? "select" : "deselect", id());
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = root132();
  var input = first_child(fragment);
  remove_input_defaults(input);
  bind_this(input, ($$value) => ref($$value), () => ref());
  var label = sibling(input, 2);
  let attributes;
  var span = child(label);
  toggle_class(span, "bx--tile__checkmark", true);
  var node = child(span);
  CheckmarkFilled_default(node, {
    get "aria-label"() {
      return iconDescription();
    },
    get title() {
      return iconDescription();
    }
  });
  reset(span);
  var span_1 = sibling(span, 2);
  toggle_class(span_1, "bx--tile-content", true);
  var node_1 = child(span_1);
  slot(node_1, $$props, "default", {}, null);
  reset(span_1);
  reset(label);
  template_effect(() => {
    set_checked(input, selected());
    set_attribute(input, "id", id());
    set_value(input, value());
    set_attribute(input, "name", name());
    set_attribute(input, "title", title());
    input.disabled = disabled();
    toggle_class(input, "bx--tile-input", true);
    attributes = set_attributes(label, attributes, {
      for: id(),
      tabindex: disabled() ? void 0 : tabindex(),
      ...$$restProps
    });
    toggle_class(label, "bx--tile", true);
    toggle_class(label, "bx--tile--selectable", true);
    toggle_class(label, "bx--tile--is-selected", selected());
    toggle_class(label, "bx--tile--light", light());
    toggle_class(label, "bx--tile--disabled", disabled());
  });
  event2("click", label, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", label, preventDefault(() => {
    if (disabled()) return;
    selected(!selected());
  }));
  event2("mouseover", label, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", label, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", label, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", label, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", label, (e) => {
    if (disabled()) return;
    if (strict_equals(e.key, " ") || strict_equals(e.key, "Enter")) {
      e.preventDefault();
      selected(!selected());
    }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SelectableTile = hmr(SelectableTile, () => SelectableTile[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SelectableTile[HMR].source;
    set(SelectableTile[HMR].source, module.default[HMR].original);
  });
}
var SelectableTile_default = SelectableTile;
mark_module_end(SelectableTile);

// node_modules/carbon-components-svelte/src/Tile/RadioTile.svelte
mark_module_start();
RadioTile[FILENAME] = "node_modules/carbon-components-svelte/src/Tile/RadioTile.svelte";
var root133 = add_locations(template(`<input type="radio">  <label><span><!></span> <span><!></span></label>`, 1), RadioTile[FILENAME], [
  [49, 0],
  [75, 0, [[88, 2], [91, 2]]]
]);
function RadioTile($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "checked",
    "light",
    "disabled",
    "required",
    "value",
    "tabindex",
    "iconDescription",
    "id",
    "name"
  ]);
  push($$props, false, RadioTile);
  const [$$stores, $$cleanup] = setup_stores();
  const $selectedValue = () => (validate_store(selectedValue, "selectedValue"), store_get(selectedValue, "$selectedValue", $$stores));
  const $groupName = () => (validate_store(groupName, "groupName"), store_get(groupName, "$groupName", $$stores));
  const $groupRequired = () => (validate_store(groupRequired, "groupRequired"), store_get(groupRequired, "$groupRequired", $$stores));
  let checked = prop($$props, "checked", 12, false);
  let light = prop($$props, "light", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let required = prop($$props, "required", 8, false);
  let value = prop($$props, "value", 8, "");
  let tabindex = prop($$props, "tabindex", 8, "0");
  let iconDescription = prop($$props, "iconDescription", 8, "Tile checkmark");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let name = prop($$props, "name", 8, void 0);
  const {
    add,
    update: update2,
    selectedValue,
    groupName,
    groupRequired
  } = getContext("TileGroup") ?? {
    groupName: readable(void 0),
    groupRequired: readable(void 0),
    selectedValue: readable(checked() ? value() : void 0)
  };
  add({ value: value(), checked: checked() });
  legacy_pre_effect(
    () => (deep_read_state(value()), $selectedValue()),
    () => {
      checked(strict_equals(value(), $selectedValue()));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = root133();
  var input = first_child(fragment);
  remove_input_defaults(input);
  var label = sibling(input, 2);
  let attributes;
  var span = child(label);
  toggle_class(span, "bx--tile__checkmark", true);
  var node = child(span);
  CheckmarkFilled_default(node, {
    get "aria-label"() {
      return iconDescription();
    },
    get title() {
      return iconDescription();
    }
  });
  reset(span);
  var span_1 = sibling(span, 2);
  toggle_class(span_1, "bx--tile-content", true);
  var node_1 = child(span_1);
  slot(node_1, $$props, "default", {}, null);
  reset(span_1);
  reset(label);
  template_effect(() => {
    set_attribute(input, "id", id());
    set_attribute(input, "name", $groupName() ?? name());
    set_value(input, value());
    set_checked(input, checked());
    set_attribute(input, "tabindex", disabled() ? void 0 : tabindex());
    input.disabled = disabled();
    input.required = $groupRequired() ?? required();
    toggle_class(input, "bx--tile-input", true);
    attributes = set_attributes(label, attributes, { for: id(), ...$$restProps });
    toggle_class(label, "bx--tile", true);
    toggle_class(label, "bx--tile--selectable", true);
    toggle_class(label, "bx--tile--is-selected", checked());
    toggle_class(label, "bx--tile--light", light());
    toggle_class(label, "bx--tile--disabled", disabled());
  });
  event2("change", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("change", input, () => {
    if (disabled()) return;
    update2(value());
  });
  event2("keydown", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", input, (e) => {
    if (disabled()) return;
    if (strict_equals(e.key, " ") || strict_equals(e.key, "Enter")) {
      e.preventDefault();
      update2(value());
    }
  });
  event2("click", label, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", label, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", label, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", label, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  RadioTile = hmr(RadioTile, () => RadioTile[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RadioTile[HMR].source;
    set(RadioTile[HMR].source, module.default[HMR].original);
  });
}
var RadioTile_default = RadioTile;
mark_module_end(RadioTile);

// node_modules/carbon-components-svelte/src/Tile/TileGroup.svelte
mark_module_start();
TileGroup[FILENAME] = "node_modules/carbon-components-svelte/src/Tile/TileGroup.svelte";
var root_188 = add_locations(template(`<legend> </legend>`), TileGroup[FILENAME], [[61, 4]]);
var root134 = add_locations(template(`<fieldset><!> <div><!></div></fieldset>`), TileGroup[FILENAME], [[59, 0, [[63, 2]]]]);
function TileGroup($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "selected",
    "disabled",
    "required",
    "name",
    "legend"
  ]);
  push($$props, false, TileGroup);
  const [$$stores, $$cleanup] = setup_stores();
  const $selectedValue = () => (validate_store(selectedValue, "selectedValue"), store_get(selectedValue, "$selectedValue", $$stores));
  const $groupName = () => (validate_store(groupName, "groupName"), store_get(groupName, "$groupName", $$stores));
  const $groupRequired = () => (validate_store(groupRequired, "groupRequired"), store_get(groupRequired, "$groupRequired", $$stores));
  let selected = prop($$props, "selected", 12, void 0);
  let disabled = prop($$props, "disabled", 8, false);
  let required = prop($$props, "required", 8, void 0);
  let name = prop($$props, "name", 8, void 0);
  let legend = prop($$props, "legend", 8, "");
  const dispatch = createEventDispatcher();
  const selectedValue = writable(selected());
  const groupName = writable(name());
  const groupRequired = writable(required());
  setContext("TileGroup", {
    selectedValue,
    groupName: readonly(groupName),
    groupRequired: readonly(groupRequired),
    add: ({ checked, value }) => {
      if (checked) {
        selectedValue.set(value);
      }
    },
    update: (value) => {
      selectedValue.set(value);
      dispatch("select", value);
    }
  });
  legacy_pre_effect(() => $selectedValue(), () => {
    selected($selectedValue());
  });
  legacy_pre_effect(() => deep_read_state(selected()), () => {
    selectedValue.set(selected());
  });
  legacy_pre_effect(() => deep_read_state(name()), () => {
    store_set(groupName, name());
  });
  legacy_pre_effect(() => deep_read_state(required()), () => {
    store_set(groupRequired, required());
  });
  legacy_pre_effect_reset();
  init();
  var fieldset = root134();
  let attributes;
  var node = child(fieldset);
  {
    var consequent = ($$anchor2) => {
      var legend_1 = root_188();
      toggle_class(legend_1, "bx--label", true);
      var text2 = child(legend_1, true);
      reset(legend_1);
      template_effect(() => set_text(text2, legend()));
      append($$anchor2, legend_1);
    };
    if_block(node, ($$render) => {
      if (legend()) $$render(consequent);
    });
  }
  var div = sibling(node, 2);
  var node_1 = child(div);
  slot(node_1, $$props, "default", {}, null);
  reset(div);
  reset(fieldset);
  template_effect(() => {
    attributes = set_attributes(fieldset, attributes, { disabled: disabled(), ...$$restProps });
    toggle_class(fieldset, "bx--tile-group", true);
  });
  append($$anchor, fieldset);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  TileGroup = hmr(TileGroup, () => TileGroup[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TileGroup[HMR].source;
    set(TileGroup[HMR].source, module.default[HMR].original);
  });
}
var TileGroup_default = TileGroup;
mark_module_end(TileGroup);

// node_modules/carbon-components-svelte/src/TimePicker/TimePicker.svelte
mark_module_start();
TimePicker[FILENAME] = "node_modules/carbon-components-svelte/src/TimePicker/TimePicker.svelte";
var root_189 = add_locations(template(`<label><!></label>`), TimePicker[FILENAME], [[74, 8]]);
var root_318 = add_locations(template(`<div> </div>`), TimePicker[FILENAME], [[113, 4]]);
var root135 = add_locations(template(`<div><div><div><!> <input></div> <!></div> <!></div>`), TimePicker[FILENAME], [
  [
    57,
    0,
    [
      [64, 2, [[72, 4, [[85, 6]]]]]
    ]
  ]
]);
function TimePicker($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "size",
    "value",
    "placeholder",
    "pattern",
    "maxlength",
    "light",
    "disabled",
    "labelText",
    "hideLabel",
    "invalid",
    "invalidText",
    "id",
    "name",
    "ref"
  ]);
  push($$props, false, TimePicker);
  let size = prop($$props, "size", 8, void 0);
  let value = prop($$props, "value", 12, "");
  let placeholder = prop($$props, "placeholder", 8, "hh:mm");
  let pattern = prop($$props, "pattern", 8, "(1[012]|[1-9]):[0-5][0-9](\\s)?");
  let maxlength = prop($$props, "maxlength", 8, 5);
  let light = prop($$props, "light", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let labelText = prop($$props, "labelText", 8, "");
  let hideLabel = prop($$props, "hideLabel", 8, false);
  let invalid = prop($$props, "invalid", 8, false);
  let invalidText = prop($$props, "invalidText", 8, "");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let name = prop($$props, "name", 8, void 0);
  let ref = prop($$props, "ref", 12, null);
  init();
  var div = root135();
  toggle_class(div, "bx--form-item", true);
  var div_1 = child(div);
  toggle_class(div_1, "bx--time-picker", true);
  var div_2 = child(div_1);
  toggle_class(div_2, "bx--time-picker__input", true);
  var node = child(div_2);
  {
    var consequent = ($$anchor2) => {
      var label = root_189();
      var node_1 = child(label);
      slot(node_1, $$props, "labelText", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, labelText()));
        append($$anchor3, text2);
      });
      reset(label);
      template_effect(() => {
        set_attribute(label, "for", id());
        toggle_class(label, "bx--label", true);
        toggle_class(label, "bx--visually-hidden", hideLabel());
        toggle_class(label, "bx--label--disabled", disabled());
      });
      append($$anchor2, label);
    };
    if_block(node, ($$render) => {
      if (labelText() || $$slots.labelText) $$render(consequent);
    });
  }
  var input = sibling(node, 2);
  remove_input_defaults(input);
  let attributes;
  bind_this(input, ($$value) => ref($$value), () => ref());
  reset(div_2);
  var node_2 = sibling(div_2, 2);
  slot(node_2, $$props, "default", {}, null);
  reset(div_1);
  var node_3 = sibling(div_1, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var div_3 = root_318();
      toggle_class(div_3, "bx--form-requirement", true);
      var text_1 = child(div_3, true);
      reset(div_3);
      template_effect(() => set_text(text_1, invalidText()));
      append($$anchor2, div_3);
    };
    if_block(node_3, ($$render) => {
      if (invalid()) $$render(consequent_1);
    });
  }
  reset(div);
  template_effect(() => {
    toggle_class(div_1, "bx--time-picker--light", light());
    toggle_class(div_1, "bx--time-picker--invalid", invalid());
    toggle_class(div_1, "bx--time-picker--sm", strict_equals(size(), "sm"));
    toggle_class(div_1, "bx--time-picker--xl", strict_equals(size(), "xl"));
    toggle_class(div_1, "bx--select--light", light());
    attributes = set_attributes(input, attributes, {
      type: "text",
      "data-invalid": invalid() || void 0,
      pattern: pattern(),
      placeholder: placeholder(),
      maxlength: maxlength(),
      id: id(),
      name: name(),
      disabled: disabled(),
      ...$$restProps
    });
    toggle_class(input, "bx--time-picker__input-field", true);
    toggle_class(input, "bx--text-input", true);
    toggle_class(input, "bx--text-input--light", light());
    toggle_class(input, "bx--text-input--invalid", invalid());
  });
  bind_value(input, value);
  event2("change", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("input", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keyup", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("focus", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("blur", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("paste", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TimePicker = hmr(TimePicker, () => TimePicker[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TimePicker[HMR].source;
    set(TimePicker[HMR].source, module.default[HMR].original);
  });
}
var TimePicker_default = TimePicker;
mark_module_end(TimePicker);

// node_modules/carbon-components-svelte/src/TimePicker/TimePickerSelect.svelte
mark_module_start();
TimePickerSelect[FILENAME] = "node_modules/carbon-components-svelte/src/TimePicker/TimePickerSelect.svelte";
var root_190 = add_locations(template(`<label><!></label>`), TimePickerSelect[FILENAME], [[53, 4]]);
var root136 = add_locations(template(`<div><!> <select><!></select> <!></div>`), TimePickerSelect[FILENAME], [[43, 0, [[64, 2]]]]);
function TimePickerSelect($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "value",
    "disabled",
    "iconDescription",
    "labelText",
    "id",
    "name",
    "ref"
  ]);
  push($$props, false, TimePickerSelect);
  const [$$stores, $$cleanup] = setup_stores();
  const $selectedValue = () => (validate_store(selectedValue, "selectedValue"), store_get(selectedValue, "$selectedValue", $$stores));
  let value = prop($$props, "value", 12, "");
  let disabled = prop($$props, "disabled", 8, false);
  let iconDescription = prop($$props, "iconDescription", 8, "Open list of options");
  let labelText = prop($$props, "labelText", 8, "");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let name = prop($$props, "name", 8, void 0);
  let ref = prop($$props, "ref", 12, null);
  const selectedValue = writable(value());
  setContext("TimePickerSelect", { selectedValue });
  legacy_pre_effect(() => $selectedValue(), () => {
    value($selectedValue());
  });
  legacy_pre_effect(() => deep_read_state(value()), () => {
    selectedValue.set(value());
  });
  legacy_pre_effect_reset();
  init();
  var div = root136();
  let attributes;
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var label = root_190();
      var node_1 = child(label);
      slot(node_1, $$props, "labelText", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, labelText()));
        append($$anchor3, text2);
      });
      reset(label);
      template_effect(() => {
        set_attribute(label, "for", id());
        toggle_class(label, "bx--label", true);
        toggle_class(label, "bx--visually-hidden", true);
      });
      append($$anchor2, label);
    };
    if_block(node, ($$render) => {
      if (labelText() || $$slots.labelText) $$render(consequent);
    });
  }
  var select = sibling(node, 2);
  init_select(select, value);
  var select_value;
  var node_2 = child(select);
  slot(node_2, $$props, "default", {}, null);
  reset(select);
  bind_this(select, ($$value) => ref($$value), () => ref());
  var node_3 = sibling(select, 2);
  ChevronDown_default(node_3, {
    get "aria-label"() {
      return iconDescription();
    },
    get title() {
      return iconDescription();
    },
    class: "bx--select__arrow"
  });
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--select", true);
    toggle_class(div, "bx--time-picker__select", true);
    set_attribute(select, "id", id());
    set_attribute(select, "name", name());
    select.disabled = disabled();
    if (select_value !== (select_value = value())) {
      select.value = null == (select.__value = value()) ? "" : value(), select_option(select, value());
    }
    toggle_class(select, "bx--select-input", true);
  });
  event2("change", select, ({ target }) => {
    selectedValue.set(target.value);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  TimePickerSelect = hmr(TimePickerSelect, () => TimePickerSelect[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TimePickerSelect[HMR].source;
    set(TimePickerSelect[HMR].source, module.default[HMR].original);
  });
}
var TimePickerSelect_default = TimePickerSelect;
mark_module_end(TimePickerSelect);

// node_modules/carbon-components-svelte/src/Toggle/ToggleSkeleton.svelte
mark_module_start();
ToggleSkeleton[FILENAME] = "node_modules/carbon-components-svelte/src/Toggle/ToggleSkeleton.svelte";
var root_191 = add_locations(template(`<span><!></span>`), ToggleSkeleton[FILENAME], [[41, 6]]);
var root137 = add_locations(template(`<div><input type="checkbox"> <label><!> <span></span> <span></span> <span></span></label></div>`), ToggleSkeleton[FILENAME], [
  [
    17,
    0,
    [
      [25, 2],
      [
        32,
        2,
        [[47, 4], [48, 4], [49, 4]]
      ]
    ]
  ]
]);
function ToggleSkeleton($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "labelText", "id"]);
  push($$props, false, ToggleSkeleton);
  let size = prop($$props, "size", 8, "default");
  let labelText = prop($$props, "labelText", 8, "");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  init();
  var div = root137();
  let attributes;
  var input = child(div);
  var label = sibling(input, 2);
  var node = child(label);
  {
    var consequent = ($$anchor2) => {
      var span = root_191();
      toggle_class(span, "bx--toggle__label-text", true);
      var node_1 = child(span);
      slot(node_1, $$props, "labelText", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, labelText()));
        append($$anchor3, text2);
      });
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if (labelText() || $$slots.labelText) $$render(consequent);
    });
  }
  var span_1 = sibling(node, 2);
  toggle_class(span_1, "bx--toggle__text--left", true);
  var span_2 = sibling(span_1, 2);
  toggle_class(span_2, "bx--toggle__appearance", true);
  var span_3 = sibling(span_2, 2);
  toggle_class(span_3, "bx--toggle__text--right", true);
  reset(label);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    toggle_class(div, "bx--form-item", true);
    set_attribute(input, "id", id());
    toggle_class(input, "bx--toggle", true);
    toggle_class(input, "bx--toggle--small", strict_equals(size(), "sm"));
    toggle_class(input, "bx--skeleton", true);
    set_attribute(label, "aria-label", labelText() ? void 0 : $$sanitized_props["aria-label"] || "Toggle is loading");
    set_attribute(label, "for", id());
    toggle_class(label, "bx--toggle__label", true);
    toggle_class(label, "bx--skeleton", true);
  });
  event2("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ToggleSkeleton = hmr(ToggleSkeleton, () => ToggleSkeleton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ToggleSkeleton[HMR].source;
    set(ToggleSkeleton[HMR].source, module.default[HMR].original);
  });
}
var ToggleSkeleton_default = ToggleSkeleton;
mark_module_end(ToggleSkeleton);

// node_modules/carbon-components-svelte/src/icons/Information.svelte
mark_module_start();
Information[FILENAME] = "node_modules/carbon-components-svelte/src/icons/Information.svelte";
var root_192 = add_locations(ns_template(`<title> </title>`), Information[FILENAME], [[24, 13]]);
var root138 = add_locations(ns_template(`<svg><!><path d="M17 22L17 14 13 14 13 16 15 16 15 22 12 22 12 24 20 24 20 22 17 22zM16 8a1.5 1.5 0 101.5 1.5A1.5 1.5 0 0016 8z"></path><path d="M16,30A14,14,0,1,1,30,16,14,14,0,0,1,16,30ZM16,4A12,12,0,1,0,28,16,12,12,0,0,0,16,4Z"></path></svg>`), Information[FILENAME], [[14, 0, [[25, 2], [27, 10]]]]);
function Information($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, Information);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root138();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_192();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next(2);
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Information = hmr(Information, () => Information[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Information[HMR].source;
    set(Information[HMR].source, module.default[HMR].original);
  });
}
var Information_default = Information;
mark_module_end(Information);

// node_modules/carbon-components-svelte/src/Tooltip/Tooltip.svelte
mark_module_start();
Tooltip[FILENAME] = "node_modules/carbon-components-svelte/src/Tooltip/Tooltip.svelte";
var root_193 = add_locations(template(`<div><!> <div><!></div></div>`), Tooltip[FILENAME], [[208, 4, [[211, 6]]]]);
var root_412 = add_locations(template(`<div><!></div>`), Tooltip[FILENAME], [[226, 4]]);
var root_613 = add_locations(template(`<div><span></span>  <div tabindex="-1" role="dialog"><!></div></div>`), Tooltip[FILENAME], [[240, 4, [[255, 6], [258, 6]]]]);
var root139 = add_locations(template(`<div><!> <!></div>`), Tooltip[FILENAME], [[202, 0]]);
function Tooltip($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "align",
    "direction",
    "open",
    "hideIcon",
    "icon",
    "iconDescription",
    "iconName",
    "tabindex",
    "tooltipId",
    "triggerId",
    "triggerText",
    "ref",
    "refTooltip",
    "refIcon"
  ]);
  push($$props, false, Tooltip);
  const buttonProps = mutable_state();
  let align = prop($$props, "align", 8, "center");
  let direction = prop($$props, "direction", 8, "bottom");
  let open = prop($$props, "open", 12, false);
  let hideIcon = prop($$props, "hideIcon", 8, false);
  let icon = prop($$props, "icon", 8, Information_default);
  let iconDescription = prop($$props, "iconDescription", 8, "");
  let iconName = prop($$props, "iconName", 8, "");
  let tabindex = prop($$props, "tabindex", 8, "0");
  let tooltipId = prop($$props, "tooltipId", 24, () => "ccs-" + Math.random().toString(36));
  let triggerId = prop($$props, "triggerId", 24, () => "ccs-" + Math.random().toString(36));
  let triggerText = prop($$props, "triggerText", 8, "");
  let ref = prop($$props, "ref", 12, null);
  let refTooltip = prop($$props, "refTooltip", 12, null);
  let refIcon = prop($$props, "refIcon", 12, null);
  const dispatch = createEventDispatcher();
  const tooltipOpen = writable(open());
  setContext("Tooltip", { tooltipOpen });
  function onKeydown(e) {
    var _a;
    if (strict_equals(e.key, "Escape") || strict_equals(e.key, "Tab")) {
      e.stopPropagation();
      if (strict_equals(e.key, "Escape")) (_a = refIcon()) == null ? void 0 : _a.focus();
      open(false);
    } else if (strict_equals(e.key, " ") || strict_equals(e.key, "Enter")) {
      e.stopPropagation();
      e.preventDefault();
      open(true);
    }
  }
  function onBlur({ relatedTarget }) {
    if (refTooltip() && !refTooltip().contains(relatedTarget)) {
      open(false);
    }
  }
  function onFocus() {
    open(true);
  }
  function onMousedown() {
    const shouldClose = open();
    setTimeout(() => {
      open(shouldClose ? false : true);
    });
  }
  afterUpdate(() => {
    if (open()) {
      const button = ref().getBoundingClientRect();
      const tooltip = refTooltip().getBoundingClientRect();
      let iconWidth = 16;
      let iconHeight = 16;
      if (refIcon()) {
        const icon2 = refIcon().getBoundingClientRect();
        iconWidth = icon2.width;
        iconHeight = icon2.height;
      }
      let offsetX = 0;
      let offsetY = 0;
      switch (direction()) {
        case "bottom":
          if (hideIcon()) {
            offsetX = -1 * (tooltip.width / 2 - button.width / 2);
          } else {
            offsetX = -1 * (tooltip.width / 2 - button.width + iconWidth / 2);
          }
          offsetY = iconHeight / 2;
          break;
        case "right":
          offsetX = button.width + 6;
          offsetY = -1 * (tooltip.height / 2 + iconWidth / 2 - 3);
          break;
        case "left":
          if (hideIcon()) {
            offsetX = -1 * (tooltip.width + 6 + 1);
          } else {
            offsetX = -1 * (tooltip.width - button.width + iconWidth + 8);
          }
          offsetY = -1 * (tooltip.height / 2 + button.height) - 2;
          break;
        case "top":
          if (hideIcon()) {
            offsetX = -1 * (tooltip.width / 2 - button.width / 2);
          } else {
            offsetX = -1 * (tooltip.width / 2 - button.width + iconWidth / 2 + 1);
          }
          offsetY = -1 * (tooltip.height + button.height + iconWidth / 2 - 1);
          break;
      }
      refTooltip(refTooltip().style.left = offsetX + "px", true);
      refTooltip(refTooltip().style.marginTop = offsetY + "px", true);
    }
  });
  legacy_pre_effect(() => deep_read_state(open()), () => {
    tooltipOpen.set(open());
  });
  legacy_pre_effect(() => deep_read_state(open()), () => {
    dispatch(open() ? "open" : "close");
  });
  legacy_pre_effect(
    () => (deep_read_state(hideIcon()), deep_read_state(triggerId()), deep_read_state(open()), deep_read_state(tooltipId()), deep_read_state(triggerText()), deep_read_state(iconDescription()), deep_read_state(tabindex()), deep_read_state($$restProps)),
    () => {
      set(buttonProps, {
        role: "button",
        "aria-haspopup": "true",
        id: hideIcon() ? triggerId() : void 0,
        class: hideIcon() ? "bx--tooltip__label" : "bx--tooltip__trigger",
        "aria-expanded": open(),
        "aria-describedby": open() ? tooltipId() : void 0,
        "aria-labelledby": triggerText() ? triggerId() : void 0,
        "aria-label": triggerText() ? void 0 : iconDescription(),
        tabindex: tabindex(),
        style: hideIcon() ? $$restProps.style : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root139();
  event2("mousedown", $window, ({ target }) => {
    if (open()) {
      if (target.contains(refTooltip())) {
        if (refIcon()) {
          refIcon().focus();
        } else if (ref()) {
          ref().focus();
        }
      }
    }
  });
  event2(
    "click",
    $window,
    ({ target }) => {
      if (open() && !ref().contains(target) && !refTooltip().contains(target)) {
        setTimeout(() => {
          open(false);
        });
      }
    },
    true
  );
  let attributes;
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var div_1 = root_193();
      var node_1 = child(div_1);
      slot(node_1, $$props, "triggerText", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, triggerText()));
        append($$anchor3, text2);
      });
      var div_2 = sibling(node_1, 2);
      let attributes_1;
      var node_2 = child(div_2);
      slot(node_2, $$props, "icon", {}, ($$anchor3) => {
        var fragment_1 = comment();
        var node_3 = first_child(fragment_1);
        component(node_3, icon, ($$anchor4, $$component) => {
          $$component($$anchor4, {
            get name() {
              return iconName();
            }
          });
        });
        append($$anchor3, fragment_1);
      });
      reset(div_2);
      bind_this(div_2, ($$value) => refIcon($$value), () => refIcon());
      reset(div_1);
      bind_this(div_1, ($$value) => ref($$value), () => ref());
      template_effect(() => {
        set_attribute(div_1, "id", triggerId());
        toggle_class(div_1, "bx--tooltip__label", true);
        attributes_1 = set_attributes(div_2, attributes_1, {
          ...get(buttonProps),
          "aria-describedby": tooltipId()
        });
      });
      event2("mousedown", div_2, onMousedown);
      event2("focus", div_2, onFocus);
      event2("keydown", div_2, onKeydown);
      append($$anchor2, div_1);
    };
    var alternate = ($$anchor2) => {
      var div_3 = root_412();
      let attributes_2;
      var node_4 = child(div_3);
      slot(node_4, $$props, "triggerText", {}, ($$anchor3) => {
        var text_1 = text();
        template_effect(() => set_text(text_1, triggerText()));
        append($$anchor3, text_1);
      });
      reset(div_3);
      bind_this(div_3, ($$value) => ref($$value), () => ref());
      template_effect(() => attributes_2 = set_attributes(div_3, attributes_2, {
        ...get(buttonProps),
        "aria-describedby": tooltipId()
      }));
      event2("mousedown", div_3, onMousedown);
      event2("focus", div_3, onFocus);
      event2("blur", div_3, onBlur);
      event2("keydown", div_3, onKeydown);
      append($$anchor2, div_3);
    };
    if_block(node, ($$render) => {
      if (!hideIcon()) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_5 = sibling(node, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var div_4 = root_613();
      var span = child(div_4);
      toggle_class(span, "bx--tooltip__caret", true);
      var div_5 = sibling(span, 2);
      toggle_class(div_5, "bx--tooltip__content", true);
      var node_6 = child(div_5);
      slot(node_6, $$props, "default", {}, null);
      reset(div_5);
      reset(div_4);
      bind_this(div_4, ($$value) => refTooltip($$value), () => refTooltip());
      template_effect(() => {
        set_attribute(div_4, "id", tooltipId());
        set_attribute(div_4, "data-floating-menu-direction", direction());
        toggle_class(div_4, "bx--tooltip", true);
        toggle_class(div_4, "bx--tooltip--shown", open());
        toggle_class(div_4, "bx--tooltip--top", strict_equals(direction(), "top"));
        toggle_class(div_4, "bx--tooltip--right", strict_equals(direction(), "right"));
        toggle_class(div_4, "bx--tooltip--bottom", strict_equals(direction(), "bottom"));
        toggle_class(div_4, "bx--tooltip--left", strict_equals(direction(), "left"));
        toggle_class(div_4, "bx--tooltip--align-center", strict_equals(align(), "center"));
        toggle_class(div_4, "bx--tooltip--align-start", strict_equals(align(), "start"));
        toggle_class(div_4, "bx--tooltip--align-end", strict_equals(align(), "end"));
      });
      event2("click", div_5, stopPropagation(function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      }));
      event2("mousedown", div_5, stopPropagation(function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      }));
      event2("keydown", div_4, onKeydown);
      append($$anchor2, div_4);
    };
    if_block(node_5, ($$render) => {
      if (open()) $$render(consequent_1);
    });
  }
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps });
    set_style(div, "position", "relative");
    set_style(div, "z-index", open() ? 1 : void 0);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip = hmr(Tooltip, () => Tooltip[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip[HMR].source;
    set(Tooltip[HMR].source, module.default[HMR].original);
  });
}
var Tooltip_default = Tooltip;
mark_module_end(Tooltip);

// node_modules/carbon-components-svelte/src/Tooltip/TooltipFooter.svelte
mark_module_start();
TooltipFooter[FILENAME] = "node_modules/carbon-components-svelte/src/Tooltip/TooltipFooter.svelte";
var root140 = add_locations(template(`<div><!></div>`), TooltipFooter[FILENAME], [[27, 0]]);
function TooltipFooter($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, TooltipFooter);
  let selectorPrimaryFocus = prop($$props, "selectorPrimaryFocus", 8, "a[href], button:not([disabled])");
  let ref = mutable_state(null);
  let open = mutable_state(false);
  const ctx = getContext("Tooltip");
  const unsubscribe = ctx.tooltipOpen.subscribe((tooltipOpen) => {
    set(open, tooltipOpen);
  });
  onMount(() => {
    return () => {
      unsubscribe();
    };
  });
  legacy_pre_effect(
    () => (get(open), get(ref), deep_read_state(selectorPrimaryFocus())),
    () => {
      if (get(open) && get(ref)) {
        const node = get(ref).querySelector(selectorPrimaryFocus());
        if (node) node.focus();
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root140();
  toggle_class(div, "bx--tooltip__footer", true);
  var node_1 = child(div);
  slot(node_1, $$props, "default", {}, null);
  reset(div);
  bind_this(div, ($$value) => set(ref, $$value), () => get(ref));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TooltipFooter = hmr(TooltipFooter, () => TooltipFooter[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TooltipFooter[HMR].source;
    set(TooltipFooter[HMR].source, module.default[HMR].original);
  });
}
var TooltipFooter_default = TooltipFooter;
mark_module_end(TooltipFooter);

// node_modules/carbon-components-svelte/src/TooltipDefinition/TooltipDefinition.svelte
mark_module_start();
TooltipDefinition[FILENAME] = "node_modules/carbon-components-svelte/src/TooltipDefinition/TooltipDefinition.svelte";
var root141 = add_locations(template(`<span><button type="button"><!></button> <div role="tooltip"><!></div></span>`), TooltipDefinition[FILENAME], [[51, 0, [[58, 2], [82, 2]]]]);
function TooltipDefinition($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "tooltipText",
    "open",
    "align",
    "direction",
    "id",
    "ref"
  ]);
  push($$props, false, TooltipDefinition);
  let tooltipText = prop($$props, "tooltipText", 8, "");
  let open = prop($$props, "open", 12, false);
  let align = prop($$props, "align", 8, "center");
  let direction = prop($$props, "direction", 8, "bottom");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let ref = prop($$props, "ref", 12, null);
  const dispatch = createEventDispatcher();
  const hide = () => open(false);
  const show = () => open(true);
  legacy_pre_effect(() => deep_read_state(open()), () => {
    dispatch(open() ? "open" : "close");
  });
  legacy_pre_effect_reset();
  init();
  var span = root141();
  event2("keydown", $window, ({ key }) => {
    if (strict_equals(key, "Escape")) hide();
  });
  let attributes;
  var button = child(span);
  var node = child(button);
  slot(node, $$props, "default", {}, null);
  reset(button);
  bind_this(button, ($$value) => ref($$value), () => ref());
  var div = sibling(button, 2);
  var node_1 = child(div);
  slot(node_1, $$props, "tooltip", {}, ($$anchor2) => {
    var text2 = text();
    template_effect(() => set_text(text2, tooltipText()));
    append($$anchor2, text2);
  });
  reset(div);
  reset(span);
  template_effect(() => {
    attributes = set_attributes(span, attributes, { ...$$restProps });
    toggle_class(span, "bx--tooltip--definition", true);
    toggle_class(span, "bx--tooltip--a11y", true);
    set_attribute(button, "aria-describedby", id());
    toggle_class(button, "bx--tooltip--a11y", true);
    toggle_class(button, "bx--tooltip__trigger", true);
    toggle_class(button, "bx--tooltip__trigger--definition", true);
    toggle_class(button, "bx--tooltip--hidden", !open());
    toggle_class(button, "bx--tooltip--visible", open());
    toggle_class(button, "bx--tooltip--top", strict_equals(direction(), "top"));
    toggle_class(button, "bx--tooltip--bottom", strict_equals(direction(), "bottom"));
    toggle_class(button, "bx--tooltip--align-start", strict_equals(align(), "start"));
    toggle_class(button, "bx--tooltip--align-center", strict_equals(align(), "center"));
    toggle_class(button, "bx--tooltip--align-end", strict_equals(align(), "end"));
    set_attribute(div, "id", id());
    toggle_class(div, "bx--assistive-text", true);
  });
  event2("click", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("focus", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("focus", button, show);
  event2("blur", button, hide);
  event2("mouseenter", span, show);
  event2("mouseleave", span, hide);
  append($$anchor, span);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TooltipDefinition = hmr(TooltipDefinition, () => TooltipDefinition[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TooltipDefinition[HMR].source;
    set(TooltipDefinition[HMR].source, module.default[HMR].original);
  });
}
var TooltipDefinition_default = TooltipDefinition;
mark_module_end(TooltipDefinition);

// node_modules/carbon-components-svelte/src/TooltipIcon/TooltipIcon.svelte
mark_module_start();
TooltipIcon[FILENAME] = "node_modules/carbon-components-svelte/src/TooltipIcon/TooltipIcon.svelte";
var root142 = add_locations(template(`<button><span><!></span> <!></button>`), TooltipIcon[FILENAME], [[46, 0, [[76, 2]]]]);
function TooltipIcon($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "tooltipText",
    "icon",
    "disabled",
    "align",
    "direction",
    "id",
    "ref"
  ]);
  push($$props, false, TooltipIcon);
  let tooltipText = prop($$props, "tooltipText", 8, "");
  let icon = prop($$props, "icon", 8, void 0);
  let disabled = prop($$props, "disabled", 8, false);
  let align = prop($$props, "align", 8, "center");
  let direction = prop($$props, "direction", 8, "bottom");
  let id = prop($$props, "id", 24, () => "ccs-" + Math.random().toString(36));
  let ref = prop($$props, "ref", 12, null);
  let hidden = mutable_state(false);
  init();
  var button = root142();
  event2("keydown", $window, ({ key }) => {
    if (strict_equals(key, "Escape")) {
      set(hidden, true);
    }
  });
  let attributes;
  var span = child(button);
  var node = child(span);
  slot(node, $$props, "tooltipText", {}, ($$anchor2) => {
    var text2 = text();
    template_effect(() => set_text(text2, tooltipText()));
    append($$anchor2, text2);
  });
  reset(span);
  var node_1 = sibling(span, 2);
  slot(node_1, $$props, "default", {}, ($$anchor2) => {
    var fragment_1 = comment();
    var node_2 = first_child(fragment_1);
    component(node_2, icon, ($$anchor3, $$component) => {
      $$component($$anchor3, {});
    });
    append($$anchor2, fragment_1);
  });
  reset(button);
  bind_this(button, ($$value) => ref($$value), () => ref());
  template_effect(() => {
    attributes = set_attributes(button, attributes, {
      disabled: disabled(),
      "aria-describedby": id(),
      ...$$restProps
    });
    toggle_class(button, "bx--tooltip__trigger", true);
    toggle_class(button, "bx--tooltip--a11y", true);
    toggle_class(button, "bx--tooltip--hidden", get(hidden) || disabled());
    toggle_class(button, "bx--tooltip--top", strict_equals(direction(), "top"));
    toggle_class(button, "bx--tooltip--right", strict_equals(direction(), "right"));
    toggle_class(button, "bx--tooltip--bottom", strict_equals(direction(), "bottom"));
    toggle_class(button, "bx--tooltip--left", strict_equals(direction(), "left"));
    toggle_class(button, "bx--tooltip--align-start", strict_equals(align(), "start"));
    toggle_class(button, "bx--tooltip--align-center", strict_equals(align(), "center"));
    toggle_class(button, "bx--tooltip--align-end", strict_equals(align(), "end"));
    set_style(button, "cursor", disabled() ? "not-allowed" : "default");
    set_attribute(span, "id", id());
    toggle_class(span, "bx--assistive-text", true);
  });
  event2("click", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", button, () => {
    if (disabled()) return;
    set(hidden, false);
  });
  event2("mouseleave", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("focus", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("focus", button, () => {
    if (disabled()) return;
    set(hidden, false);
  });
  append($$anchor, button);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TooltipIcon = hmr(TooltipIcon, () => TooltipIcon[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TooltipIcon[HMR].source;
    set(TooltipIcon[HMR].source, module.default[HMR].original);
  });
}
var TooltipIcon_default = TooltipIcon;
mark_module_end(TooltipIcon);

// node_modules/carbon-components-svelte/src/icons/CaretDown.svelte
mark_module_start();
CaretDown[FILENAME] = "node_modules/carbon-components-svelte/src/icons/CaretDown.svelte";
var root_194 = add_locations(ns_template(`<title> </title>`), CaretDown[FILENAME], [[24, 13]]);
var root143 = add_locations(ns_template(`<svg><!><path d="M24 12L16 22 8 12z"></path></svg>`), CaretDown[FILENAME], [[14, 0, [[25, 2]]]]);
function CaretDown($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, CaretDown);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root143();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_194();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next();
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CaretDown = hmr(CaretDown, () => CaretDown[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretDown[HMR].source;
    set(CaretDown[HMR].source, module.default[HMR].original);
  });
}
var CaretDown_default = CaretDown;
mark_module_end(CaretDown);

// node_modules/carbon-components-svelte/src/TreeView/TreeViewNode.svelte
mark_module_start();
TreeViewNode[FILENAME] = "node_modules/carbon-components-svelte/src/TreeView/TreeViewNode.svelte";
function computeTreeLeafDepth(node) {
  let depth = 0;
  if (equals(node, null)) return depth;
  let parentNode = node.parentNode;
  while (equals(parentNode, null, false) && strict_equals(parentNode.getAttribute("role"), "tree", false)) {
    parentNode = parentNode.parentNode;
    if (strict_equals(parentNode.tagName, "LI")) depth++;
  }
  return depth;
}
function findParentTreeNode(node) {
  if (node.classList.contains("bx--tree-parent-node")) return node;
  if (node.classList.contains("bx--tree")) return null;
  return findParentTreeNode(node.parentNode);
}
var root144 = add_locations(template(`<li role="treeitem"><div><!> <!></div></li>`), TreeViewNode[FILENAME], [[89, 0, [[127, 2]]]]);
function TreeViewNode($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, TreeViewNode);
  const [$$stores, $$cleanup] = setup_stores();
  const $activeNodeId = () => (validate_store(activeNodeId, "activeNodeId"), store_get(activeNodeId, "$activeNodeId", $$stores));
  const $selectedNodeIds = () => (validate_store(selectedNodeIds, "selectedNodeIds"), store_get(selectedNodeIds, "$selectedNodeIds", $$stores));
  const selected = mutable_state();
  const node = mutable_state();
  let leaf = prop($$props, "leaf", 8, false);
  let id = prop($$props, "id", 8, "");
  let text2 = prop($$props, "text", 8, "");
  let disabled = prop($$props, "disabled", 8, false);
  let icon = prop($$props, "icon", 8, void 0);
  let ref = mutable_state(null);
  let refLabel = mutable_state(null);
  let prevActiveId = void 0;
  const {
    activeNodeId,
    selectedNodeIds,
    clickNode,
    selectNode,
    focusNode
  } = getContext("TreeView");
  const offset = () => computeTreeLeafDepth(get(refLabel)) + (leaf() && icon() ? 2 : 2.5);
  afterUpdate(() => {
    if (strict_equals(id(), $activeNodeId()) && strict_equals(prevActiveId, $activeNodeId(), false)) {
      if (!$selectedNodeIds().includes(id())) selectNode(get(node));
    }
    prevActiveId = $activeNodeId();
  });
  legacy_pre_effect(
    () => ($selectedNodeIds(), deep_read_state(id())),
    () => {
      set(selected, $selectedNodeIds().includes(id()));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(id()), deep_read_state(text2()), deep_read_state(leaf()), deep_read_state(disabled()), get(selected)),
    () => {
      set(node, {
        id: id(),
        text: text2(),
        // A node cannot be expanded.
        expanded: false,
        leaf: leaf(),
        disabled: disabled(),
        selected: get(selected)
      });
    }
  );
  legacy_pre_effect(() => get(refLabel), () => {
    if (get(refLabel)) {
      mutate(refLabel, get(refLabel).style.marginLeft = `-${offset()}rem`);
      mutate(refLabel, get(refLabel).style.paddingLeft = `${offset()}rem`);
    }
  });
  legacy_pre_effect_reset();
  init();
  var li = root144();
  var div = child(li);
  toggle_class(div, "bx--tree-node__label", true);
  var node_1 = child(div);
  component(node_1, icon, ($$anchor2, $$component) => {
    $$component($$anchor2, { class: "bx--tree-node__icon" });
  });
  var node_2 = sibling(node_1, 2);
  slot(
    node_2,
    $$props,
    "default",
    {
      get node() {
        return get(node);
      }
    },
    ($$anchor2) => {
      var text_1 = text();
      template_effect(() => set_text(text_1, text2()));
      append($$anchor2, text_1);
    }
  );
  reset(div);
  bind_this(div, ($$value) => set(refLabel, $$value), () => get(refLabel));
  reset(li);
  bind_this(li, ($$value) => set(ref, $$value), () => get(ref));
  template_effect(() => {
    set_attribute(li, "id", id());
    set_attribute(li, "tabindex", disabled() ? void 0 : -1);
    set_attribute(li, "aria-current", strict_equals(id(), $activeNodeId()) || void 0);
    set_attribute(li, "aria-selected", disabled() ? void 0 : get(selected));
    set_attribute(li, "aria-disabled", disabled());
    toggle_class(li, "bx--tree-node", true);
    toggle_class(li, "bx--tree-leaf-node", true);
    toggle_class(li, "bx--tree-node--active", strict_equals(id(), $activeNodeId()));
    toggle_class(li, "bx--tree-node--selected", get(selected));
    toggle_class(li, "bx--tree-node--disabled", disabled());
    toggle_class(li, "bx--tree-node--with-icon", icon());
  });
  event2("click", li, stopPropagation(() => {
    if (disabled()) return;
    clickNode(get(node));
  }));
  event2("keydown", li, (e) => {
    if (strict_equals(e.key, "ArrowLeft") || strict_equals(e.key, "ArrowRight") || strict_equals(e.key, "Enter")) {
      e.stopPropagation();
    }
    if (strict_equals(e.key, "ArrowLeft")) {
      const parentNode = findParentTreeNode(get(ref).parentNode);
      if (parentNode) parentNode.focus();
    }
    if (strict_equals(e.key, "Enter") || strict_equals(e.key, " ")) {
      e.preventDefault();
      if (disabled()) return;
      clickNode(get(node));
    }
  });
  event2("focus", li, () => {
    focusNode(get(node));
  });
  append($$anchor, li);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  TreeViewNode = hmr(TreeViewNode, () => TreeViewNode[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TreeViewNode[HMR].source;
    set(TreeViewNode[HMR].source, module.default[HMR].original);
  });
}
var TreeViewNode_default = TreeViewNode;
mark_module_end(TreeViewNode);

// node_modules/carbon-components-svelte/src/TreeView/TreeViewNodeList.svelte
mark_module_start();
TreeViewNodeList[FILENAME] = "node_modules/carbon-components-svelte/src/TreeView/TreeViewNodeList.svelte";
var root_95 = add_locations(template(`<ul role="group"></ul>`), TreeViewNodeList[FILENAME], [[164, 6]]);
var root_88 = add_locations(template(`<li role="treeitem"><div><span><!></span> <span><!> <!></span></div> <!></li>`), TreeViewNodeList[FILENAME], [
  [
    82,
    2,
    [[140, 4, [[143, 6], [158, 6]]]]
  ]
]);
function TreeViewNodeList($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, TreeViewNodeList);
  const [$$stores, $$cleanup] = setup_stores();
  const $activeNodeId = () => (validate_store(activeNodeId, "activeNodeId"), store_get(activeNodeId, "$activeNodeId", $$stores));
  const $selectedNodeIds = () => (validate_store(selectedNodeIds, "selectedNodeIds"), store_get(selectedNodeIds, "$selectedNodeIds", $$stores));
  const $expandedNodeIds = () => (validate_store(expandedNodeIds, "expandedNodeIds"), store_get(expandedNodeIds, "$expandedNodeIds", $$stores));
  const parent2 = mutable_state();
  const node = mutable_state();
  const expanded = mutable_state();
  let children = prop($$props, "children", 24, () => []);
  let root169 = prop($$props, "root", 8, false);
  let id = prop($$props, "id", 8, "");
  let text2 = prop($$props, "text", 8, "");
  let disabled = prop($$props, "disabled", 8, false);
  let icon = prop($$props, "icon", 8, void 0);
  let ref = mutable_state(null);
  let refLabel = mutable_state(null);
  let prevActiveId = void 0;
  const {
    activeNodeId,
    selectedNodeIds,
    expandedNodeIds,
    clickNode,
    selectNode,
    expandNode,
    focusNode,
    toggleNode
  } = getContext("TreeView");
  const offset = () => {
    const depth = computeTreeLeafDepth(get(refLabel));
    if (get(parent2)) return depth + 1;
    if (icon()) return depth + 2;
    return depth + 2.5;
  };
  afterUpdate(() => {
    if (strict_equals(id(), $activeNodeId()) && strict_equals(prevActiveId, $activeNodeId(), false)) {
      if (!$selectedNodeIds().includes(id())) selectNode(get(node));
    }
    prevActiveId = $activeNodeId();
  });
  legacy_pre_effect(() => deep_read_state(children()), () => {
    set(parent2, Array.isArray(children()));
  });
  legacy_pre_effect(
    () => ($expandedNodeIds(), deep_read_state(id())),
    () => {
      set(expanded, $expandedNodeIds().includes(id()));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(id()), deep_read_state(text2()), get(expanded), get(parent2)),
    () => {
      set(node, {
        id: id(),
        text: text2(),
        expanded: get(expanded),
        leaf: !get(parent2)
      });
    }
  );
  legacy_pre_effect(() => get(refLabel), () => {
    if (get(refLabel)) {
      mutate(refLabel, get(refLabel).style.marginLeft = `-${offset()}rem`);
      mutate(refLabel, get(refLabel).style.paddingLeft = `${offset()}rem`);
    }
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node_1 = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      validate_each_keys(children, (child2) => child2.id);
      each(node_2, 1, children, (child2) => child2.id, ($$anchor3, child2) => {
        var fragment_2 = comment();
        var node_3 = first_child(fragment_2);
        {
          var consequent = ($$anchor4) => {
            var fragment_3 = comment();
            var node_4 = first_child(fragment_3);
            TreeViewNodeList(node_4, spread_props(() => get(child2), {
              children: invalid_default_snippet,
              $$slots: {
                default: ($$anchor5, $$slotProps) => {
                  const node2 = derived_safe_equal(() => $$slotProps.node);
                  var fragment_4 = comment();
                  var node_5 = first_child(fragment_4);
                  slot(
                    node_5,
                    $$props,
                    "default",
                    {
                      get node() {
                        return get(node2);
                      }
                    },
                    null
                  );
                  append($$anchor5, fragment_4);
                }
              }
            }));
            append($$anchor4, fragment_3);
          };
          var alternate = ($$anchor4) => {
            var fragment_5 = comment();
            var node_6 = first_child(fragment_5);
            TreeViewNode_default(node_6, spread_props({ leaf: true }, () => get(child2), {
              children: invalid_default_snippet,
              $$slots: {
                default: ($$anchor5, $$slotProps) => {
                  const node2 = derived_safe_equal(() => $$slotProps.node);
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  slot(
                    node_7,
                    $$props,
                    "default",
                    {
                      get node() {
                        return get(node2);
                      }
                    },
                    null
                  );
                  append($$anchor5, fragment_6);
                }
              }
            }));
            append($$anchor4, fragment_5);
          };
          if_block(node_3, ($$render) => {
            if (Array.isArray(get(child2).children)) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor3, fragment_2);
      });
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var li = root_88();
      const selected = derived_safe_equal(() => $selectedNodeIds().includes(id()));
      get(selected);
      var div = child(li);
      toggle_class(div, "bx--tree-node__label", true);
      var span = child(div);
      var node_8 = child(span);
      const expression = derived_safe_equal(() => get(expanded) && "bx--tree-parent-node__toggle-icon--expanded");
      CaretDown_default(node_8, {
        get class() {
          return `bx--tree-parent-node__toggle-icon ${get(expression) ?? ""}`;
        }
      });
      reset(span);
      var span_1 = sibling(span, 2);
      toggle_class(span_1, "bx--tree-node__label__details", true);
      var node_9 = child(span_1);
      component(node_9, icon, ($$anchor3, $$component) => {
        $$component($$anchor3, { class: "bx--tree-node__icon" });
      });
      var node_10 = sibling(node_9, 2);
      const expression_1 = derived_safe_equal(() => ({
        ...get(node),
        selected: get(selected),
        disabled: disabled()
      }));
      slot(
        node_10,
        $$props,
        "default",
        {
          get node() {
            return get(expression_1);
          }
        },
        null
      );
      reset(span_1);
      reset(div);
      bind_this(div, ($$value) => set(refLabel, $$value), () => get(refLabel));
      var node_11 = sibling(div, 2);
      {
        var consequent_3 = ($$anchor3) => {
          var ul = root_95();
          toggle_class(ul, "bx--tree-node__children", true);
          validate_each_keys(children, (child2) => child2.id);
          each(ul, 5, children, (child2) => child2.id, ($$anchor4, child2) => {
            var fragment_7 = comment();
            var node_12 = first_child(fragment_7);
            {
              var consequent_2 = ($$anchor5) => {
                var fragment_8 = comment();
                var node_13 = first_child(fragment_8);
                TreeViewNodeList(node_13, spread_props(() => get(child2), {
                  children: invalid_default_snippet,
                  $$slots: {
                    default: ($$anchor6, $$slotProps) => {
                      const node2 = derived_safe_equal(() => $$slotProps.node);
                      var fragment_9 = comment();
                      var node_14 = first_child(fragment_9);
                      slot(
                        node_14,
                        $$props,
                        "default",
                        {
                          get node() {
                            return get(node2);
                          }
                        },
                        null
                      );
                      append($$anchor6, fragment_9);
                    }
                  }
                }));
                append($$anchor5, fragment_8);
              };
              var alternate_1 = ($$anchor5) => {
                var fragment_10 = comment();
                var node_15 = first_child(fragment_10);
                TreeViewNode_default(node_15, spread_props({ leaf: true }, () => get(child2), {
                  children: invalid_default_snippet,
                  $$slots: {
                    default: ($$anchor6, $$slotProps) => {
                      const node2 = derived_safe_equal(() => $$slotProps.node);
                      var fragment_11 = comment();
                      var node_16 = first_child(fragment_11);
                      slot(
                        node_16,
                        $$props,
                        "default",
                        {
                          get node() {
                            return get(node2);
                          }
                        },
                        ($$anchor7) => {
                          var text_1 = text();
                          template_effect(() => set_text(text_1, get(node2).text));
                          append($$anchor7, text_1);
                        }
                      );
                      append($$anchor6, fragment_11);
                    }
                  }
                }));
                append($$anchor5, fragment_10);
              };
              if_block(node_12, ($$render) => {
                if (Array.isArray(get(child2).children)) $$render(consequent_2);
                else $$render(alternate_1, false);
              });
            }
            append($$anchor4, fragment_7);
          });
          reset(ul);
          append($$anchor3, ul);
        };
        if_block(node_11, ($$render) => {
          if (get(expanded)) $$render(consequent_3);
        });
      }
      reset(li);
      bind_this(li, ($$value) => set(ref, $$value), () => get(ref));
      template_effect(() => {
        set_attribute(li, "id", id());
        set_attribute(li, "tabindex", disabled() ? void 0 : -1);
        set_attribute(li, "aria-current", strict_equals(id(), $activeNodeId()) || void 0);
        set_attribute(li, "aria-selected", disabled() ? void 0 : get(selected));
        set_attribute(li, "aria-disabled", disabled());
        set_attribute(li, "aria-expanded", get(expanded));
        toggle_class(li, "bx--tree-node", true);
        toggle_class(li, "bx--tree-parent-node", true);
        toggle_class(li, "bx--tree-node--active", strict_equals(id(), $activeNodeId()));
        toggle_class(li, "bx--tree-node--selected", get(selected));
        toggle_class(li, "bx--tree-node--disabled", disabled());
        toggle_class(li, "bx--tree-node--with-icon", icon());
        span.disabled = disabled();
        toggle_class(span, "bx--tree-parent-node__toggle", true);
      });
      event2("click", span, () => {
        if (disabled()) return;
        set(expanded, !get(expanded));
        expandNode(get(node), get(expanded));
        toggleNode(get(node));
      });
      event2("click", li, stopPropagation(() => {
        if (disabled()) return;
        clickNode(get(node));
      }));
      event2("keydown", li, (e) => {
        var _a;
        if (strict_equals(e.key, "ArrowLeft") || strict_equals(e.key, "ArrowRight") || strict_equals(e.key, "Enter")) {
          e.stopPropagation();
        }
        if (get(parent2) && strict_equals(e.key, "ArrowLeft")) {
          set(expanded, false);
          expandNode(get(node), false);
          toggleNode(get(node));
        }
        if (get(parent2) && strict_equals(e.key, "ArrowRight")) {
          if (get(expanded)) {
            (_a = get(ref).lastChild.firstElementChild) == null ? void 0 : _a.focus();
          } else {
            set(expanded, true);
            expandNode(get(node), true);
            toggleNode(get(node));
          }
        }
        if (strict_equals(e.key, "Enter") || strict_equals(e.key, " ")) {
          e.preventDefault();
          if (disabled()) return;
          set(expanded, !get(expanded));
          toggleNode(get(node));
          clickNode(get(node));
          expandNode(get(node), get(expanded));
          get(ref).focus();
        }
      });
      event2("focus", li, () => {
        focusNode(get(node));
      });
      append($$anchor2, li);
    };
    if_block(node_1, ($$render) => {
      if (root169()) $$render(consequent_1);
      else $$render(alternate_2, false);
    });
  }
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  TreeViewNodeList = hmr(TreeViewNodeList, () => TreeViewNodeList[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TreeViewNodeList[HMR].source;
    set(TreeViewNodeList[HMR].source, module.default[HMR].original);
  });
}
var TreeViewNodeList_default = TreeViewNodeList;
mark_module_end(TreeViewNodeList);

// node_modules/carbon-components-svelte/src/TreeView/TreeView.svelte
mark_module_start();
TreeView[FILENAME] = "node_modules/carbon-components-svelte/src/TreeView/TreeView.svelte";
function findNodeById(node, id) {
  if (strict_equals(node, null)) return null;
  if (strict_equals(node.id, id)) return [node];
  if (!Array.isArray(node.children)) {
    return null;
  }
  for (const child2 of node.children) {
    const nodes = findNodeById(child2, id);
    if (Array.isArray(nodes)) {
      nodes.unshift(node);
      return nodes;
    }
  }
  return null;
}
var root_195 = add_locations(template(`<label><!></label>`), TreeView[FILENAME], [[245, 2]]);
var root145 = add_locations(template(`<!> <ul><!></ul>`, 1), TreeView[FILENAME], [[251, 0]]);
function TreeView($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "expandAll",
    "collapseAll",
    "expandNodes",
    "collapseNodes",
    "showNode",
    "children",
    "activeId",
    "selectedIds",
    "expandedIds",
    "size",
    "labelText",
    "hideLabel"
  ]);
  push($$props, false, TreeView);
  const nodes = mutable_state();
  const nodeIds = mutable_state();
  let children = prop($$props, "children", 24, () => []);
  let activeId = prop($$props, "activeId", 12, "");
  let selectedIds = prop($$props, "selectedIds", 28, () => []);
  let expandedIds = prop($$props, "expandedIds", 28, () => []);
  let size = prop($$props, "size", 8, "default");
  let labelText = prop($$props, "labelText", 8, "");
  let hideLabel = prop($$props, "hideLabel", 8, false);
  function expandAll() {
    expandedIds([...get(nodeIds)]);
  }
  function collapseAll() {
    expandedIds([]);
  }
  function expandNodes(filterNode = (node) => false) {
    expandedIds(get(nodes).filter((node) => {
      var _a;
      return filterNode(node) || ((_a = node.children) == null ? void 0 : _a.some((child2) => filterNode(child2) && child2.children));
    }).map((node) => node.id));
  }
  function collapseNodes(filterNode = (node) => true) {
    expandedIds(get(nodes).filter((node) => expandedIds().includes(node.id) && !filterNode(node)).map((node) => node.id));
  }
  function showNode(id) {
    for (const child2 of children()) {
      const nodes2 = findNodeById(child2, id);
      if (nodes2) {
        const ids = nodes2.map((node) => node.id);
        const nodeIds2 = new Set(ids);
        expandNodes((node) => nodeIds2.has(node.id));
        const lastId = ids[ids.length - 1];
        activeId(lastId);
        selectedIds([lastId]);
        tick().then(() => {
          var _a, _b;
          (_b = (_a = get(ref)) == null ? void 0 : _a.querySelector(`[id="${lastId}"]`)) == null ? void 0 : _b.focus();
        });
        break;
      }
    }
  }
  const dispatch = createEventDispatcher();
  const labelId = `label-${Math.random().toString(36)}`;
  const activeNodeId = writable(activeId());
  const selectedNodeIds = writable(selectedIds());
  const expandedNodeIds = writable(expandedIds());
  let ref = mutable_state(null);
  let treeWalker = mutable_state(null);
  setContext("TreeView", {
    activeNodeId,
    selectedNodeIds,
    expandedNodeIds,
    clickNode: (node) => {
      activeId(node.id);
      selectedIds([node.id]);
      dispatch("select", node);
    },
    selectNode: (node) => {
      selectedIds([node.id]);
    },
    expandNode: (node, expanded) => {
      if (expanded) {
        expandedIds([...expandedIds(), node.id]);
      } else {
        expandedIds(expandedIds().filter((_id) => strict_equals(_id, node.id, false)));
      }
    },
    focusNode: (node) => dispatch("focus", node),
    toggleNode: (node) => dispatch("toggle", node)
  });
  function handleKeyDown(e) {
    if (strict_equals(e.key, "ArrowUp") || strict_equals(e.key, "ArrowDown")) e.preventDefault();
    mutate(treeWalker, get(treeWalker).currentNode = e.target);
    let node = null;
    if (strict_equals(e.key, "ArrowUp")) node = get(treeWalker).previousNode();
    if (strict_equals(e.key, "ArrowDown")) node = get(treeWalker).nextNode();
    if (node && strict_equals(node, e.target, false)) {
      node.tabIndex = "0";
      node.focus();
    }
  }
  onMount(() => {
    const firstFocusableNode = get(ref).querySelector("li.bx--tree-node:not(.bx--tree-node--disabled)");
    if (equals(firstFocusableNode, null, false)) {
      firstFocusableNode.tabIndex = "0";
    }
  });
  function traverse(children2) {
    let nodes2 = [];
    children2.forEach((node) => {
      nodes2.push(node);
      if (Array.isArray(node.children)) {
        nodes2 = [...nodes2, ...traverse(node.children)];
      }
    });
    return nodes2;
  }
  legacy_pre_effect(() => deep_read_state(children()), () => {
    set(nodes, traverse(children()));
  });
  legacy_pre_effect(() => get(nodes), () => {
    set(nodeIds, get(nodes).map((node) => node.id));
  });
  legacy_pre_effect(() => deep_read_state(activeId()), () => {
    activeNodeId.set(activeId());
  });
  legacy_pre_effect(() => deep_read_state(selectedIds()), () => {
    selectedNodeIds.set(selectedIds());
  });
  legacy_pre_effect(() => deep_read_state(expandedIds()), () => {
    expandedNodeIds.set(expandedIds());
  });
  legacy_pre_effect(() => get(ref), () => {
    if (get(ref)) {
      set(treeWalker, document.createTreeWalker(get(ref), NodeFilter.SHOW_ELEMENT, {
        acceptNode: (node) => {
          if (node.classList.contains("bx--tree-node--disabled")) return NodeFilter.FILTER_REJECT;
          if (node.matches("li.bx--tree-node")) return NodeFilter.FILTER_ACCEPT;
          return NodeFilter.FILTER_SKIP;
        }
      }));
    }
  });
  legacy_pre_effect_reset();
  init();
  var fragment = root145();
  var node_1 = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var label = root_195();
      set_attribute(label, "id", labelId);
      toggle_class(label, "bx--label", true);
      var node_2 = child(label);
      slot(node_2, $$props, "labelText", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, labelText()));
        append($$anchor3, text2);
      });
      reset(label);
      append($$anchor2, label);
    };
    if_block(node_1, ($$render) => {
      if (!hideLabel()) $$render(consequent);
    });
  }
  var ul = sibling(node_1, 2);
  let attributes;
  var node_3 = child(ul);
  TreeViewNodeList_default(node_3, {
    root: true,
    get children() {
      return children();
    },
    $$slots: {
      default: ($$anchor2, $$slotProps) => {
        const node = derived_safe_equal(() => $$slotProps.node);
        var fragment_2 = comment();
        var node_4 = first_child(fragment_2);
        slot(
          node_4,
          $$props,
          "default",
          {
            get node() {
              return get(node);
            }
          },
          ($$anchor3) => {
            var text_1 = text();
            template_effect(() => set_text(text_1, get(node).text));
            append($$anchor3, text_1);
          }
        );
        append($$anchor2, fragment_2);
      }
    }
  });
  reset(ul);
  bind_this(ul, ($$value) => set(ref, $$value), () => get(ref));
  template_effect(() => {
    attributes = set_attributes(ul, attributes, {
      ...$$restProps,
      role: "tree",
      "aria-label": hideLabel() ? labelText() : void 0,
      "aria-labelledby": !hideLabel() ? labelId : void 0,
      "aria-multiselectable": selectedIds().length > 1 || void 0
    });
    toggle_class(ul, "bx--tree", true);
    toggle_class(ul, "bx--tree--default", strict_equals(size(), "default"));
    toggle_class(ul, "bx--tree--compact", strict_equals(size(), "compact"));
  });
  event2("keydown", ul, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", ul, stopPropagation(handleKeyDown));
  append($$anchor, fragment);
  bind_prop($$props, "expandAll", expandAll);
  bind_prop($$props, "collapseAll", collapseAll);
  bind_prop($$props, "expandNodes", expandNodes);
  bind_prop($$props, "collapseNodes", collapseNodes);
  bind_prop($$props, "showNode", showNode);
  return pop({
    get expandAll() {
      return expandAll;
    },
    get collapseAll() {
      return collapseAll;
    },
    get expandNodes() {
      return expandNodes;
    },
    get collapseNodes() {
      return collapseNodes;
    },
    get showNode() {
      return showNode;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  TreeView = hmr(TreeView, () => TreeView[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TreeView[HMR].source;
    set(TreeView[HMR].source, module.default[HMR].original);
  });
}
var TreeView_default = TreeView;
mark_module_end(TreeView);

// node_modules/carbon-components-svelte/src/Truncate/Truncate.svelte
mark_module_start();
Truncate[FILENAME] = "node_modules/carbon-components-svelte/src/Truncate/Truncate.svelte";
var root146 = add_locations(template(`<p><!></p>`), Truncate[FILENAME], [[6, 0]]);
function Truncate($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["clamp"]);
  push($$props, false, Truncate);
  let clamp = prop($$props, "clamp", 8, "end");
  var p = root146();
  let attributes;
  var node = child(p);
  slot(node, $$props, "default", {}, null);
  reset(p);
  template_effect(() => {
    attributes = set_attributes(p, attributes, { ...$$restProps });
    toggle_class(p, "bx--text-truncate--end", strict_equals(clamp(), "end"));
    toggle_class(p, "bx--text-truncate--front", strict_equals(clamp(), "front"));
  });
  append($$anchor, p);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Truncate = hmr(Truncate, () => Truncate[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Truncate[HMR].source;
    set(Truncate[HMR].source, module.default[HMR].original);
  });
}
var Truncate_default = Truncate;
mark_module_end(Truncate);

// node_modules/carbon-components-svelte/src/Truncate/truncate.js
function truncate(node, options = {}) {
  const prefix = "bx--text-truncate--";
  function toggleClass(front = false) {
    const classes = [...node.classList].filter((name) => !name.startsWith(prefix)).join(" ");
    node.className = `${classes} ${prefix}${front ? "front" : "end"}`;
  }
  toggleClass(options.clamp === "front");
  return {
    update(options2) {
      toggleClass(options2.clamp === "front");
    }
  };
}
var truncate_default = truncate;

// node_modules/carbon-components-svelte/src/icons/Menu.svelte
mark_module_start();
Menu[FILENAME] = "node_modules/carbon-components-svelte/src/icons/Menu.svelte";
var root_196 = add_locations(ns_template(`<title> </title>`), Menu[FILENAME], [[24, 13]]);
var root147 = add_locations(ns_template(`<svg><!><path d="M4 6H28V8H4zM4 24H28V26H4zM4 12H28V14H4zM4 18H28V20H4z"></path></svg>`), Menu[FILENAME], [[14, 0, [[25, 2]]]]);
function Menu($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, Menu);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root147();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_196();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next();
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu = hmr(Menu, () => Menu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu[HMR].source;
    set(Menu[HMR].source, module.default[HMR].original);
  });
}
var Menu_default = Menu;
mark_module_end(Menu);

// node_modules/carbon-components-svelte/src/UIShell/navStore.js
var shouldRenderHamburgerMenu = writable(false);
var isSideNavCollapsed = writable(false);
var isSideNavRail = writable(false);

// node_modules/carbon-components-svelte/src/UIShell/HamburgerMenu.svelte
mark_module_start();
HamburgerMenu[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/HamburgerMenu.svelte";
var root148 = add_locations(template(`<button><!></button>`), HamburgerMenu[FILENAME], [[32, 0]]);
function HamburgerMenu($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "ariaLabel",
    "isOpen",
    "iconMenu",
    "iconClose",
    "ref"
  ]);
  push($$props, false, HamburgerMenu);
  let ariaLabel = prop($$props, "ariaLabel", 8, void 0);
  let isOpen = prop($$props, "isOpen", 12, false);
  let iconMenu = prop($$props, "iconMenu", 8, Menu_default);
  let iconClose = prop($$props, "iconClose", 8, Close_default);
  let ref = prop($$props, "ref", 12, null);
  var button = root148();
  let attributes;
  var node = child(button);
  component(node, () => isOpen() ? iconClose() : iconMenu(), ($$anchor2, $$component) => {
    $$component($$anchor2, { size: 20 });
  });
  reset(button);
  bind_this(button, ($$value) => ref($$value), () => ref());
  template_effect(() => {
    attributes = set_attributes(button, attributes, {
      type: "button",
      title: ariaLabel(),
      "aria-label": ariaLabel(),
      ...$$restProps
    });
    toggle_class(button, "bx--header__action", true);
    toggle_class(button, "bx--header__menu-trigger", true);
    toggle_class(button, "bx--header__menu-toggle", true);
  });
  event2("click", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", button, () => isOpen(!isOpen()));
  append($$anchor, button);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HamburgerMenu = hmr(HamburgerMenu, () => HamburgerMenu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HamburgerMenu[HMR].source;
    set(HamburgerMenu[HMR].source, module.default[HMR].original);
  });
}
var HamburgerMenu_default = HamburgerMenu;
mark_module_end(HamburgerMenu);

// node_modules/carbon-components-svelte/src/UIShell/Header.svelte
mark_module_start();
Header[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/Header.svelte";
var root_230 = add_locations(template(`<span><!></span>`), Header[FILENAME], [[100, 6]]);
var root149 = add_locations(template(`<header><!> <!> <a><!> <!></a> <!></header>`), Header[FILENAME], [[83, 0, [[92, 2]]]]);
function Header($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "expandedByDefault",
    "isSideNavOpen",
    "uiShellAriaLabel",
    "href",
    "company",
    "platformName",
    "persistentHamburgerMenu",
    "expansionBreakpoint",
    "ref",
    "iconMenu",
    "iconClose"
  ]);
  push($$props, false, Header);
  const [$$stores, $$cleanup] = setup_stores();
  const $shouldRenderHamburgerMenu = () => (validate_store(shouldRenderHamburgerMenu, "shouldRenderHamburgerMenu"), store_get(shouldRenderHamburgerMenu, "$shouldRenderHamburgerMenu", $$stores));
  const ariaLabel = mutable_state();
  let expandedByDefault = prop($$props, "expandedByDefault", 8, true);
  let isSideNavOpen = prop($$props, "isSideNavOpen", 12, false);
  let uiShellAriaLabel = prop($$props, "uiShellAriaLabel", 8, void 0);
  let href = prop($$props, "href", 8, void 0);
  let company = prop($$props, "company", 8, void 0);
  let platformName = prop($$props, "platformName", 8, "");
  let persistentHamburgerMenu = prop($$props, "persistentHamburgerMenu", 8, false);
  let expansionBreakpoint = prop($$props, "expansionBreakpoint", 8, 1056);
  let ref = prop($$props, "ref", 12, null);
  let iconMenu = prop($$props, "iconMenu", 8, Menu_default);
  let iconClose = prop($$props, "iconClose", 8, Close_default);
  let winWidth = mutable_state(void 0);
  legacy_pre_effect(
    () => (deep_read_state(expandedByDefault()), get(winWidth), deep_read_state(expansionBreakpoint()), deep_read_state(persistentHamburgerMenu())),
    () => {
      isSideNavOpen(expandedByDefault() && get(winWidth) >= expansionBreakpoint() && !persistentHamburgerMenu());
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(company()), deep_read_state(uiShellAriaLabel()), deep_read_state($$sanitized_props), deep_read_state(platformName())),
    () => {
      set(ariaLabel, company() ? `${company()} ` : "" + (uiShellAriaLabel() || $$sanitized_props["aria-label"] || platformName()));
    }
  );
  legacy_pre_effect_reset();
  init();
  var header = root149();
  var node = child(header);
  slot(node, $$props, "skip-to-content", {}, null);
  var node_1 = sibling(node, 2);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_2 = first_child(fragment);
      {
        add_owner_effect(isSideNavOpen, HamburgerMenu_default);
        HamburgerMenu_default(node_2, {
          get iconClose() {
            return iconClose();
          },
          get iconMenu() {
            return iconMenu();
          },
          get isOpen() {
            return isSideNavOpen();
          },
          set isOpen($$value) {
            isSideNavOpen($$value);
          },
          $$legacy: true
        });
      }
      append($$anchor2, fragment);
    };
    if_block(node_1, ($$render) => {
      if ($shouldRenderHamburgerMenu() && get(winWidth) < expansionBreakpoint() || persistentHamburgerMenu()) $$render(consequent);
    });
  }
  var a = sibling(node_1, 2);
  let attributes;
  var node_3 = child(a);
  {
    var consequent_1 = ($$anchor2) => {
      var span = root_230();
      toggle_class(span, "bx--header__name--prefix", true);
      var node_4 = child(span);
      slot(node_4, $$props, "company", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, `${company() ?? ""}`));
        append($$anchor3, text2);
      });
      reset(span);
      append($$anchor2, span);
    };
    if_block(node_3, ($$render) => {
      if (company() || $$slots.company) $$render(consequent_1);
    });
  }
  var node_5 = sibling(node_3, 2);
  slot(node_5, $$props, "platform", {}, ($$anchor2) => {
    var text_1 = text();
    template_effect(() => set_text(text_1, platformName()));
    append($$anchor2, text_1);
  });
  reset(a);
  bind_this(a, ($$value) => ref($$value), () => ref());
  var node_6 = sibling(a, 2);
  slot(node_6, $$props, "default", {}, null);
  reset(header);
  template_effect(() => {
    set_attribute(header, "aria-label", get(ariaLabel));
    toggle_class(header, "bx--header", true);
    attributes = set_attributes(a, attributes, { href: href(), ...$$restProps });
    toggle_class(a, "bx--header__name", true);
  });
  bind_window_size("innerWidth", ($$value) => set(winWidth, $$value));
  event2("click", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, header);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Header = hmr(Header, () => Header[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Header[HMR].source;
    set(Header[HMR].source, module.default[HMR].original);
  });
}
var Header_default = Header;
mark_module_end(Header);

// node_modules/carbon-components-svelte/src/icons/Switcher.svelte
mark_module_start();
Switcher[FILENAME] = "node_modules/carbon-components-svelte/src/icons/Switcher.svelte";
var root_197 = add_locations(ns_template(`<title> </title>`), Switcher[FILENAME], [[24, 13]]);
var root150 = add_locations(ns_template(`<svg><!><path d="M14 4H18V8H14zM4 4H8V8H4zM24 4H28V8H24zM14 14H18V18H14zM4 14H8V18H4zM24 14H28V18H24zM14 24H18V28H14zM4 24H8V28H4zM24 24H28V28H24z"></path></svg>`), Switcher[FILENAME], [[14, 0, [[25, 2]]]]);
function Switcher($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "title"]);
  push($$props, false, Switcher);
  const labelled = mutable_state();
  const attributes = mutable_state();
  let size = prop($$props, "size", 8, 16);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state($$sanitized_props), deep_read_state(title())),
    () => {
      set(labelled, $$sanitized_props["aria-label"] || $$sanitized_props["aria-labelledby"] || title());
    }
  );
  legacy_pre_effect(
    () => (get(labelled), deep_read_state($$sanitized_props)),
    () => {
      set(attributes, {
        "aria-hidden": get(labelled) ? void 0 : true,
        role: get(labelled) ? "img" : void 0,
        focusable: strict_equals(Number($$sanitized_props["tabindex"]), 0) ? true : void 0
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var svg = root150();
  let attributes_1;
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_197();
      var text2 = child(title_1, true);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor2, title_1);
    };
    if_block(node, ($$render) => {
      if (title()) $$render(consequent);
    });
  }
  next();
  reset(svg);
  template_effect(() => attributes_1 = set_attributes(
    svg,
    attributes_1,
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      preserveAspectRatio: "xMidYMid meet",
      width: size(),
      height: size(),
      ...get(attributes),
      ...$$restProps
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Switcher = hmr(Switcher, () => Switcher[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Switcher[HMR].source;
    set(Switcher[HMR].source, module.default[HMR].original);
  });
}
var Switcher_default = Switcher;
mark_module_end(Switcher);

// node_modules/carbon-components-svelte/src/UIShell/HeaderAction.svelte
mark_module_start();
HeaderAction[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/HeaderAction.svelte";
var root_614 = add_locations(template(`<span> </span>`), HeaderAction[FILENAME], [[91, 14]]);
var root_711 = add_locations(template(`<div><!></div>`), HeaderAction[FILENAME], [[95, 2]]);
var root151 = add_locations(template(`<button><!> <!></button> <!>`, 1), HeaderAction[FILENAME], [[68, 0]]);
var $$css = {
  hash: "s-vvyJ3qRS6z3W",
  code: "\n  .bx--header__action--text {\n    display: inline-flex;\n    align-items: center;\n    width: auto;\n\n    /** 2px bottom padding aligns icon with `HeaderAction` */\n    padding: 0 1rem 2px 1rem;\n\n    /** `body-short-01` styles */\n    font-size: 0.875rem;\n    line-height: 1.28572;\n    letter-spacing: 0.16px;\n\n    /** Same color as `Header` platformName */\n    color: #f4f4f4;\n  }\n\n  .bx--header__action-text {\n    margin-left: 0.75rem;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGVhZGVyQWN0aW9uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJIZWFkZXJBY3Rpb24uc3ZlbHRlIl19 */"
};
function HeaderAction($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "isOpen",
    "icon",
    "closeIcon",
    "text",
    "ref",
    "transition",
    "preventCloseOnClickOutside"
  ]);
  push($$props, false, HeaderAction);
  append_styles($$anchor, $$css);
  let isOpen = prop($$props, "isOpen", 12, false);
  let icon = prop($$props, "icon", 8, Switcher_default);
  let closeIcon = prop($$props, "closeIcon", 8, Close_default);
  let text2 = prop($$props, "text", 8, void 0);
  let ref = prop($$props, "ref", 12, null);
  let transition2 = prop($$props, "transition", 24, () => ({ duration: 200 }));
  let preventCloseOnClickOutside = prop($$props, "preventCloseOnClickOutside", 8, false);
  const dispatch = createEventDispatcher();
  let refPanel = mutable_state(null);
  init();
  var fragment = root151();
  event2("click", $window, ({ target }) => {
    if (isOpen() && !ref().contains(target) && !get(refPanel).contains(target) && !preventCloseOnClickOutside()) {
      isOpen(false);
      dispatch("close");
    }
  });
  var button = first_child(fragment);
  let attributes;
  var node = child(button);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, $$props, "closeIcon", {}, ($$anchor3) => {
        var fragment_2 = comment();
        var node_2 = first_child(fragment_2);
        component(node_2, closeIcon, ($$anchor4, $$component) => {
          $$component($$anchor4, { size: 20 });
        });
        append($$anchor3, fragment_2);
      });
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_3 = comment();
      var node_3 = first_child(fragment_3);
      slot(node_3, $$props, "icon", {}, ($$anchor3) => {
        var fragment_4 = comment();
        var node_4 = first_child(fragment_4);
        component(node_4, icon, ($$anchor4, $$component) => {
          $$component($$anchor4, { size: 20 });
        });
        append($$anchor3, fragment_4);
      });
      append($$anchor2, fragment_3);
    };
    if_block(node, ($$render) => {
      if (isOpen()) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_5 = sibling(node, 2);
  slot(node_5, $$props, "text", {}, ($$anchor2) => {
    var fragment_5 = comment();
    var node_6 = first_child(fragment_5);
    {
      var consequent_1 = ($$anchor3) => {
        var span = root_614();
        toggle_class(span, "bx--header__action-text", true);
        var text_1 = child(span, true);
        reset(span);
        template_effect(() => set_text(text_1, text2()));
        append($$anchor3, span);
      };
      if_block(node_6, ($$render) => {
        if (text2()) $$render(consequent_1);
      });
    }
    append($$anchor2, fragment_5);
  });
  reset(button);
  bind_this(button, ($$value) => ref($$value), () => ref());
  var node_7 = sibling(button, 2);
  {
    var consequent_2 = ($$anchor2) => {
      var div = root_711();
      toggle_class(div, "bx--header-panel", true);
      toggle_class(div, "bx--header-panel--expanded", true);
      set_style(div, "overflow-y", "auto");
      var node_8 = child(div);
      slot(node_8, $$props, "default", {}, null);
      reset(div);
      bind_this(div, ($$value) => set(refPanel, $$value), () => get(refPanel));
      transition(3, div, () => slide, () => ({
        ...transition2(),
        duration: strict_equals(transition2(), false) ? 0 : transition2().duration
      }));
      append($$anchor2, div);
    };
    if_block(node_7, ($$render) => {
      if (isOpen()) $$render(consequent_2);
    });
  }
  template_effect(() => {
    attributes = set_attributes(button, attributes, { type: "button", ...$$restProps }, "s-vvyJ3qRS6z3W");
    toggle_class(button, "bx--header__action", true);
    toggle_class(button, "bx--header__action--active", isOpen());
    toggle_class(button, "bx--header__action--text", text2());
  });
  event2("click", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", button, stopPropagation(() => {
    isOpen(!isOpen());
    dispatch(isOpen() ? "open" : "close");
  }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HeaderAction = hmr(HeaderAction, () => HeaderAction[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-vvyJ3qRS6z3W");
    module.default[HMR].source = HeaderAction[HMR].source;
    set(HeaderAction[HMR].source, module.default[HMR].original);
  });
}
var HeaderAction_default = HeaderAction;
mark_module_end(HeaderAction);

// node_modules/carbon-components-svelte/src/UIShell/HeaderActionLink.svelte
mark_module_start();
HeaderActionLink[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/HeaderActionLink.svelte";
var root152 = add_locations(template(`<a><!></a>`), HeaderActionLink[FILENAME], [[21, 0]]);
var $$css2 = {
  hash: "s-kHAlhVCYsuEC",
  code: "\n  .bx--header__action {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    /** Hot fix to align icon with `HeaderAction` */\n    padding-bottom: 2px;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGVhZGVyQWN0aW9uTGluay5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiSGVhZGVyQWN0aW9uTGluay5zdmVsdGUiXX0= */"
};
function HeaderActionLink($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["linkIsActive", "href", "icon", "ref"]);
  push($$props, false, HeaderActionLink);
  append_styles($$anchor, $$css2);
  let linkIsActive = prop($$props, "linkIsActive", 8, false);
  let href = prop($$props, "href", 8, void 0);
  let icon = prop($$props, "icon", 8, void 0);
  let ref = prop($$props, "ref", 12, null);
  init();
  var a = root152();
  let attributes;
  var node = child(a);
  slot(node, $$props, "icon", {}, ($$anchor2) => {
    var fragment = comment();
    var node_1 = first_child(fragment);
    component(node_1, icon, ($$anchor3, $$component) => {
      $$component($$anchor3, { size: 20 });
    });
    append($$anchor2, fragment);
  });
  reset(a);
  bind_this(a, ($$value) => ref($$value), () => ref());
  template_effect(() => {
    attributes = set_attributes(
      a,
      attributes,
      {
        href: href(),
        rel: strict_equals($$restProps.target, "_blank") ? "noopener noreferrer" : void 0,
        ...$$restProps
      },
      "s-kHAlhVCYsuEC"
    );
    toggle_class(a, "bx--header__action", true);
    toggle_class(a, "bx--header__action--active", linkIsActive());
  });
  event2("click", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, a);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HeaderActionLink = hmr(HeaderActionLink, () => HeaderActionLink[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-kHAlhVCYsuEC");
    module.default[HMR].source = HeaderActionLink[HMR].source;
    set(HeaderActionLink[HMR].source, module.default[HMR].original);
  });
}
var HeaderActionLink_default = HeaderActionLink;
mark_module_end(HeaderActionLink);

// node_modules/carbon-components-svelte/src/UIShell/HeaderNav.svelte
mark_module_start();
HeaderNav[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/HeaderNav.svelte";
var root153 = add_locations(template(`<nav><ul><!></ul></nav>`), HeaderNav[FILENAME], [[8, 0, [[10, 2]]]]);
function HeaderNav($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, HeaderNav);
  const props = mutable_state();
  legacy_pre_effect(() => deep_read_state($$sanitized_props), () => {
    set(props, {
      "aria-label": $$sanitized_props["aria-label"],
      "aria-labelledby": $$sanitized_props["aria-labelledby"]
    });
  });
  legacy_pre_effect_reset();
  init();
  var nav = root153();
  let attributes;
  var ul = child(nav);
  let attributes_1;
  var node = child(ul);
  slot(node, $$props, "default", {}, null);
  reset(ul);
  reset(nav);
  template_effect(() => {
    attributes = set_attributes(nav, attributes, { ...get(props), ...$$restProps });
    toggle_class(nav, "bx--header__nav", true);
    attributes_1 = set_attributes(ul, attributes_1, { ...get(props), role: "menubar" });
    toggle_class(ul, "bx--header__menu-bar", true);
  });
  append($$anchor, nav);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HeaderNav = hmr(HeaderNav, () => HeaderNav[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HeaderNav[HMR].source;
    set(HeaderNav[HMR].source, module.default[HMR].original);
  });
}
var HeaderNav_default = HeaderNav;
mark_module_end(HeaderNav);

// node_modules/carbon-components-svelte/src/UIShell/HeaderNavItem.svelte
mark_module_start();
HeaderNavItem[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/HeaderNavItem.svelte";
var root154 = add_locations(template(`<li role="none"><a><span><!></span></a></li>`), HeaderNavItem[FILENAME], [
  [40, 0, [[41, 2, [[64, 4]]]]]
]);
function HeaderNavItem($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["href", "text", "isSelected", "ref"]);
  push($$props, false, HeaderNavItem);
  let href = prop($$props, "href", 8, void 0);
  let text2 = prop($$props, "text", 8, void 0);
  let isSelected = prop($$props, "isSelected", 8, false);
  let ref = prop($$props, "ref", 12, null);
  const id = "ccs-" + Math.random().toString(36);
  const ctx = getContext("HeaderNavMenu");
  let selectedItemIds = mutable_state([]);
  const unsubSelectedItems = ctx == null ? void 0 : ctx.selectedItems.subscribe((_selectedItems) => {
    set(selectedItemIds, Object.keys(_selectedItems));
  });
  onMount(() => {
    return () => {
      if (unsubSelectedItems) unsubSelectedItems();
    };
  });
  legacy_pre_effect(() => deep_read_state(isSelected()), () => {
    ctx == null ? void 0 : ctx.updateSelectedItems({ id, isSelected: isSelected() });
  });
  legacy_pre_effect_reset();
  init();
  var li = root154();
  var a = child(li);
  let attributes;
  var span = child(a);
  toggle_class(span, "bx--text-truncate--end", true);
  var node = child(span);
  slot(node, $$props, "default", {}, ($$anchor2) => {
    var text_1 = text();
    template_effect(() => set_text(text_1, text2()));
    append($$anchor2, text_1);
  });
  reset(span);
  reset(a);
  bind_this(a, ($$value) => ref($$value), () => ref());
  reset(li);
  template_effect(() => {
    attributes = set_attributes(a, attributes, {
      role: "menuitem",
      tabindex: "0",
      href: href(),
      rel: strict_equals($$restProps.target, "_blank") ? "noopener noreferrer" : void 0,
      "aria-current": isSelected() ? "page" : void 0,
      ...$$restProps
    });
    toggle_class(a, "bx--header__menu-item", true);
  });
  event2("click", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseover", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keyup", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("focus", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("blur", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("blur", a, () => {
    if (strict_equals(get(selectedItemIds).indexOf(id), get(selectedItemIds).length - 1)) {
      ctx == null ? void 0 : ctx.closeMenu();
    }
  });
  append($$anchor, li);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HeaderNavItem = hmr(HeaderNavItem, () => HeaderNavItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HeaderNavItem[HMR].source;
    set(HeaderNavItem[HMR].source, module.default[HMR].original);
  });
}
var HeaderNavItem_default = HeaderNavItem;
mark_module_end(HeaderNavItem);

// node_modules/carbon-components-svelte/src/UIShell/HeaderNavMenu.svelte
mark_module_start();
HeaderNavMenu[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/HeaderNavMenu.svelte";
var root155 = add_locations(template(`<li role="none"><a> <!></a> <ul role="menu"><!></ul></li>`), HeaderNavMenu[FILENAME], [[50, 0, [[67, 2], [98, 2]]]]);
function HeaderNavMenu($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["expanded", "href", "text", "ref"]);
  push($$props, false, HeaderNavMenu);
  const [$$stores, $$cleanup] = setup_stores();
  const $selectedItems = () => (validate_store(selectedItems, "selectedItems"), store_get(selectedItems, "$selectedItems", $$stores));
  const isCurrentSubmenu = mutable_state();
  let expanded = prop($$props, "expanded", 12, false);
  let href = prop($$props, "href", 8, "/");
  let text2 = prop($$props, "text", 8, void 0);
  let ref = prop($$props, "ref", 12, null);
  const selectedItems = writable({});
  let menuRef = mutable_state(null);
  setContext("HeaderNavMenu", {
    selectedItems,
    updateSelectedItems(item) {
      selectedItems.update((_items) => ({ ..._items, [item.id]: item.isSelected }));
    },
    closeMenu() {
      expanded(false);
    }
  });
  legacy_pre_effect(() => $selectedItems(), () => {
    set(isCurrentSubmenu, Object.values($selectedItems()).filter(Boolean).length > 0);
  });
  legacy_pre_effect_reset();
  init();
  var li = root155();
  event2("click", $window, ({ target }) => {
    if (!ref().contains(target)) {
      expanded(false);
    }
  });
  toggle_class(li, "bx--header__submenu", true);
  var a = child(li);
  let attributes;
  var text_1 = child(a);
  var node = sibling(text_1);
  ChevronDown_default(node, { class: "bx--header__menu-arrow" });
  reset(a);
  bind_this(a, ($$value) => ref($$value), () => ref());
  var ul = sibling(a, 2);
  var node_1 = child(ul);
  slot(node_1, $$props, "default", {}, null);
  reset(ul);
  bind_this(ul, ($$value) => set(menuRef, $$value), () => get(menuRef));
  reset(li);
  template_effect(() => {
    toggle_class(li, "bx--header__submenu--current", get(isCurrentSubmenu));
    attributes = set_attributes(a, attributes, {
      role: "menuitem",
      tabindex: "0",
      "aria-haspopup": "menu",
      "aria-expanded": expanded(),
      "aria-label": text2(),
      href: href(),
      ...$$restProps
    });
    toggle_class(a, "bx--header__menu-item", true);
    toggle_class(a, "bx--header__menu-title", true);
    set_style(a, "z-index", 1);
    set_text(text_1, `${text2() ?? ""} `);
    set_attribute(ul, "aria-label", text2());
    toggle_class(ul, "bx--header__menu", true);
  });
  event2("keydown", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", a, (e) => {
    if (strict_equals(e.key, " ")) e.preventDefault();
    if (strict_equals(e.key, "Enter") || strict_equals(e.key, " ")) {
      expanded(!expanded());
    }
  });
  event2("click", a, preventDefault(function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  }));
  event2("mouseover", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseenter", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("mouseleave", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keyup", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("focus", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("blur", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", li, (e) => {
    if (!get(menuRef).contains(e.target)) {
      e.preventDefault();
    }
    expanded(!expanded());
  });
  event2("keydown", li, (e) => {
    if (strict_equals(e.key, "Enter")) {
      e.stopPropagation();
      expanded(!expanded());
    }
  });
  append($$anchor, li);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  HeaderNavMenu = hmr(HeaderNavMenu, () => HeaderNavMenu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HeaderNavMenu[HMR].source;
    set(HeaderNavMenu[HMR].source, module.default[HMR].original);
  });
}
var HeaderNavMenu_default = HeaderNavMenu;
mark_module_end(HeaderNavMenu);

// node_modules/carbon-components-svelte/src/UIShell/HeaderPanelDivider.svelte
mark_module_start();
HeaderPanelDivider[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/HeaderPanelDivider.svelte";
var root_198 = add_locations(template(`<li><!></li>`), HeaderPanelDivider[FILENAME], [[2, 2]]);
var root156 = add_locations(template(`<!> <hr>`, 1), HeaderPanelDivider[FILENAME], [[6, 0]]);
var $$css3 = {
  hash: "s-Yx0wYeQxWXeW",
  code: "\n  /**\n    * Carbon does not support a divider with a subject.\n    * We apply custom styles using the switcher subject divider\n    * from https://carbondesignsystem.com/ as a reference.\n    */\n\n  .bx--header-panel-divider {\n    margin: 2rem 1rem 0;\n    font-size: 0.75rem;\n    line-height: 1.3;\n    letter-spacing: 0.02rem;\n    color: #c6c6c6;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGVhZGVyUGFuZWxEaXZpZGVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJIZWFkZXJQYW5lbERpdmlkZXIuc3ZlbHRlIl19 */"
};
function HeaderPanelDivider($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  push($$props, false, HeaderPanelDivider);
  append_styles($$anchor, $$css3);
  var fragment = root156();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var li = root_198();
      toggle_class(li, "bx--header-panel-divider", true);
      var node_1 = child(li);
      slot(node_1, $$props, "default", {}, null);
      reset(li);
      append($$anchor2, li);
    };
    if_block(node, ($$render) => {
      if ($$slots.default) $$render(consequent);
    });
  }
  var hr = sibling(node, 2);
  toggle_class(hr, "bx--switcher__item--divider", true);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HeaderPanelDivider = hmr(HeaderPanelDivider, () => HeaderPanelDivider[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-Yx0wYeQxWXeW");
    module.default[HMR].source = HeaderPanelDivider[HMR].source;
    set(HeaderPanelDivider[HMR].source, module.default[HMR].original);
  });
}
var HeaderPanelDivider_default = HeaderPanelDivider;
mark_module_end(HeaderPanelDivider);

// node_modules/carbon-components-svelte/src/UIShell/HeaderPanelLink.svelte
mark_module_start();
HeaderPanelLink[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/HeaderPanelLink.svelte";
var root157 = add_locations(template(`<li><a><!></a></li>`), HeaderPanelLink[FILENAME], [[12, 0, [[13, 2]]]]);
function HeaderPanelLink($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["href", "ref"]);
  push($$props, false, HeaderPanelLink);
  let href = prop($$props, "href", 8, void 0);
  let ref = prop($$props, "ref", 12, null);
  init();
  var li = root157();
  toggle_class(li, "bx--switcher__item", true);
  var a = child(li);
  let attributes;
  var node = child(a);
  slot(node, $$props, "default", {}, null);
  reset(a);
  bind_this(a, ($$value) => ref($$value), () => ref());
  reset(li);
  template_effect(() => {
    attributes = set_attributes(a, attributes, {
      href: href(),
      rel: strict_equals($$restProps.target, "_blank") ? "noopener noreferrer" : void 0,
      ...$$restProps
    });
    toggle_class(a, "bx--switcher__item-link", true);
  });
  event2("click", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, li);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HeaderPanelLink = hmr(HeaderPanelLink, () => HeaderPanelLink[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HeaderPanelLink[HMR].source;
    set(HeaderPanelLink[HMR].source, module.default[HMR].original);
  });
}
var HeaderPanelLink_default = HeaderPanelLink;
mark_module_end(HeaderPanelLink);

// node_modules/carbon-components-svelte/src/UIShell/HeaderPanelLinks.svelte
mark_module_start();
HeaderPanelLinks[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/HeaderPanelLinks.svelte";
var root158 = add_locations(template(`<ul><!></ul>`), HeaderPanelLinks[FILENAME], [[1, 0]]);
function HeaderPanelLinks($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, HeaderPanelLinks);
  var ul = root158();
  toggle_class(ul, "bx--switcher__item", true);
  var node = child(ul);
  slot(node, $$props, "default", {}, null);
  reset(ul);
  append($$anchor, ul);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HeaderPanelLinks = hmr(HeaderPanelLinks, () => HeaderPanelLinks[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HeaderPanelLinks[HMR].source;
    set(HeaderPanelLinks[HMR].source, module.default[HMR].original);
  });
}
var HeaderPanelLinks_default = HeaderPanelLinks;
mark_module_end(HeaderPanelLinks);

// node_modules/carbon-components-svelte/src/UIShell/HeaderUtilities.svelte
mark_module_start();
HeaderUtilities[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/HeaderUtilities.svelte";
var root159 = add_locations(template(`<div><!></div>`), HeaderUtilities[FILENAME], [[1, 0]]);
function HeaderUtilities($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, HeaderUtilities);
  var div = root159();
  toggle_class(div, "bx--header__global", true);
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HeaderUtilities = hmr(HeaderUtilities, () => HeaderUtilities[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HeaderUtilities[HMR].source;
    set(HeaderUtilities[HMR].source, module.default[HMR].original);
  });
}
var HeaderUtilities_default = HeaderUtilities;
mark_module_end(HeaderUtilities);

// node_modules/carbon-components-svelte/src/UIShell/SideNav.svelte
mark_module_start();
SideNav[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/SideNav.svelte";
var root_199 = add_locations(template(`<div></div>`), SideNav[FILENAME], [[60, 2]]);
var root160 = add_locations(template(`<!> <nav><!></nav>`, 1), SideNav[FILENAME], [[70, 0]]);
function SideNav($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "fixed",
    "rail",
    "ariaLabel",
    "isOpen",
    "expansionBreakpoint"
  ]);
  push($$props, false, SideNav);
  const [$$stores, $$cleanup] = setup_stores();
  const $isSideNavCollapsed = () => (validate_store(isSideNavCollapsed, "isSideNavCollapsed"), store_get(isSideNavCollapsed, "$isSideNavCollapsed", $$stores));
  const $isSideNavRail = () => (validate_store(isSideNavRail, "isSideNavRail"), store_get(isSideNavRail, "$isSideNavRail", $$stores));
  let fixed = prop($$props, "fixed", 8, false);
  let rail = prop($$props, "rail", 8, false);
  let ariaLabel = prop($$props, "ariaLabel", 8, void 0);
  let isOpen = prop($$props, "isOpen", 12, false);
  let expansionBreakpoint = prop($$props, "expansionBreakpoint", 8, 1056);
  const dispatch = createEventDispatcher();
  let winWidth = mutable_state(void 0);
  onMount(() => {
    shouldRenderHamburgerMenu.set(true);
    return () => shouldRenderHamburgerMenu.set(false);
  });
  legacy_pre_effect(() => deep_read_state(isOpen()), () => {
    dispatch(isOpen() ? "open" : "close");
  });
  legacy_pre_effect(() => deep_read_state(isOpen()), () => {
    store_set(isSideNavCollapsed, !isOpen());
  });
  legacy_pre_effect(() => deep_read_state(rail()), () => {
    store_set(isSideNavRail, rail());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = root160();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_199();
      toggle_class(div, "bx--side-nav__overlay", true);
      template_effect(() => {
        toggle_class(div, "bx--side-nav__overlay-active", isOpen());
        set_style(div, "z-index", isOpen() ? 6e3 : void 0);
      });
      event2("click", div, () => {
        dispatch("click:overlay");
        isOpen(false);
      });
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if (!fixed()) $$render(consequent);
    });
  }
  var nav = sibling(node, 2);
  let attributes;
  var node_1 = child(nav);
  slot(node_1, $$props, "default", {}, null);
  reset(nav);
  template_effect(() => {
    attributes = set_attributes(nav, attributes, {
      "aria-hidden": !isOpen(),
      "aria-label": ariaLabel(),
      ...$$restProps
    });
    toggle_class(nav, "bx--side-nav__navigation", true);
    toggle_class(nav, "bx--side-nav", true);
    toggle_class(nav, "bx--side-nav--ux", true);
    toggle_class(nav, "bx--side-nav--expanded", rail() && get(winWidth) >= expansionBreakpoint() ? false : isOpen());
    toggle_class(nav, "bx--side-nav--collapsed", !isOpen() && !rail());
    toggle_class(nav, "bx--side-nav--rail", rail());
  });
  bind_window_size("innerWidth", ($$value) => set(winWidth, $$value));
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  SideNav = hmr(SideNav, () => SideNav[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SideNav[HMR].source;
    set(SideNav[HMR].source, module.default[HMR].original);
  });
}
var SideNav_default = SideNav;
mark_module_end(SideNav);

// node_modules/carbon-components-svelte/src/UIShell/SideNavItems.svelte
mark_module_start();
SideNavItems[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/SideNavItems.svelte";
var root161 = add_locations(template(`<ul><!></ul>`), SideNavItems[FILENAME], [[1, 0]]);
function SideNavItems($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, SideNavItems);
  var ul = root161();
  toggle_class(ul, "bx--side-nav__items", true);
  var node = child(ul);
  slot(node, $$props, "default", {}, null);
  reset(ul);
  append($$anchor, ul);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SideNavItems = hmr(SideNavItems, () => SideNavItems[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SideNavItems[HMR].source;
    set(SideNavItems[HMR].source, module.default[HMR].original);
  });
}
var SideNavItems_default = SideNavItems;
mark_module_end(SideNavItems);

// node_modules/carbon-components-svelte/src/UIShell/SideNavLink.svelte
mark_module_start();
SideNavLink[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/SideNavLink.svelte";
var root_1100 = add_locations(template(`<div><!></div>`), SideNavLink[FILENAME], [[39, 6]]);
var root162 = add_locations(template(`<li><a><!> <span><!></span></a></li>`), SideNavLink[FILENAME], [
  [27, 0, [[28, 2, [[48, 4]]]]]
]);
function SideNavLink($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "isSelected",
    "href",
    "text",
    "icon",
    "ref"
  ]);
  push($$props, false, SideNavLink);
  let isSelected = prop($$props, "isSelected", 8, false);
  let href = prop($$props, "href", 8, void 0);
  let text2 = prop($$props, "text", 8, void 0);
  let icon = prop($$props, "icon", 8, void 0);
  let ref = prop($$props, "ref", 12, null);
  init();
  var li = root162();
  toggle_class(li, "bx--side-nav__item", true);
  var a = child(li);
  let attributes;
  var node = child(a);
  {
    var consequent = ($$anchor2) => {
      var div = root_1100();
      toggle_class(div, "bx--side-nav__icon", true);
      toggle_class(div, "bx--side-nav__icon--small", true);
      var node_1 = child(div);
      slot(node_1, $$props, "icon", {}, ($$anchor3) => {
        var fragment = comment();
        var node_2 = first_child(fragment);
        component(node_2, icon, ($$anchor4, $$component) => {
          $$component($$anchor4, {});
        });
        append($$anchor3, fragment);
      });
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$slots.icon || icon()) $$render(consequent);
    });
  }
  var span = sibling(node, 2);
  toggle_class(span, "bx--side-nav__link-text", true);
  var node_3 = child(span);
  slot(node_3, $$props, "default", {}, ($$anchor2) => {
    var text_1 = text();
    template_effect(() => set_text(text_1, text2()));
    append($$anchor2, text_1);
  });
  reset(span);
  reset(a);
  bind_this(a, ($$value) => ref($$value), () => ref());
  reset(li);
  template_effect(() => {
    attributes = set_attributes(a, attributes, {
      "aria-current": isSelected() ? "page" : void 0,
      href: href(),
      rel: strict_equals($$restProps.target, "_blank") ? "noopener noreferrer" : void 0,
      ...$$restProps
    });
    toggle_class(a, "bx--side-nav__link", true);
    toggle_class(a, "bx--side-nav__link--current", isSelected());
  });
  event2("click", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, li);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SideNavLink = hmr(SideNavLink, () => SideNavLink[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SideNavLink[HMR].source;
    set(SideNavLink[HMR].source, module.default[HMR].original);
  });
}
var SideNavLink_default = SideNavLink;
mark_module_end(SideNavLink);

// node_modules/carbon-components-svelte/src/UIShell/SideNavMenu.svelte
mark_module_start();
SideNavMenu[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/SideNavMenu.svelte";
var root_1101 = add_locations(template(`<div><!></div>`), SideNavMenu[FILENAME], [[36, 6]]);
var root163 = add_locations(template(`<li><button><!> <span> </span> <div><!></div></button> <ul role="menu"><!></ul></li>`), SideNavMenu[FILENAME], [
  [
    23,
    0,
    [
      [24, 2, [[42, 4], [43, 4]]],
      [52, 2]
    ]
  ]
]);
function SideNavMenu($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["expanded", "text", "icon", "ref"]);
  push($$props, false, SideNavMenu);
  let expanded = prop($$props, "expanded", 12, false);
  let text2 = prop($$props, "text", 8, void 0);
  let icon = prop($$props, "icon", 8, void 0);
  let ref = prop($$props, "ref", 12, null);
  var li = root163();
  toggle_class(li, "bx--side-nav__item", true);
  var button = child(li);
  let attributes;
  var node = child(button);
  {
    var consequent = ($$anchor2) => {
      var div = root_1101();
      toggle_class(div, "bx--side-nav__icon", true);
      var node_1 = child(div);
      slot(node_1, $$props, "icon", {}, ($$anchor3) => {
        var fragment = comment();
        var node_2 = first_child(fragment);
        component(node_2, icon, ($$anchor4, $$component) => {
          $$component($$anchor4, {});
        });
        append($$anchor3, fragment);
      });
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$slots.icon || icon()) $$render(consequent);
    });
  }
  var span = sibling(node, 2);
  toggle_class(span, "bx--side-nav__submenu-title", true);
  var text_1 = child(span, true);
  reset(span);
  var div_1 = sibling(span, 2);
  toggle_class(div_1, "bx--side-nav__icon", true);
  toggle_class(div_1, "bx--side-nav__icon--small", true);
  toggle_class(div_1, "bx--side-nav__submenu-chevron", true);
  var node_3 = child(div_1);
  ChevronDown_default(node_3, {});
  reset(div_1);
  reset(button);
  bind_this(button, ($$value) => ref($$value), () => ref());
  var ul = sibling(button, 2);
  toggle_class(ul, "bx--side-nav__menu", true);
  var node_4 = child(ul);
  slot(node_4, $$props, "default", {}, null);
  reset(ul);
  reset(li);
  template_effect(() => {
    toggle_class(li, "bx--side-nav__item--icon", icon());
    attributes = set_attributes(button, attributes, {
      type: "button",
      "aria-expanded": expanded(),
      ...$$restProps
    });
    toggle_class(button, "bx--side-nav__submenu", true);
    set_text(text_1, text2());
    set_style(ul, "max-height", expanded() ? "none" : void 0);
  });
  event2("click", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", button, () => {
    expanded(!expanded());
  });
  append($$anchor, li);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SideNavMenu = hmr(SideNavMenu, () => SideNavMenu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SideNavMenu[HMR].source;
    set(SideNavMenu[HMR].source, module.default[HMR].original);
  });
}
var SideNavMenu_default = SideNavMenu;
mark_module_end(SideNavMenu);

// node_modules/carbon-components-svelte/src/UIShell/SideNavMenuItem.svelte
mark_module_start();
SideNavMenuItem[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/SideNavMenuItem.svelte";
var root164 = add_locations(template(`<li><a><span><!></span></a></li>`), SideNavMenuItem[FILENAME], [
  [21, 0, [[22, 2, [[30, 4]]]]]
]);
function SideNavMenuItem($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["isSelected", "href", "text", "ref"]);
  push($$props, false, SideNavMenuItem);
  let isSelected = prop($$props, "isSelected", 8, false);
  let href = prop($$props, "href", 8, void 0);
  let text2 = prop($$props, "text", 8, void 0);
  let ref = prop($$props, "ref", 12, null);
  var li = root164();
  toggle_class(li, "bx--side-nav__menu-item", true);
  var a = child(li);
  let attributes;
  var span = child(a);
  toggle_class(span, "bx--side-nav__link-text", true);
  var node = child(span);
  slot(node, $$props, "default", {}, ($$anchor2) => {
    var text_1 = text();
    template_effect(() => set_text(text_1, text2()));
    append($$anchor2, text_1);
  });
  reset(span);
  reset(a);
  bind_this(a, ($$value) => ref($$value), () => ref());
  reset(li);
  template_effect(() => {
    attributes = set_attributes(a, attributes, {
      "aria-current": isSelected() ? "page" : void 0,
      href: href(),
      ...$$restProps
    });
    toggle_class(a, "bx--side-nav__link", true);
  });
  event2("click", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, li);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SideNavMenuItem = hmr(SideNavMenuItem, () => SideNavMenuItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SideNavMenuItem[HMR].source;
    set(SideNavMenuItem[HMR].source, module.default[HMR].original);
  });
}
var SideNavMenuItem_default = SideNavMenuItem;
mark_module_end(SideNavMenuItem);

// node_modules/carbon-components-svelte/src/UIShell/Content.svelte
mark_module_start();
Content[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/Content.svelte";
var root165 = add_locations(template(`<main><!></main>`), Content[FILENAME], [[17, 0]]);
function Content($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["id"]);
  push($$props, false, Content);
  const [$$stores, $$cleanup] = setup_stores();
  const $isSideNavCollapsed = () => (validate_store(isSideNavCollapsed, "isSideNavCollapsed"), store_get(isSideNavCollapsed, "$isSideNavCollapsed", $$stores));
  const $isSideNavRail = () => (validate_store(isSideNavRail, "isSideNavRail"), store_get(isSideNavRail, "$isSideNavRail", $$stores));
  const unsetLeftMargin = mutable_state();
  let id = prop($$props, "id", 8, "main-content");
  legacy_pre_effect(
    () => ($isSideNavCollapsed(), $isSideNavRail()),
    () => {
      set(unsetLeftMargin, $isSideNavCollapsed() && !$isSideNavRail());
    }
  );
  legacy_pre_effect_reset();
  var main = root165();
  let attributes;
  var node = child(main);
  slot(node, $$props, "default", {}, null);
  reset(main);
  template_effect(() => {
    attributes = set_attributes(main, attributes, { id: id(), ...$$restProps });
    toggle_class(main, "bx--content", true);
    set_style(main, "margin-left", get(unsetLeftMargin) ? 0 : void 0);
  });
  append($$anchor, main);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Content = hmr(Content, () => Content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Content[HMR].source;
    set(Content[HMR].source, module.default[HMR].original);
  });
}
var Content_default = Content;
mark_module_end(Content);

// node_modules/carbon-components-svelte/src/UIShell/SkipToContent.svelte
mark_module_start();
SkipToContent[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/SkipToContent.svelte";
var root166 = add_locations(template(`<a><!></a>`), SkipToContent[FILENAME], [[9, 0]]);
function SkipToContent($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["href", "tabindex"]);
  push($$props, false, SkipToContent);
  let href = prop($$props, "href", 8, "#main-content");
  let tabindex = prop($$props, "tabindex", 8, "0");
  var a = root166();
  let attributes;
  var node = child(a);
  slot(node, $$props, "default", {}, ($$anchor2) => {
    var text2 = text("Skip to main content");
    append($$anchor2, text2);
  });
  reset(a);
  template_effect(() => {
    attributes = set_attributes(a, attributes, {
      href: href(),
      tabindex: tabindex(),
      ...$$restProps
    });
    toggle_class(a, "bx--skip-to-content", true);
  });
  event2("click", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, a);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SkipToContent = hmr(SkipToContent, () => SkipToContent[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SkipToContent[HMR].source;
    set(SkipToContent[HMR].source, module.default[HMR].original);
  });
}
var SkipToContent_default = SkipToContent;
mark_module_end(SkipToContent);

// node_modules/carbon-components-svelte/src/UIShell/HeaderGlobalAction.svelte
mark_module_start();
HeaderGlobalAction[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/HeaderGlobalAction.svelte";
function HeaderGlobalAction($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["isActive", "icon", "ref"]);
  push($$props, false, HeaderGlobalAction);
  const buttonClass = mutable_state();
  let isActive = prop($$props, "isActive", 8, false);
  let icon = prop($$props, "icon", 8, void 0);
  let ref = prop($$props, "ref", 12, null);
  legacy_pre_effect(
    () => (deep_read_state(isActive()), deep_read_state($$restProps)),
    () => {
      set(buttonClass, [
        "bx--header__action",
        isActive() && " bx--header__action--active",
        $$restProps.class
      ].filter(Boolean).join(" "));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, Button_default);
    Button_default(node, spread_props(() => $$restProps, {
      get class() {
        return get(buttonClass);
      },
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      $$events: {
        click($$arg) {
          bubble_event.call(this, $$props, $$arg);
        }
      },
      $$slots: {
        icon: ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          component(node_1, icon, ($$anchor3, $$component) => {
            $$component($$anchor3, { slot: "icon", size: 20 });
          });
          append($$anchor2, fragment_1);
        }
      },
      $$legacy: true
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HeaderGlobalAction = hmr(HeaderGlobalAction, () => HeaderGlobalAction[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HeaderGlobalAction[HMR].source;
    set(HeaderGlobalAction[HMR].source, module.default[HMR].original);
  });
}
var HeaderGlobalAction_default = HeaderGlobalAction;
mark_module_end(HeaderGlobalAction);

// node_modules/carbon-components-svelte/src/UIShell/HeaderSearch.svelte
mark_module_start();
HeaderSearch[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/HeaderSearch.svelte";
var root_413 = add_locations(template(`<span> </span>`), HeaderSearch[FILENAME], [[190, 38]]);
var root_319 = add_locations(template(` <!>`, 1), HeaderSearch[FILENAME], []);
var root_231 = add_locations(template(`<li role="none"><a tabindex="-1" role="menuitem"><!></a></li>`), HeaderSearch[FILENAME], [[173, 8, [[174, 10]]]]);
var root_1102 = add_locations(template(`<ul aria-labelledby="search-label" role="menu" id="search-menu"></ul>`), HeaderSearch[FILENAME], [[166, 4]]);
var root167 = add_locations(template(`<div role="search"><label for="search-input" id="search-label">Search</label> <div aria-owns="search-menu" aria-haspopup="menu"><button type="button" aria-label="Search"><!></button> <input> <button type="button" aria-label="Clear search"><!></button></div> <!></div>`), HeaderSearch[FILENAME], [
  [
    63,
    0,
    [
      [69, 2],
      [
        74,
        2,
        [[79, 4], [93, 4], [148, 4]]
      ]
    ]
  ]
]);
var $$css4 = {
  hash: "s-qIO5oRXzFdSn",
  code: "\n  .bx--header__search-label {\n    position: absolute;\n    width: 1px;\n    height: 1px;\n    margin: -1px;\n    padding: 0;\n    overflow: hidden;\n    white-space: nowrap;\n    border: 0;\n    visibility: inherit;\n    clip: rect(0, 0, 0, 0);\n  }\n\n  .bx--header__search {\n    position: relative;\n    display: flex;\n    max-width: 28rem;\n    width: 100%;\n    margin-left: 0.5rem;\n    height: 3rem;\n    background-color: #393939;\n    color: #fff;\n    transition: max-width 0.11s cubic-bezier(0.2, 0, 0.38, 0.9),\n      background 0.11s cubic-bezier(0.2, 0, 0.38, 0.9);\n  }\n\n  .bx--header__search:not(.bx--header__search--active) {\n    max-width: 3rem;\n    background-color: #161616;\n  }\n\n  .bx--header__search.bx--header__search--active {\n    outline: 2px solid #fff;\n    outline-offset: -2px;\n  }\n\n  .bx--header__search-menu {\n    display: flex;\n    flex-grow: 1;\n    border-bottom: 1px solid #393939;\n  }\n\n  .bx--header__search-input {\n    width: 100%;\n    height: 3rem;\n    padding: 0;\n    font-size: 1rem;\n    font-weight: 400;\n    line-height: 1.375rem;\n    letter-spacing: 0;\n    color: #fff;\n    caret-color: #fff;\n    background-color: initial;\n    border: none;\n    outline: none;\n    transition: opacity 0.11s cubic-bezier(0.2, 0, 0.38, 0.9);\n  }\n\n  .bx--header__search-input:not(.bx--header__search--active) {\n    opacity: 0;\n    pointer-events: none;\n  }\n\n  .bx--header-search-button {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 3rem;\n    height: 100%;\n    padding: 0;\n    flex-shrink: 0;\n    opacity: 1;\n    transition: background-color 0.11s cubic-bezier(0.2, 0, 0.38, 0.9),\n      opacity 0.11s cubic-bezier(0.2, 0, 0.38, 0.9);\n  }\n\n  .bx--header-search-button--disabled {\n    border: none;\n    pointer-events: none;\n  }\n\n  .bx--header-search-button:hover {\n    background-color: #4c4c4c;\n  }\n\n  .bx--header-search-button--hidden {\n    opacity: 0;\n    display: none;\n  }\n\n  .bx--header-search-menu {\n    position: absolute;\n    z-index: 10000;\n    padding: 1rem 0;\n    left: 0;\n    right: 0;\n    top: 3rem;\n    background-color: #161616;\n    border: 1px solid #393939;\n    border-top: none;\n    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.5);\n  }\n\n  .bx--header-search-menu-item {\n    padding: 6px 1rem;\n    cursor: pointer;\n    font-size: 0.875rem;\n    font-weight: 600;\n    line-height: 1.29;\n    letter-spacing: 0.16px;\n    transition: all 70ms cubic-bezier(0.2, 0, 0.38, 0.9);\n    display: block;\n    text-decoration: none;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    color: #c6c6c6;\n  }\n\n  .bx--header-search-menu-item--selected,\n  .bx--header-search-menu-item:hover {\n    background-color: #353535;\n    color: #f4f4f4;\n  }\n\n  .bx--header-search-menu-description {\n    font-size: 0.75rem;\n    font-weight: 400;\n    line-height: 1.34;\n    letter-spacing: 0.32px;\n    text-transform: lowercase;\n    color: #c6c6c6;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGVhZGVyU2VhcmNoLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJIZWFkZXJTZWFyY2guc3ZlbHRlIl19 */"
};
function HeaderSearch($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "value",
    "active",
    "ref",
    "results",
    "selectedResultIndex"
  ]);
  push($$props, false, HeaderSearch);
  append_styles($$anchor, $$css4);
  const selectedResult = mutable_state();
  const selectedId = mutable_state();
  let value = prop($$props, "value", 12, "");
  let active = prop($$props, "active", 12, false);
  let ref = prop($$props, "ref", 12, null);
  let results = prop($$props, "results", 24, () => []);
  let selectedResultIndex = prop($$props, "selectedResultIndex", 12, 0);
  const dispatch = createEventDispatcher();
  let refSearch = mutable_state(null);
  function reset2() {
    active(false);
    value("");
    selectedResultIndex(0);
  }
  function selectResult() {
    dispatch("select", {
      value: value(),
      selectedResultIndex: selectedResultIndex(),
      selectedResult: get(selectedResult)
    });
    reset2();
  }
  legacy_pre_effect(
    () => (deep_read_state(active()), deep_read_state(ref())),
    () => {
      if (active() && ref()) ref().focus();
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(active()), deep_read_state(ref())),
    () => {
      if (!active() && ref()) ref().blur();
    }
  );
  legacy_pre_effect(() => deep_read_state(active()), () => {
    dispatch(active() ? "active" : "inactive");
  });
  legacy_pre_effect(
    () => (deep_read_state(results()), deep_read_state(selectedResultIndex())),
    () => {
      set(selectedResult, results()[selectedResultIndex()]);
    }
  );
  legacy_pre_effect(
    () => (get(selectedResult), deep_read_state(selectedResultIndex())),
    () => {
      set(selectedId, get(selectedResult) ? `search-menuitem-${selectedResultIndex()}` : void 0);
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root167();
  event2("mouseup", $window, ({ target }) => {
    if (active() && !get(refSearch).contains(target)) active(false);
  });
  toggle_class(div, "bx--header__search", true);
  var label = child(div);
  toggle_class(label, "bx--header__search-label", true);
  var div_1 = sibling(label, 2);
  toggle_class(div_1, "bx--header__search-menu", true);
  var button = child(div_1);
  var node = child(button);
  IconSearch_default(node, { size: 20, title: "Search" });
  reset(button);
  var input = sibling(button, 2);
  remove_input_defaults(input);
  let attributes;
  bind_this(input, ($$value) => ref($$value), () => ref());
  var button_1 = sibling(input, 2);
  var node_1 = child(button_1);
  Close_default(node_1, { size: 20, title: "Close" });
  reset(button_1);
  reset(div_1);
  var node_2 = sibling(div_1, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var ul = root_1102();
      toggle_class(ul, "bx--header-search-menu", true);
      each(ul, 5, results, index, ($$anchor3, result, i) => {
        var li = root_231();
        var a = child(li);
        set_attribute(a, "id", `search-menuitem-${i ?? ""}`);
        var node_3 = child(a);
        slot(
          node_3,
          $$props,
          "default",
          {
            get result() {
              return get(result);
            },
            index: i
          },
          ($$anchor4) => {
            var fragment = root_319();
            var text2 = first_child(fragment);
            var node_4 = sibling(text2);
            {
              var consequent = ($$anchor5) => {
                var span = root_413();
                toggle_class(span, "bx--header-search-menu-description", true);
                var text_1 = child(span);
                reset(span);
                template_effect(() => set_text(text_1, ` ${get(result).description ?? ""}`));
                append($$anchor5, span);
              };
              if_block(node_4, ($$render) => {
                if (get(result).description) $$render(consequent);
              });
            }
            template_effect(() => set_text(text2, `${get(result).text ?? ""} `));
            append($$anchor4, fragment);
          }
        );
        reset(a);
        reset(li);
        template_effect(() => {
          set_attribute(a, "href", get(result).href);
          toggle_class(a, "bx--header-search-menu-item", true);
          toggle_class(a, "bx--header-search-menu-item--selected", strict_equals(get(selectedId), `search-menuitem-${i}`));
        });
        event2("click", a, preventDefault(async () => {
          selectedResultIndex(i);
          await tick();
          selectResult();
        }));
        append($$anchor3, li);
      });
      reset(ul);
      append($$anchor2, ul);
    };
    if_block(node_2, ($$render) => {
      if (active() && results().length > 0) $$render(consequent_1);
    });
  }
  reset(div);
  bind_this(div, ($$value) => set(refSearch, $$value), () => get(refSearch));
  template_effect(() => {
    toggle_class(div, "bx--header__search--active", active());
    set_attribute(button, "aria-expanded", active());
    set_attribute(button, "tabindex", active() ? "-1" : "0");
    toggle_class(button, "bx--header-search-button", true);
    toggle_class(button, "bx--header__action", true);
    toggle_class(button, "bx--header-search-button--disabled", active());
    attributes = set_attributes(
      input,
      attributes,
      {
        type: "text",
        autocomplete: "off",
        placeholder: "Search...",
        tabindex: active() ? "0" : "-1",
        ...$$restProps,
        id: "search-input",
        "aria-autocomplete": "list",
        "aria-controls": "search-menu",
        "aria-activedescendant": get(selectedId)
      },
      "s-qIO5oRXzFdSn"
    );
    toggle_class(input, "bx--header__search-input", true);
    toggle_class(input, "bx--header__search--active", active());
    set_attribute(button_1, "tabindex", active() ? "0" : "-1");
    toggle_class(button_1, "bx--header__action", true);
    toggle_class(button_1, "bx--header-search-button", true);
    toggle_class(button_1, "bx--header-search-button--hidden", !active());
  });
  event2("click", button, () => {
    active(true);
  });
  bind_value(input, value);
  event2("change", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("input", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("focus", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("blur", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("keydown", input, (e) => {
    switch (e.key) {
      case "Enter":
        selectResult();
        break;
      case "ArrowDown":
        e.preventDefault();
        if (strict_equals(selectedResultIndex(), results().length - 1)) {
          selectedResultIndex(0);
        } else {
          selectedResultIndex(selectedResultIndex() + 1);
        }
        break;
      case "ArrowUp":
        e.preventDefault();
        if (strict_equals(selectedResultIndex(), 0)) {
          selectedResultIndex(results().length - 1);
        } else {
          selectedResultIndex(selectedResultIndex() - 1);
        }
        break;
      case "Escape":
        if (strict_equals(value(), "")) {
          active(false);
        }
        value("");
        selectedResultIndex(0);
        break;
    }
  });
  event2("paste", input, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event2("click", button_1, () => {
    reset2();
    dispatch("clear");
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HeaderSearch = hmr(HeaderSearch, () => HeaderSearch[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-qIO5oRXzFdSn");
    module.default[HMR].source = HeaderSearch[HMR].source;
    set(HeaderSearch[HMR].source, module.default[HMR].original);
  });
}
var HeaderSearch_default = HeaderSearch;
mark_module_end(HeaderSearch);

// node_modules/carbon-components-svelte/src/UIShell/SideNavDivider.svelte
mark_module_start();
SideNavDivider[FILENAME] = "node_modules/carbon-components-svelte/src/UIShell/SideNavDivider.svelte";
var root168 = add_locations(template(`<li></li>`), SideNavDivider[FILENAME], [[1, 0]]);
function SideNavDivider($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, SideNavDivider);
  var li = root168();
  let attributes;
  template_effect(() => {
    attributes = set_attributes(li, attributes, { role: "separator", ...$$restProps });
    toggle_class(li, "bx--side-nav__divider", true);
  });
  append($$anchor, li);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SideNavDivider = hmr(SideNavDivider, () => SideNavDivider[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SideNavDivider[HMR].source;
    set(SideNavDivider[HMR].source, module.default[HMR].original);
  });
}
var SideNavDivider_default = SideNavDivider;
mark_module_end(SideNavDivider);
export {
  Accordion_default as Accordion,
  AccordionItem_default as AccordionItem,
  AccordionSkeleton_default as AccordionSkeleton,
  AspectRatio_default as AspectRatio,
  Breadcrumb_default as Breadcrumb,
  BreadcrumbItem_default as BreadcrumbItem,
  BreadcrumbSkeleton_default as BreadcrumbSkeleton,
  Breakpoint_default as Breakpoint,
  Button_default as Button,
  ButtonSet_default as ButtonSet,
  ButtonSkeleton_default as ButtonSkeleton,
  Checkbox_default as Checkbox,
  CheckboxSkeleton_default as CheckboxSkeleton,
  ClickableTile_default as ClickableTile,
  CodeSnippet_default as CodeSnippet,
  CodeSnippetSkeleton_default as CodeSnippetSkeleton,
  Column_default as Column,
  ComboBox_default as ComboBox,
  ComposedModal_default as ComposedModal,
  Content_default as Content,
  ContentSwitcher_default as ContentSwitcher,
  ContextMenu_default as ContextMenu,
  ContextMenuDivider_default as ContextMenuDivider,
  ContextMenuGroup_default as ContextMenuGroup,
  ContextMenuOption_default as ContextMenuOption,
  ContextMenuRadioGroup_default as ContextMenuRadioGroup,
  CopyButton_default as CopyButton,
  DataTable_default as DataTable,
  DataTableSkeleton_default as DataTableSkeleton,
  DatePicker_default as DatePicker,
  DatePickerInput_default as DatePickerInput,
  DatePickerSkeleton_default as DatePickerSkeleton,
  Dropdown_default as Dropdown,
  DropdownSkeleton_default as DropdownSkeleton,
  ExpandableTile_default as ExpandableTile,
  FileUploader_default as FileUploader,
  FileUploaderButton_default as FileUploaderButton,
  FileUploaderDropContainer_default as FileUploaderDropContainer,
  FileUploaderItem_default as FileUploaderItem,
  FileUploaderSkeleton_default as FileUploaderSkeleton,
  Filename_default as Filename,
  FluidForm_default as FluidForm,
  Form_default as Form,
  FormGroup_default as FormGroup,
  FormItem_default as FormItem,
  FormLabel_default as FormLabel,
  Grid_default as Grid,
  Header_default as Header,
  HeaderAction_default as HeaderAction,
  HeaderActionLink_default as HeaderActionLink,
  HeaderGlobalAction_default as HeaderGlobalAction,
  HeaderNav_default as HeaderNav,
  HeaderNavItem_default as HeaderNavItem,
  HeaderNavMenu_default as HeaderNavMenu,
  HeaderPanelDivider_default as HeaderPanelDivider,
  HeaderPanelLink_default as HeaderPanelLink,
  HeaderPanelLinks_default as HeaderPanelLinks,
  HeaderSearch_default as HeaderSearch,
  HeaderUtilities_default as HeaderUtilities,
  ImageLoader_default as ImageLoader,
  InlineLoading_default as InlineLoading,
  InlineNotification_default as InlineNotification,
  Link_default as Link,
  ListBox_default as ListBox,
  ListBoxField_default as ListBoxField,
  ListBoxMenu_default as ListBoxMenu,
  ListBoxMenuIcon_default as ListBoxMenuIcon,
  ListBoxMenuItem_default as ListBoxMenuItem,
  ListBoxSelection_default as ListBoxSelection,
  ListItem_default as ListItem,
  Loading_default as Loading,
  LocalStorage_default as LocalStorage,
  Modal_default as Modal,
  ModalBody_default as ModalBody,
  ModalFooter_default as ModalFooter,
  ModalHeader_default as ModalHeader,
  MultiSelect_default as MultiSelect,
  NotificationActionButton_default as NotificationActionButton,
  NotificationButton_default as NotificationButton,
  NotificationIcon_default as NotificationIcon,
  NumberInput_default as NumberInput,
  NumberInputSkeleton_default as NumberInputSkeleton,
  OrderedList_default as OrderedList,
  OutboundLink_default as OutboundLink,
  OverflowMenu_default as OverflowMenu,
  OverflowMenuItem_default as OverflowMenuItem,
  Pagination_default as Pagination,
  PaginationNav_default as PaginationNav,
  PaginationSkeleton_default as PaginationSkeleton,
  PasswordInput_default as PasswordInput,
  Popover_default as Popover,
  ProgressBar_default as ProgressBar,
  ProgressIndicator_default as ProgressIndicator,
  ProgressIndicatorSkeleton_default as ProgressIndicatorSkeleton,
  ProgressStep_default as ProgressStep,
  RadioButton_default as RadioButton,
  RadioButtonGroup_default as RadioButtonGroup,
  RadioButtonSkeleton_default as RadioButtonSkeleton,
  RadioTile_default as RadioTile,
  RecursiveList_default as RecursiveList,
  Row_default as Row,
  Search_default as Search,
  SearchSkeleton_default as SearchSkeleton,
  Select_default as Select,
  SelectItem_default as SelectItem,
  SelectItemGroup_default as SelectItemGroup,
  SelectSkeleton_default as SelectSkeleton,
  SelectableTile_default as SelectableTile,
  SideNav_default as SideNav,
  SideNavDivider_default as SideNavDivider,
  SideNavItems_default as SideNavItems,
  SideNavLink_default as SideNavLink,
  SideNavMenu_default as SideNavMenu,
  SideNavMenuItem_default as SideNavMenuItem,
  SkeletonPlaceholder_default as SkeletonPlaceholder,
  SkeletonText_default as SkeletonText,
  SkipToContent_default as SkipToContent,
  Slider_default as Slider,
  SliderSkeleton_default as SliderSkeleton,
  StructuredList_default as StructuredList,
  StructuredListBody_default as StructuredListBody,
  StructuredListCell_default as StructuredListCell,
  StructuredListHead_default as StructuredListHead,
  StructuredListInput_default as StructuredListInput,
  StructuredListRow_default as StructuredListRow,
  StructuredListSkeleton_default as StructuredListSkeleton,
  Switch_default as Switch,
  Tab_default as Tab,
  TabContent_default as TabContent,
  Table_default as Table,
  TableBody_default as TableBody,
  TableCell_default as TableCell,
  TableContainer_default as TableContainer,
  TableHead_default as TableHead,
  TableHeader_default as TableHeader,
  TableRow_default as TableRow,
  Tabs_default as Tabs,
  TabsSkeleton_default as TabsSkeleton,
  Tag_default as Tag,
  TagSkeleton_default as TagSkeleton,
  TextArea_default as TextArea,
  TextAreaSkeleton_default as TextAreaSkeleton,
  TextInput_default as TextInput,
  TextInputSkeleton_default as TextInputSkeleton,
  Theme_default as Theme,
  Tile_default as Tile,
  TileGroup_default as TileGroup,
  TimePicker_default as TimePicker,
  TimePickerSelect_default as TimePickerSelect,
  ToastNotification_default as ToastNotification,
  Toggle_default as Toggle,
  ToggleSkeleton_default as ToggleSkeleton,
  Toolbar_default as Toolbar,
  ToolbarBatchActions_default as ToolbarBatchActions,
  ToolbarContent_default as ToolbarContent,
  ToolbarMenu_default as ToolbarMenu,
  ToolbarMenuItem_default as ToolbarMenuItem,
  ToolbarSearch_default as ToolbarSearch,
  Tooltip_default as Tooltip,
  TooltipDefinition_default as TooltipDefinition,
  TooltipFooter_default as TooltipFooter,
  TooltipIcon_default as TooltipIcon,
  TreeView_default as TreeView,
  Truncate_default as Truncate,
  UnorderedList_default as UnorderedList,
  breakpointObserver_default as breakpointObserver,
  breakpoints_default as breakpoints,
  truncate_default as truncate
};
//# sourceMappingURL=carbon-components-svelte.js.map
