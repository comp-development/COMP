import "./chunk-BFCEFRYA.js";

// node_modules/mathlifier/dist/mathlifier.js
function us(t, e) {
  return (n, ...r) => {
    let s = "", a = "", l = 0, u = {
      mathEnv: 0
      /* equation */
    };
    if (n.forEach((c, m) => {
      let b = r[m];
      if ((b == null || typeof b == "object" && Object.keys(b).length === 0) && (b = ""), l === 0)
        c.endsWith("@") ? s += `${c.slice(0, c.length - 1)}${b}` : [l, a, s, u] = le(c, "", b, s);
      else if (l === 1) {
        const A = /([^]*?)(\r?\n)([^]*)/, x = c.match(A);
        if (x) {
          const [, T, D, j] = x;
          a += `${T}`, a && (s += t.math(a)), [l, a, s, u] = le(j, D, b, s);
        } else
          c.endsWith("@") ? a += `${c.slice(0, c.length - 1)}` : a += `${c}${b}`;
      } else if (l === 2) {
        const A = /([^]*?)(\r?\n[ \t]*\r?\n)([^]*)/, x = c.match(A);
        if (x) {
          const [, T, D, j] = x;
          a += T, a && (s += t.display(a)), [l, a, s, u] = le(j, D, b, s);
        } else
          c.endsWith("@") ? a += `${c.slice(0, c.length - 1)}` : a += `${c}${b}`;
      } else if (l === 3) {
        const A = /([^]*?)(\r?\n[ \t]*\r?\n)([^]*)/, x = c.match(A);
        if (x) {
          const [, T, D, j] = x;
          a += T, a && (s += ue(
            u,
            a,
            t
          )), [l, a, s, u] = le(j, D, b, s);
        } else
          c.endsWith("@") ? a += `${c.slice(0, c.length - 1)}` : a += `${c}${b}`;
      }
    }), a) {
      const c = l;
      if (e != null && e.postContent) {
        const m = e.postContent.mode ?? "auto-math", b = e.postContent.content;
        c === 0 && m === "text" ? s += a + b : c === 1 && (m === "math" || m === "auto-math") ? s += t.math(a + b) : c === 2 && (m === "display" || m === "auto-math") ? s += t.display(a + b) : c === 3 && m === "auto-math" ? s += ue(
          u,
          a + b,
          t
        ) : (c === 0 ? s += a : c === 1 ? s += t.math(a) : c === 2 ? s += t.display(a) : s += ue(
          u,
          a,
          t
        ), m === "text" ? s += b : m === "math" || m === "auto-math" ? s += t.math(b) : m === "display" && (s += t.display(b)));
      } else
        c === 1 ? s += t.math(a) : c === 2 ? s += t.display(a) : s += ue(
          u,
          a,
          t
        );
    } else if (e != null && e.postContent) {
      const { mode: c, content: m } = e.postContent;
      c === "text" ? s += m : c === "math" || c === "auto-math" ? s += t.math(m) : c === "display" && (s += t.display(m));
    }
    return s;
  };
}
var cs = [
  "equation",
  "equation*",
  "align",
  "align*",
  "gather",
  "gather*",
  "alignat",
  "alignat*"
];
function hs(t) {
  return cs.includes(t);
}
var ds = {
  equation: 0,
  "equation*": 1,
  align: 2,
  "align*": 3,
  gather: 4,
  "gather*": 5,
  alignat: 6,
  // triggered by $${'alignat'}{x}
  "alignat*": 7
  /* alignatStar */
  // triggered by $${'alignat'}{x}
};
function le(t, e, n, r) {
  const s = {
    mathEnv: 0
    /* equation */
  };
  let a = s;
  if (t.endsWith("$")) {
    let l = `${n}`, u = 2;
    return hs(l) && (u = 3, a = { mathEnv: ds[l] }, l = ""), [
      u,
      l,
      r + `${e}${t.slice(0, t.length - 1)}`,
      a
    ];
  } else return t.endsWith("@") ? [
    0,
    "",
    r + `${e}${t.slice(0, t.length - 1)}${n}`,
    s
  ] : [
    1,
    `${n}`,
    r + e + t,
    s
  ];
}
function ue(t, e, n) {
  var s, a, l, u, c, m, b, A;
  const r = t.mathEnv;
  return r === 0 ? (s = n.mathEnvs) != null && s.equation ? n.mathEnvs.equation(e) : e : r === 1 ? (a = n.mathEnvs) != null && a.equationStar ? n.mathEnvs.equationStar(e) : e : r === 2 ? (l = n.mathEnvs) != null && l.align ? n.mathEnvs.align(e) : e : r === 3 ? (u = n.mathEnvs) != null && u.alignStar ? n.mathEnvs.alignStar(e) : e : r === 4 ? (c = n.mathEnvs) != null && c.gather ? n.mathEnvs.gather(e) : e : r === 5 ? (m = n.mathEnvs) != null && m.gatherStar ? n.mathEnvs.gatherStar(e) : e : r === 6 ? (b = n.mathEnvs) != null && b.alignat ? n.mathEnvs.alignat(e) : e : r === 7 ? (A = n.mathEnvs) != null && A.alignatStar ? n.mathEnvs.alignatStar(e) : e : (console.warn(`mathEnv ${r} not found`), e);
}
function ps(t, ...e) {
  return us(ms)(t, ...e);
}
var Nt = (t) => "$$ " + t + " $$";
var ms = {
  math: (t) => "$ " + t + " $",
  display: Nt,
  mathEnvs: {
    equation: (t) => Nt(Et("equation", t)),
    align: (t) => Nt(Et("align", t)),
    gather: (t) => Nt(Et("gather", t)),
    alignat: (t) => Nt(Et("alignat", t)),
    equationStar: (t) => Nt(Et("equation*", t)),
    alignStar: (t) => Nt(Et("align*", t)),
    gatherStar: (t) => Nt(Et("gather*", t)),
    alignatStar: (t) => Nt(Et("alignat*", t))
  }
};
function Et(t, e, n = "") {
  if (t === "alignat" || t === "alignat*") {
    let r = e.split(`
`)[0];
    r || (r = e.split(`
`)[1]);
    const s = r.split("&").length;
    s % 2 !== 0 && console.warn(
      `alignat should have an even number of columns, but got ${s} instead`
    ), n = `{${Math.floor(s / 2)}}`;
  }
  for (; e.endsWith(`
`) || e.endsWith("	") || e.endsWith(" "); )
    e = e.slice(0, e.length - 1);
  return `\\begin{${t}}${n}${e}
\\end{${t}}`;
}
function fs(t, ...e) {
  return ps(t, ...e).replace(new RegExp("(?<!\\\\)\\$(?!`)\\$([^]+?)\\$\\$", "g"), (r, s) => `$$\`${s}\``).replace(
    new RegExp("(?<!\\\\)\\$(?![`$])([^]+?)(?<!\\\\)\\$", "g"),
    (r, s) => `$\`${s}\``
  );
}
var q = class _q {
  constructor(e, n) {
    let r = " " + e, s;
    const a = n && n.loc;
    if (a && a.start <= a.end) {
      const u = a.lexer.input;
      s = a.start;
      const c = a.end;
      s === u.length ? r += " at end of input: " : r += " at position " + (s + 1) + ": ";
      const m = u.slice(s, c).replace(/[^]/g, "$&Ì²");
      let b;
      s > 15 ? b = "â€¦" + u.slice(s - 15, s) : b = u.slice(0, s);
      let A;
      c + 15 < u.length ? A = u.slice(c, c + 15) + "â€¦" : A = u.slice(c), r += b + m + A;
    }
    const l = new Error(r);
    return l.name = "ParseError", l.__proto__ = _q.prototype, l.position = s, l;
  }
};
q.prototype.__proto__ = Error.prototype;
var gs = function(t, e) {
  return t === void 0 ? e : t;
};
var bs = /([A-Z])/g;
var xs = function(t) {
  return t.replace(bs, "-$1").toLowerCase();
};
var ys = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
};
var ws = /[&><"']/g;
function vs(t) {
  return String(t).replace(ws, (e) => ys[e]);
}
var Zt = function(t) {
  return t.type === "ordgroup" || t.type === "color" ? t.body.length === 1 ? Zt(t.body[0]) : t : t.type === "font" ? Zt(t.body) : t;
};
var ks = function(t) {
  const e = Zt(t);
  return e.type === "mathord" || e.type === "textord" || e.type === "atom";
};
var _s = function(t) {
  if (!t)
    throw new Error("Expected non-null, but got " + String(t));
  return t;
};
var As = function(t) {
  const e = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(t);
  return e ? e[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(e[1]) ? null : e[1].toLowerCase() : "_relative";
};
var Ss = function(t) {
  return +t.toFixed(4);
};
var Q = {
  deflt: gs,
  escape: vs,
  hyphenate: xs,
  getBaseElem: Zt,
  isCharacterBox: ks,
  protocolFromUrl: As,
  round: Ss
};
var ln = class {
  constructor(e) {
    e = e || {}, this.displayMode = Q.deflt(e.displayMode, false), this.annotate = Q.deflt(e.annotate, false), this.leqno = Q.deflt(e.leqno, false), this.throwOnError = Q.deflt(e.throwOnError, false), this.errorColor = Q.deflt(e.errorColor, "#b22222"), this.macros = e.macros || {}, this.wrap = Q.deflt(e.wrap, "tex"), this.xml = Q.deflt(e.xml, false), this.colorIsTextColor = Q.deflt(e.colorIsTextColor, false), this.strict = Q.deflt(e.strict, false), this.trust = Q.deflt(e.trust, false), this.maxSize = e.maxSize === void 0 ? [1 / 0, 1 / 0] : Array.isArray(e.maxSize) ? e.maxSize : [1 / 0, 1 / 0], this.maxExpand = Math.max(0, Q.deflt(e.maxExpand, 1e3));
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(e) {
    if (e.url && !e.protocol) {
      const r = Q.protocolFromUrl(e.url);
      if (r == null)
        return false;
      e.protocol = r;
    }
    return !!(typeof this.trust == "function" ? this.trust(e) : this.trust);
  }
};
var Nr = {};
var be = {};
function E({
  type: t,
  names: e,
  props: n,
  handler: r,
  mathmlBuilder: s
}) {
  const a = {
    type: t,
    numArgs: n.numArgs,
    argTypes: n.argTypes,
    allowedInArgument: !!n.allowedInArgument,
    allowedInText: !!n.allowedInText,
    allowedInMath: n.allowedInMath === void 0 ? true : n.allowedInMath,
    numOptionalArgs: n.numOptionalArgs || 0,
    infix: !!n.infix,
    primitive: !!n.primitive,
    handler: r
  };
  for (let l = 0; l < e.length; ++l)
    Nr[e[l]] = a;
  t && s && (be[t] = s);
}
function zt({ type: t, mathmlBuilder: e }) {
  E({
    type: t,
    names: [],
    props: { numArgs: 0 },
    handler() {
      throw new Error("Should never be called.");
    },
    mathmlBuilder: e
  });
}
var Yt = function(t) {
  return t.type === "ordgroup" && t.body.length === 1 ? t.body[0] : t;
};
var it = function(t) {
  return t.type === "ordgroup" ? t.body : [t];
};
var un = class {
  constructor(e) {
    this.children = e, this.classes = [], this.style = {};
  }
  hasClass(e) {
    return this.classes.includes(e);
  }
  /** Convert the fragment into a node. */
  toNode() {
    const e = document.createDocumentFragment();
    for (let n = 0; n < this.children.length; n++)
      e.appendChild(this.children[n].toNode());
    return e;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    let e = "";
    for (let n = 0; n < this.children.length; n++)
      e += this.children[n].toMarkup();
    return e;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    const e = (n) => n.toText();
    return this.children.map(e).join("");
  }
};
var xe = function(t) {
  return t.filter((e) => e).join(" ");
};
var Ns = function(t, e) {
  this.classes = t || [], this.attributes = {}, this.style = e || {};
};
var Cs = function(t) {
  const e = document.createElement(t);
  e.className = xe(this.classes);
  for (const n in this.style)
    Object.prototype.hasOwnProperty.call(this.style, n) && (e.style[n] = this.style[n]);
  for (const n in this.attributes)
    Object.prototype.hasOwnProperty.call(this.attributes, n) && e.setAttribute(n, this.attributes[n]);
  for (let n = 0; n < this.children.length; n++)
    e.appendChild(this.children[n].toNode());
  return e;
};
var Ts = function(t) {
  let e = `<${t}`;
  this.classes.length && (e += ` class="${Q.escape(xe(this.classes))}"`);
  let n = "";
  for (const r in this.style)
    Object.prototype.hasOwnProperty.call(this.style, r) && (n += `${Q.hyphenate(r)}:${this.style[r]};`);
  n && (e += ` style="${n}"`);
  for (const r in this.attributes)
    Object.prototype.hasOwnProperty.call(this.attributes, r) && (e += ` ${r}="${Q.escape(this.attributes[r])}"`);
  e += ">";
  for (let r = 0; r < this.children.length; r++)
    e += this.children[r].toMarkup();
  return e += `</${t}>`, e;
};
var Cr = class {
  constructor(e, n, r) {
    Ns.call(this, e, r), this.children = n || [];
  }
  setAttribute(e, n) {
    this.attributes[e] = n;
  }
  toNode() {
    return Cs.call(this, "span");
  }
  toMarkup() {
    return Ts.call(this, "span");
  }
};
var qs = class {
  constructor(e) {
    this.text = e;
  }
  toNode() {
    return document.createTextNode(this.text);
  }
  toMarkup() {
    return Q.escape(this.text);
  }
};
var Ms = class {
  constructor(e, n, r) {
    this.alt = n, this.src = e, this.classes = ["mord"], this.style = r;
  }
  hasClass(e) {
    return this.classes.includes(e);
  }
  toNode() {
    const e = document.createElement("img");
    e.src = this.src, e.alt = this.alt, e.className = "mord";
    for (const n in this.style)
      Object.prototype.hasOwnProperty.call(this.style, n) && (e.style[n] = this.style[n]);
    return e;
  }
  toMarkup() {
    let e = `<img src='${this.src}' alt='${this.alt}'`, n = "";
    for (const r in this.style)
      Object.prototype.hasOwnProperty.call(this.style, r) && (n += `${Q.hyphenate(r)}:${this.style[r]};`);
    return n && (e += ` style="${Q.escape(n)}"`), e += ">", e;
  }
};
function Os(t) {
  return new un(t);
}
var ht = class {
  constructor(e, n, r, s) {
    this.type = e, this.attributes = {}, this.children = n || [], this.classes = r || [], this.style = s || {};
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(e, n) {
    this.attributes[e] = n;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(e) {
    return this.attributes[e];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    const e = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (const n in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, n) && e.setAttribute(n, this.attributes[n]);
    this.classes.length > 0 && (e.className = xe(this.classes));
    for (const n in this.style)
      Object.prototype.hasOwnProperty.call(this.style, n) && (e.style[n] = this.style[n]);
    for (let n = 0; n < this.children.length; n++)
      e.appendChild(this.children[n].toNode());
    return e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    let e = "<" + this.type;
    for (const r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && (e += " " + r + '="', e += Q.escape(this.attributes[r]), e += '"');
    this.classes.length > 0 && (e += ` class="${Q.escape(xe(this.classes))}"`);
    let n = "";
    for (const r in this.style)
      Object.prototype.hasOwnProperty.call(this.style, r) && (n += `${Q.hyphenate(r)}:${this.style[r]};`);
    n && (e += ` style="${n}"`), e += ">";
    for (let r = 0; r < this.children.length; r++)
      e += this.children[r].toMarkup();
    return e += "</" + this.type + ">", e;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((e) => e.toText()).join("");
  }
};
var Tr = class {
  constructor(e) {
    this.text = e;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return Q.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
};
var cn = (t) => {
  let e;
  return t.length === 1 && t[0].type === "mrow" ? (e = t.pop(), e.type = "mstyle") : e = new ht("mstyle", t), e;
};
var y = {
  MathNode: ht,
  TextNode: Tr,
  newDocumentFragment: Os
};
var Ht = (t) => {
  let e = 0;
  if (t.body)
    for (const n of t.body)
      e += Ht(n);
  else if (t.type === "supsub")
    e += Ht(t.base), t.sub && (e += 0.7 * Ht(t.sub)), t.sup && (e += 0.7 * Ht(t.sup));
  else if (t.type === "mathord" || t.type === "textord")
    for (const n of t.text.split("")) {
      const r = n.codePointAt(0);
      96 < r && r < 123 || 944 < r && r < 970 ? e += 0.56 : 47 < r && r < 58 ? e += 0.5 : e += 0.92;
    }
  else
    e += 1;
  return e;
};
var Es = {
  widehat: "^",
  widecheck: "Ë‡",
  widetilde: "~",
  wideparen: "âœ",
  // \u23dc
  utilde: "~",
  overleftarrow: "â†",
  underleftarrow: "â†",
  xleftarrow: "â†",
  overrightarrow: "â†’",
  underrightarrow: "â†’",
  xrightarrow: "â†’",
  underbrace: "âŸ",
  overbrace: "â",
  overgroup: "â ",
  overparen: "âœ",
  undergroup: "â¡",
  underparen: "â",
  overleftrightarrow: "â†”",
  underleftrightarrow: "â†”",
  xleftrightarrow: "â†”",
  Overrightarrow: "â‡’",
  xRightarrow: "â‡’",
  overleftharpoon: "â†¼",
  xleftharpoonup: "â†¼",
  overrightharpoon: "â‡€",
  xrightharpoonup: "â‡€",
  xLeftarrow: "â‡",
  xLeftrightarrow: "â‡”",
  xhookleftarrow: "â†©",
  xhookrightarrow: "â†ª",
  xmapsto: "â†¦",
  xrightharpoondown: "â‡",
  xleftharpoondown: "â†½",
  xtwoheadleftarrow: "â†",
  xtwoheadrightarrow: "â† ",
  xlongequal: "=",
  xrightleftarrows: "â‡„",
  yields: "â†’",
  yieldsLeft: "â†",
  mesomerism: "â†”",
  longrightharpoonup: "â‡€",
  longleftharpoondown: "â†½",
  eqrightharpoonup: "â‡€",
  eqleftharpoondown: "â†½",
  "\\cdrightarrow": "â†’",
  "\\cdleftarrow": "â†",
  "\\cdlongequal": "="
};
var qr = function(t) {
  const e = new y.TextNode(Es[t.slice(1)]), n = new y.MathNode("mo", [e]);
  return n.setAttribute("stretchy", "true"), n;
};
var $s = ["\\widetilde", "\\widehat", "\\widecheck", "\\utilde"];
var Is = (t) => {
  const e = qr(t.label);
  if ($s.includes(t.label)) {
    const n = Ht(t.base);
    1 < n && n < 1.6 ? e.classes.push("tml-crooked-2") : 1.6 <= n && n < 2.5 ? e.classes.push("tml-crooked-3") : 2.5 <= n && e.classes.push("tml-crooked-4");
  }
  return e;
};
var Ae = {
  mathMLnode: qr,
  accentNode: Is
};
var Ds = {
  bin: 1,
  close: 1,
  inner: 1,
  open: 1,
  punct: 1,
  rel: 1
};
var Ps = {
  "accent-token": 1,
  mathord: 1,
  "op-token": 1,
  spacing: 1,
  textord: 1
};
var lt = {
  math: {},
  text: {}
};
function i(t, e, n, r, s) {
  lt[t][r] = { group: e, replace: n }, s && n && (lt[t][n] = lt[t][r]);
}
var o = "math";
var _ = "text";
var V = "accent-token";
var w = "bin";
var at = "close";
var jt = "inner";
var O = "mathord";
var G = "op-token";
var ut = "open";
var Jt = "punct";
var d = "rel";
var qt = "spacing";
var f = "textord";
i(o, d, "â‰¡", "\\equiv", true);
i(o, d, "â‰º", "\\prec", true);
i(o, d, "â‰»", "\\succ", true);
i(o, d, "âˆ¼", "\\sim", true);
i(o, d, "âŸ‚", "\\perp", true);
i(o, d, "âª¯", "\\preceq", true);
i(o, d, "âª°", "\\succeq", true);
i(o, d, "â‰ƒ", "\\simeq", true);
i(o, d, "â‰Œ", "\\backcong", true);
i(o, d, "|", "\\mid", true);
i(o, d, "â‰ª", "\\ll", true);
i(o, d, "â‰«", "\\gg", true);
i(o, d, "â‰", "\\asymp", true);
i(o, d, "âˆ¥", "\\parallel");
i(o, d, "âŒ£", "\\smile", true);
i(o, d, "âŠ‘", "\\sqsubseteq", true);
i(o, d, "âŠ’", "\\sqsupseteq", true);
i(o, d, "â‰", "\\doteq", true);
i(o, d, "âŒ¢", "\\frown", true);
i(o, d, "âˆ‹", "\\ni", true);
i(o, d, "âˆŒ", "\\notni", true);
i(o, d, "âˆ", "\\propto", true);
i(o, d, "âŠ¢", "\\vdash", true);
i(o, d, "âŠ£", "\\dashv", true);
i(o, d, "âˆ‹", "\\owns");
i(o, d, "â‰˜", "\\arceq", true);
i(o, d, "â‰™", "\\wedgeq", true);
i(o, d, "â‰š", "\\veeeq", true);
i(o, d, "â‰›", "\\stareq", true);
i(o, d, "â‰", "\\eqdef", true);
i(o, d, "â‰", "\\measeq", true);
i(o, d, "â‰Ÿ", "\\questeq", true);
i(o, d, "â‰ ", "\\ne", true);
i(o, d, "â‰ ", "\\neq");
i(o, d, "â©µ", "\\eqeq", true);
i(o, d, "â©¶", "\\eqeqeq", true);
i(o, d, "âˆ·", "\\dblcolon", true);
i(o, d, "â‰”", "\\coloneqq", true);
i(o, d, "â‰•", "\\eqqcolon", true);
i(o, d, "âˆ¹", "\\eqcolon", true);
i(o, d, "â©´", "\\Coloneqq", true);
i(o, Jt, ".", "\\ldotp");
i(o, Jt, "Â·", "\\cdotp");
i(o, f, "#", "\\#");
i(_, f, "#", "\\#");
i(o, f, "&", "\\&");
i(_, f, "&", "\\&");
i(o, f, "â„µ", "\\aleph", true);
i(o, f, "âˆ€", "\\forall", true);
i(o, f, "â„", "\\hbar", true);
i(o, f, "âˆƒ", "\\exists", true);
i(o, w, "âˆ‡", "\\nabla", true);
i(o, f, "â™­", "\\flat", true);
i(o, f, "â„“", "\\ell", true);
i(o, f, "â™®", "\\natural", true);
i(o, f, "â„«", "\\Angstrom", true);
i(_, f, "â„«", "\\Angstrom", true);
i(o, f, "â™£", "\\clubsuit", true);
i(o, f, "â™§", "\\varclubsuit", true);
i(o, f, "â„˜", "\\wp", true);
i(o, f, "â™¯", "\\sharp", true);
i(o, f, "â™¢", "\\diamondsuit", true);
i(o, f, "â™¦", "\\vardiamondsuit", true);
i(o, f, "â„œ", "\\Re", true);
i(o, f, "â™¡", "\\heartsuit", true);
i(o, f, "â™¥", "\\varheartsuit", true);
i(o, f, "â„‘", "\\Im", true);
i(o, f, "â™ ", "\\spadesuit", true);
i(o, f, "â™¤", "\\varspadesuit", true);
i(o, f, "â™€", "\\female", true);
i(o, f, "â™‚", "\\male", true);
i(o, f, "Â§", "\\S", true);
i(_, f, "Â§", "\\S");
i(o, f, "Â¶", "\\P", true);
i(_, f, "Â¶", "\\P");
i(_, f, "â˜º", "\\smiley", true);
i(o, f, "â˜º", "\\smiley", true);
i(o, f, "â€ ", "\\dag");
i(_, f, "â€ ", "\\dag");
i(_, f, "â€ ", "\\textdagger");
i(o, f, "â€¡", "\\ddag");
i(_, f, "â€¡", "\\ddag");
i(_, f, "â€¡", "\\textdaggerdbl");
i(o, at, "â±", "\\rmoustache", true);
i(o, ut, "â°", "\\lmoustache", true);
i(o, at, "âŸ¯", "\\rgroup", true);
i(o, ut, "âŸ®", "\\lgroup", true);
i(o, w, "âˆ“", "\\mp", true);
i(o, w, "âŠ–", "\\ominus", true);
i(o, w, "âŠ", "\\uplus", true);
i(o, w, "âŠ“", "\\sqcap", true);
i(o, w, "âˆ—", "\\ast");
i(o, w, "âŠ”", "\\sqcup", true);
i(o, w, "â—¯", "\\bigcirc", true);
i(o, w, "âˆ™", "\\bullet", true);
i(o, w, "â€¡", "\\ddagger");
i(o, w, "â‰€", "\\wr", true);
i(o, w, "â¨¿", "\\amalg");
i(o, w, "&", "\\And");
i(o, w, "â«½", "\\sslash", true);
i(o, d, "âŸµ", "\\longleftarrow", true);
i(o, d, "â‡", "\\Leftarrow", true);
i(o, d, "âŸ¸", "\\Longleftarrow", true);
i(o, d, "âŸ¶", "\\longrightarrow", true);
i(o, d, "â‡’", "\\Rightarrow", true);
i(o, d, "âŸ¹", "\\Longrightarrow", true);
i(o, d, "â†”", "\\leftrightarrow", true);
i(o, d, "âŸ·", "\\longleftrightarrow", true);
i(o, d, "â‡”", "\\Leftrightarrow", true);
i(o, d, "âŸº", "\\Longleftrightarrow", true);
i(o, d, "â†¤", "\\mapsfrom", true);
i(o, d, "â†¦", "\\mapsto", true);
i(o, d, "âŸ¼", "\\longmapsto", true);
i(o, d, "â†—", "\\nearrow", true);
i(o, d, "â†©", "\\hookleftarrow", true);
i(o, d, "â†ª", "\\hookrightarrow", true);
i(o, d, "â†˜", "\\searrow", true);
i(o, d, "â†¼", "\\leftharpoonup", true);
i(o, d, "â‡€", "\\rightharpoonup", true);
i(o, d, "â†™", "\\swarrow", true);
i(o, d, "â†½", "\\leftharpoondown", true);
i(o, d, "â‡", "\\rightharpoondown", true);
i(o, d, "â†–", "\\nwarrow", true);
i(o, d, "â‡Œ", "\\rightleftharpoons", true);
i(o, O, "â†¯", "\\lightning", true);
i(o, O, "âˆ", "\\QED", true);
i(o, O, "â€°", "\\permil", true);
i(_, f, "â€°", "\\permil");
i(o, O, "â˜‰", "\\astrosun", true);
i(o, O, "â˜¼", "\\sun", true);
i(o, O, "â˜¾", "\\leftmoon", true);
i(o, O, "â˜½", "\\rightmoon", true);
i(o, O, "âŠ•", "\\Earth");
i(o, d, "â‰®", "\\nless", true);
i(o, d, "âª‡", "\\lneq", true);
i(o, d, "â‰¨", "\\lneqq", true);
i(o, d, "â‰¨ï¸€", "\\lvertneqq");
i(o, d, "â‹¦", "\\lnsim", true);
i(o, d, "âª‰", "\\lnapprox", true);
i(o, d, "âŠ€", "\\nprec", true);
i(o, d, "â‹ ", "\\npreceq", true);
i(o, d, "â‹¨", "\\precnsim", true);
i(o, d, "âª¹", "\\precnapprox", true);
i(o, d, "â‰", "\\nsim", true);
i(o, d, "âˆ¤", "\\nmid", true);
i(o, d, "âˆ¤", "\\nshortmid");
i(o, d, "âŠ¬", "\\nvdash", true);
i(o, d, "âŠ­", "\\nvDash", true);
i(o, d, "â‹ª", "\\ntriangleleft");
i(o, d, "â‹¬", "\\ntrianglelefteq", true);
i(o, d, "âŠ„", "\\nsubset", true);
i(o, d, "âŠ…", "\\nsupset", true);
i(o, d, "âŠŠ", "\\subsetneq", true);
i(o, d, "âŠŠï¸€", "\\varsubsetneq");
i(o, d, "â«‹", "\\subsetneqq", true);
i(o, d, "â«‹ï¸€", "\\varsubsetneqq");
i(o, d, "â‰¯", "\\ngtr", true);
i(o, d, "âªˆ", "\\gneq", true);
i(o, d, "â‰©", "\\gneqq", true);
i(o, d, "â‰©ï¸€", "\\gvertneqq");
i(o, d, "â‹§", "\\gnsim", true);
i(o, d, "âªŠ", "\\gnapprox", true);
i(o, d, "âŠ", "\\nsucc", true);
i(o, d, "â‹¡", "\\nsucceq", true);
i(o, d, "â‹©", "\\succnsim", true);
i(o, d, "âªº", "\\succnapprox", true);
i(o, d, "â‰†", "\\ncong", true);
i(o, d, "âˆ¦", "\\nparallel", true);
i(o, d, "âˆ¦", "\\nshortparallel");
i(o, d, "âŠ¯", "\\nVDash", true);
i(o, d, "â‹«", "\\ntriangleright");
i(o, d, "â‹­", "\\ntrianglerighteq", true);
i(o, d, "âŠ‹", "\\supsetneq", true);
i(o, d, "âŠ‹", "\\varsupsetneq");
i(o, d, "â«Œ", "\\supsetneqq", true);
i(o, d, "â«Œï¸€", "\\varsupsetneqq");
i(o, d, "âŠ®", "\\nVdash", true);
i(o, d, "âªµ", "\\precneqq", true);
i(o, d, "âª¶", "\\succneqq", true);
i(o, w, "âŠ´", "\\unlhd");
i(o, w, "âŠµ", "\\unrhd");
i(o, d, "â†š", "\\nleftarrow", true);
i(o, d, "â†›", "\\nrightarrow", true);
i(o, d, "â‡", "\\nLeftarrow", true);
i(o, d, "â‡", "\\nRightarrow", true);
i(o, d, "â†®", "\\nleftrightarrow", true);
i(o, d, "â‡", "\\nLeftrightarrow", true);
i(o, d, "â–³", "\\vartriangle");
i(o, f, "â„", "\\hslash");
i(o, f, "â–½", "\\triangledown");
i(o, f, "â—Š", "\\lozenge");
i(o, f, "â“ˆ", "\\circledS");
i(o, f, "Â®", "\\circledR", true);
i(_, f, "Â®", "\\circledR");
i(_, f, "Â®", "\\textregistered");
i(o, f, "âˆ¡", "\\measuredangle", true);
i(o, f, "âˆ„", "\\nexists");
i(o, f, "â„§", "\\mho");
i(o, f, "â„²", "\\Finv", true);
i(o, f, "â…", "\\Game", true);
i(o, f, "â€µ", "\\backprime");
i(o, f, "â€¶", "\\backdprime");
i(o, f, "â€·", "\\backtrprime");
i(o, f, "â–²", "\\blacktriangle");
i(o, f, "â–¼", "\\blacktriangledown");
i(o, f, "â– ", "\\blacksquare");
i(o, f, "â§«", "\\blacklozenge");
i(o, f, "â˜…", "\\bigstar");
i(o, f, "âˆ¢", "\\sphericalangle", true);
i(o, f, "âˆ", "\\complement", true);
i(o, f, "Ã°", "\\eth", true);
i(_, f, "Ã°", "Ã°");
i(o, f, "â•±", "\\diagup");
i(o, f, "â•²", "\\diagdown");
i(o, f, "â–¡", "\\square");
i(o, f, "â–¡", "\\Box");
i(o, f, "â—Š", "\\Diamond");
i(o, f, "Â¥", "\\yen", true);
i(_, f, "Â¥", "\\yen", true);
i(o, f, "âœ“", "\\checkmark", true);
i(_, f, "âœ“", "\\checkmark");
i(o, f, "âœ—", "\\ballotx", true);
i(_, f, "âœ—", "\\ballotx");
i(_, f, "â€¢", "\\textbullet");
i(o, f, "â„¶", "\\beth", true);
i(o, f, "â„¸", "\\daleth", true);
i(o, f, "â„·", "\\gimel", true);
i(o, f, "Ï", "\\digamma", true);
i(o, f, "Ï°", "\\varkappa");
i(o, ut, "âŒœ", "\\ulcorner", true);
i(o, at, "âŒ", "\\urcorner", true);
i(o, ut, "âŒ", "\\llcorner", true);
i(o, at, "âŒŸ", "\\lrcorner", true);
i(o, d, "â‰¦", "\\leqq", true);
i(o, d, "â©½", "\\leqslant", true);
i(o, d, "âª•", "\\eqslantless", true);
i(o, d, "â‰²", "\\lesssim", true);
i(o, d, "âª…", "\\lessapprox", true);
i(o, d, "â‰Š", "\\approxeq", true);
i(o, w, "â‹–", "\\lessdot");
i(o, d, "â‹˜", "\\lll", true);
i(o, d, "â‰¶", "\\lessgtr", true);
i(o, d, "â‹š", "\\lesseqgtr", true);
i(o, d, "âª‹", "\\lesseqqgtr", true);
i(o, d, "â‰‘", "\\doteqdot");
i(o, d, "â‰“", "\\risingdotseq", true);
i(o, d, "â‰’", "\\fallingdotseq", true);
i(o, d, "âˆ½", "\\backsim", true);
i(o, d, "â‹", "\\backsimeq", true);
i(o, d, "â«…", "\\subseteqq", true);
i(o, d, "â‹", "\\Subset", true);
i(o, d, "âŠ", "\\sqsubset", true);
i(o, d, "â‰¼", "\\preccurlyeq", true);
i(o, d, "â‹", "\\curlyeqprec", true);
i(o, d, "â‰¾", "\\precsim", true);
i(o, d, "âª·", "\\precapprox", true);
i(o, d, "âŠ²", "\\vartriangleleft");
i(o, d, "âŠ´", "\\trianglelefteq");
i(o, d, "âŠ¨", "\\vDash", true);
i(o, d, "âŠ«", "\\VDash", true);
i(o, d, "âŠª", "\\Vvdash", true);
i(o, d, "âŒ£", "\\smallsmile");
i(o, d, "âŒ¢", "\\smallfrown");
i(o, d, "â‰", "\\bumpeq", true);
i(o, d, "â‰", "\\Bumpeq", true);
i(o, d, "â‰§", "\\geqq", true);
i(o, d, "â©¾", "\\geqslant", true);
i(o, d, "âª–", "\\eqslantgtr", true);
i(o, d, "â‰³", "\\gtrsim", true);
i(o, d, "âª†", "\\gtrapprox", true);
i(o, w, "â‹—", "\\gtrdot");
i(o, d, "â‹™", "\\ggg", true);
i(o, d, "â‰·", "\\gtrless", true);
i(o, d, "â‹›", "\\gtreqless", true);
i(o, d, "âªŒ", "\\gtreqqless", true);
i(o, d, "â‰–", "\\eqcirc", true);
i(o, d, "â‰—", "\\circeq", true);
i(o, d, "â‰œ", "\\triangleq", true);
i(o, d, "âˆ¼", "\\thicksim");
i(o, d, "â‰ˆ", "\\thickapprox");
i(o, d, "â«†", "\\supseteqq", true);
i(o, d, "â‹‘", "\\Supset", true);
i(o, d, "âŠ", "\\sqsupset", true);
i(o, d, "â‰½", "\\succcurlyeq", true);
i(o, d, "â‹Ÿ", "\\curlyeqsucc", true);
i(o, d, "â‰¿", "\\succsim", true);
i(o, d, "âª¸", "\\succapprox", true);
i(o, d, "âŠ³", "\\vartriangleright");
i(o, d, "âŠµ", "\\trianglerighteq");
i(o, d, "âŠ©", "\\Vdash", true);
i(o, d, "âˆ£", "\\shortmid");
i(o, d, "âˆ¥", "\\shortparallel");
i(o, d, "â‰¬", "\\between", true);
i(o, d, "â‹”", "\\pitchfork", true);
i(o, d, "âˆ", "\\varpropto");
i(o, d, "â—€", "\\blacktriangleleft");
i(o, d, "âˆ´", "\\therefore", true);
i(o, d, "âˆ", "\\backepsilon");
i(o, d, "â–¶", "\\blacktriangleright");
i(o, d, "âˆµ", "\\because", true);
i(o, d, "â‹˜", "\\llless");
i(o, d, "â‹™", "\\gggtr");
i(o, w, "âŠ²", "\\lhd");
i(o, w, "âŠ³", "\\rhd");
i(o, d, "â‰‚", "\\eqsim", true);
i(o, d, "â‰‘", "\\Doteq", true);
i(o, d, "â¥½", "\\strictif", true);
i(o, d, "â¥¼", "\\strictfi", true);
i(o, w, "âˆ”", "\\dotplus", true);
i(o, w, "âˆ–", "\\smallsetminus");
i(o, w, "â‹’", "\\Cap", true);
i(o, w, "â‹“", "\\Cup", true);
i(o, w, "â©", "\\doublebarwedge", true);
i(o, w, "âŠŸ", "\\boxminus", true);
i(o, w, "âŠ", "\\boxplus", true);
i(o, w, "â§„", "\\boxslash", true);
i(o, w, "â‹‡", "\\divideontimes", true);
i(o, w, "â‹‰", "\\ltimes", true);
i(o, w, "â‹Š", "\\rtimes", true);
i(o, w, "â‹‹", "\\leftthreetimes", true);
i(o, w, "â‹Œ", "\\rightthreetimes", true);
i(o, w, "â‹", "\\curlywedge", true);
i(o, w, "â‹", "\\curlyvee", true);
i(o, w, "âŠ", "\\circleddash", true);
i(o, w, "âŠ›", "\\circledast", true);
i(o, w, "âŠº", "\\intercal", true);
i(o, w, "â‹’", "\\doublecap");
i(o, w, "â‹“", "\\doublecup");
i(o, w, "âŠ ", "\\boxtimes", true);
i(o, w, "â‹ˆ", "\\bowtie", true);
i(o, w, "â‹ˆ", "\\Join");
i(o, w, "âŸ•", "\\leftouterjoin", true);
i(o, w, "âŸ–", "\\rightouterjoin", true);
i(o, w, "âŸ—", "\\fullouterjoin", true);
i(o, w, "âˆ¸", "\\dotminus", true);
i(o, w, "âŸ‘", "\\wedgedot", true);
i(o, w, "âŸ‡", "\\veedot", true);
i(o, w, "â©¢", "\\doublebarvee", true);
i(o, w, "â©£", "\\veedoublebar", true);
i(o, w, "â©Ÿ", "\\wedgebar", true);
i(o, w, "â© ", "\\wedgedoublebar", true);
i(o, w, "â©”", "\\Vee", true);
i(o, w, "â©“", "\\Wedge", true);
i(o, w, "â©ƒ", "\\barcap", true);
i(o, w, "â©‚", "\\barcup", true);
i(o, w, "â©ˆ", "\\capbarcup", true);
i(o, w, "â©€", "\\capdot", true);
i(o, w, "â©‡", "\\capovercup", true);
i(o, w, "â©†", "\\cupovercap", true);
i(o, w, "â©", "\\closedvarcap", true);
i(o, w, "â©Œ", "\\closedvarcup", true);
i(o, w, "â¨ª", "\\minusdot", true);
i(o, w, "â¨«", "\\minusfdots", true);
i(o, w, "â¨¬", "\\minusrdots", true);
i(o, w, "âŠ»", "\\Xor", true);
i(o, w, "âŠ¼", "\\Nand", true);
i(o, w, "âŠ½", "\\Nor", true);
i(o, w, "âŠ½", "\\barvee");
i(o, w, "â«´", "\\interleave", true);
i(o, w, "â§¢", "\\shuffle", true);
i(o, w, "â«¶", "\\threedotcolon", true);
i(o, w, "â¦‚", "\\typecolon", true);
i(o, w, "âˆ¾", "\\invlazys", true);
i(o, w, "â©‹", "\\twocaps", true);
i(o, w, "â©Š", "\\twocups", true);
i(o, w, "â©", "\\Sqcap", true);
i(o, w, "â©", "\\Sqcup", true);
i(o, w, "â©–", "\\veeonvee", true);
i(o, w, "â©•", "\\wedgeonwedge", true);
i(o, w, "â§—", "\\blackhourglass", true);
i(o, w, "â§†", "\\boxast", true);
i(o, w, "â§ˆ", "\\boxbox", true);
i(o, w, "â§‡", "\\boxcircle", true);
i(o, w, "âŠœ", "\\circledequal", true);
i(o, w, "â¦·", "\\circledparallel", true);
i(o, w, "â¦¶", "\\circledvert", true);
i(o, w, "â¦µ", "\\circlehbar", true);
i(o, w, "âŸ¡", "\\concavediamond", true);
i(o, w, "âŸ¢", "\\concavediamondtickleft", true);
i(o, w, "âŸ£", "\\concavediamondtickright", true);
i(o, w, "â‹„", "\\diamond", true);
i(o, w, "â§–", "\\hourglass", true);
i(o, w, "âŸ ", "\\lozengeminus", true);
i(o, w, "âŒ½", "\\obar", true);
i(o, w, "â¦¸", "\\obslash", true);
i(o, w, "â¨¸", "\\odiv", true);
i(o, w, "â§", "\\ogreaterthan", true);
i(o, w, "â§€", "\\olessthan", true);
i(o, w, "â¦¹", "\\operp", true);
i(o, w, "â¨·", "\\Otimes", true);
i(o, w, "â¨¶", "\\otimeshat", true);
i(o, w, "â‹†", "\\star", true);
i(o, w, "â–³", "\\triangle", true);
i(o, w, "â¨º", "\\triangleminus", true);
i(o, w, "â¨¹", "\\triangleplus", true);
i(o, w, "â¨»", "\\triangletimes", true);
i(o, w, "âŸ¤", "\\whitesquaretickleft", true);
i(o, w, "âŸ¥", "\\whitesquaretickright", true);
i(o, w, "â¨³", "\\smashtimes", true);
i(o, d, "â‡¢", "\\dashrightarrow", true);
i(o, d, "â‡ ", "\\dashleftarrow", true);
i(o, d, "â‡‡", "\\leftleftarrows", true);
i(o, d, "â‡†", "\\leftrightarrows", true);
i(o, d, "â‡š", "\\Lleftarrow", true);
i(o, d, "â†", "\\twoheadleftarrow", true);
i(o, d, "â†¢", "\\leftarrowtail", true);
i(o, d, "â†«", "\\looparrowleft", true);
i(o, d, "â‡‹", "\\leftrightharpoons", true);
i(o, d, "â†¶", "\\curvearrowleft", true);
i(o, d, "â†º", "\\circlearrowleft", true);
i(o, d, "â†°", "\\Lsh", true);
i(o, d, "â‡ˆ", "\\upuparrows", true);
i(o, d, "â†¿", "\\upharpoonleft", true);
i(o, d, "â‡ƒ", "\\downharpoonleft", true);
i(o, d, "âŠ¶", "\\origof", true);
i(o, d, "âŠ·", "\\imageof", true);
i(o, d, "âŠ¸", "\\multimap", true);
i(o, d, "â†­", "\\leftrightsquigarrow", true);
i(o, d, "â‡‰", "\\rightrightarrows", true);
i(o, d, "â‡„", "\\rightleftarrows", true);
i(o, d, "â† ", "\\twoheadrightarrow", true);
i(o, d, "â†£", "\\rightarrowtail", true);
i(o, d, "â†¬", "\\looparrowright", true);
i(o, d, "â†·", "\\curvearrowright", true);
i(o, d, "â†»", "\\circlearrowright", true);
i(o, d, "â†±", "\\Rsh", true);
i(o, d, "â‡Š", "\\downdownarrows", true);
i(o, d, "â†¾", "\\upharpoonright", true);
i(o, d, "â‡‚", "\\downharpoonright", true);
i(o, d, "â‡", "\\rightsquigarrow", true);
i(o, d, "â‡", "\\leadsto");
i(o, d, "â‡›", "\\Rrightarrow", true);
i(o, d, "â†¾", "\\restriction");
i(o, f, "â€˜", "`");
i(o, f, "$", "\\$");
i(_, f, "$", "\\$");
i(_, f, "$", "\\textdollar");
i(o, f, "Â¢", "\\cent");
i(_, f, "Â¢", "\\cent");
i(o, f, "%", "\\%");
i(_, f, "%", "\\%");
i(o, f, "_", "\\_");
i(_, f, "_", "\\_");
i(_, f, "_", "\\textunderscore");
i(_, f, "â£", "\\textvisiblespace", true);
i(o, f, "âˆ ", "\\angle", true);
i(o, f, "âˆ", "\\infty", true);
i(o, f, "â€²", "\\prime");
i(o, f, "â€³", "\\dprime");
i(o, f, "â€´", "\\trprime");
i(o, f, "â—", "\\qprime");
i(o, f, "â–³", "\\triangle");
i(_, f, "Î‘", "\\Alpha", true);
i(_, f, "Î’", "\\Beta", true);
i(_, f, "Î“", "\\Gamma", true);
i(_, f, "Î”", "\\Delta", true);
i(_, f, "Î•", "\\Epsilon", true);
i(_, f, "Î–", "\\Zeta", true);
i(_, f, "Î—", "\\Eta", true);
i(_, f, "Î˜", "\\Theta", true);
i(_, f, "Î™", "\\Iota", true);
i(_, f, "Îš", "\\Kappa", true);
i(_, f, "Î›", "\\Lambda", true);
i(_, f, "Îœ", "\\Mu", true);
i(_, f, "Î", "\\Nu", true);
i(_, f, "Î", "\\Xi", true);
i(_, f, "ÎŸ", "\\Omicron", true);
i(_, f, "Î ", "\\Pi", true);
i(_, f, "Î¡", "\\Rho", true);
i(_, f, "Î£", "\\Sigma", true);
i(_, f, "Î¤", "\\Tau", true);
i(_, f, "Î¥", "\\Upsilon", true);
i(_, f, "Î¦", "\\Phi", true);
i(_, f, "Î§", "\\Chi", true);
i(_, f, "Î¨", "\\Psi", true);
i(_, f, "Î©", "\\Omega", true);
i(o, O, "Î‘", "\\Alpha", true);
i(o, O, "Î’", "\\Beta", true);
i(o, O, "Î“", "\\Gamma", true);
i(o, O, "Î”", "\\Delta", true);
i(o, O, "Î•", "\\Epsilon", true);
i(o, O, "Î–", "\\Zeta", true);
i(o, O, "Î—", "\\Eta", true);
i(o, O, "Î˜", "\\Theta", true);
i(o, O, "Î™", "\\Iota", true);
i(o, O, "Îš", "\\Kappa", true);
i(o, O, "Î›", "\\Lambda", true);
i(o, O, "Îœ", "\\Mu", true);
i(o, O, "Î", "\\Nu", true);
i(o, O, "Î", "\\Xi", true);
i(o, O, "ÎŸ", "\\Omicron", true);
i(o, O, "Î ", "\\Pi", true);
i(o, O, "Î¡", "\\Rho", true);
i(o, O, "Î£", "\\Sigma", true);
i(o, O, "Î¤", "\\Tau", true);
i(o, O, "Î¥", "\\Upsilon", true);
i(o, O, "Î¦", "\\Phi", true);
i(o, O, "Î§", "\\Chi", true);
i(o, O, "Î¨", "\\Psi", true);
i(o, O, "Î©", "\\Omega", true);
i(o, ut, "Â¬", "\\neg", true);
i(o, ut, "Â¬", "\\lnot");
i(o, f, "âŠ¤", "\\top");
i(o, f, "âŠ¥", "\\bot");
i(o, f, "âˆ…", "\\emptyset");
i(o, f, "âŒ€", "\\varnothing");
i(o, O, "Î±", "\\alpha", true);
i(o, O, "Î²", "\\beta", true);
i(o, O, "Î³", "\\gamma", true);
i(o, O, "Î´", "\\delta", true);
i(o, O, "Ïµ", "\\epsilon", true);
i(o, O, "Î¶", "\\zeta", true);
i(o, O, "Î·", "\\eta", true);
i(o, O, "Î¸", "\\theta", true);
i(o, O, "Î¹", "\\iota", true);
i(o, O, "Îº", "\\kappa", true);
i(o, O, "Î»", "\\lambda", true);
i(o, O, "Î¼", "\\mu", true);
i(o, O, "Î½", "\\nu", true);
i(o, O, "Î¾", "\\xi", true);
i(o, O, "Î¿", "\\omicron", true);
i(o, O, "Ï€", "\\pi", true);
i(o, O, "Ï", "\\rho", true);
i(o, O, "Ïƒ", "\\sigma", true);
i(o, O, "Ï„", "\\tau", true);
i(o, O, "Ï…", "\\upsilon", true);
i(o, O, "Ï•", "\\phi", true);
i(o, O, "Ï‡", "\\chi", true);
i(o, O, "Ïˆ", "\\psi", true);
i(o, O, "Ï‰", "\\omega", true);
i(o, O, "Îµ", "\\varepsilon", true);
i(o, O, "Ï‘", "\\vartheta", true);
i(o, O, "Ï–", "\\varpi", true);
i(o, O, "Ï±", "\\varrho", true);
i(o, O, "Ï‚", "\\varsigma", true);
i(o, O, "Ï†", "\\varphi", true);
i(o, O, "Ï˜", "\\Coppa", true);
i(o, O, "Ï™", "\\coppa", true);
i(o, O, "Ï™", "\\varcoppa", true);
i(o, O, "Ï", "\\Koppa", true);
i(o, O, "ÏŸ", "\\koppa", true);
i(o, O, "Ï ", "\\Sampi", true);
i(o, O, "Ï¡", "\\sampi", true);
i(o, O, "Ïš", "\\Stigma", true);
i(o, O, "Ï›", "\\stigma", true);
i(o, O, "â««", "\\Bot");
i(o, w, "âˆ—", "âˆ—", true);
i(o, w, "+", "+");
i(o, w, "*", "*");
i(o, w, "â„", "/", true);
i(o, w, "â„", "â„");
i(o, w, "âˆ’", "-", true);
i(o, w, "â‹…", "\\cdot", true);
i(o, w, "âˆ˜", "\\circ", true);
i(o, w, "Ã·", "\\div", true);
i(o, w, "Â±", "\\pm", true);
i(o, w, "Ã—", "\\times", true);
i(o, w, "âˆ©", "\\cap", true);
i(o, w, "âˆª", "\\cup", true);
i(o, w, "âˆ–", "\\setminus", true);
i(o, w, "âˆ§", "\\land");
i(o, w, "âˆ¨", "\\lor");
i(o, w, "âˆ§", "\\wedge", true);
i(o, w, "âˆ¨", "\\vee", true);
i(o, ut, "âŸ¦", "\\llbracket", true);
i(o, at, "âŸ§", "\\rrbracket", true);
i(o, ut, "âŸ¨", "\\langle", true);
i(o, ut, "âŸª", "\\lAngle", true);
i(o, ut, "â¦‰", "\\llangle", true);
i(o, ut, "|", "\\lvert");
i(o, ut, "â€–", "\\lVert");
i(o, f, "!", "\\oc");
i(o, f, "?", "\\wn");
i(o, f, "â†“", "\\shpos");
i(o, f, "â†•", "\\shift");
i(o, f, "â†‘", "\\shneg");
i(o, at, "?", "?");
i(o, at, "!", "!");
i(o, at, "â€¼", "â€¼");
i(o, at, "âŸ©", "\\rangle", true);
i(o, at, "âŸ«", "\\rAngle", true);
i(o, at, "â¦Š", "\\rrangle", true);
i(o, at, "|", "\\rvert");
i(o, at, "â€–", "\\rVert");
i(o, ut, "â¦ƒ", "\\lBrace", true);
i(o, at, "â¦„", "\\rBrace", true);
i(o, d, "=", "\\equal", true);
i(o, d, ":", ":");
i(o, d, "â‰ˆ", "\\approx", true);
i(o, d, "â‰…", "\\cong", true);
i(o, d, "â‰¥", "\\ge");
i(o, d, "â‰¥", "\\geq", true);
i(o, d, "â†", "\\gets");
i(o, d, ">", "\\gt", true);
i(o, d, "âˆˆ", "\\in", true);
i(o, d, "âˆ‰", "\\notin", true);
i(o, d, "î€ ", "\\@not");
i(o, d, "âŠ‚", "\\subset", true);
i(o, d, "âŠƒ", "\\supset", true);
i(o, d, "âŠ†", "\\subseteq", true);
i(o, d, "âŠ‡", "\\supseteq", true);
i(o, d, "âŠˆ", "\\nsubseteq", true);
i(o, d, "âŠˆ", "\\nsubseteqq");
i(o, d, "âŠ‰", "\\nsupseteq", true);
i(o, d, "âŠ‰", "\\nsupseteqq");
i(o, d, "âŠ¨", "\\models");
i(o, d, "â†", "\\leftarrow", true);
i(o, d, "â‰¤", "\\le");
i(o, d, "â‰¤", "\\leq", true);
i(o, d, "<", "\\lt", true);
i(o, d, "â†’", "\\rightarrow", true);
i(o, d, "â†’", "\\to");
i(o, d, "â‰±", "\\ngeq", true);
i(o, d, "â‰±", "\\ngeqq");
i(o, d, "â‰±", "\\ngeqslant");
i(o, d, "â‰°", "\\nleq", true);
i(o, d, "â‰°", "\\nleqq");
i(o, d, "â‰°", "\\nleqslant");
i(o, d, "â««", "\\Perp", true);
i(o, qt, "Â ", "\\ ");
i(o, qt, "Â ", "\\space");
i(o, qt, "Â ", "\\nobreakspace");
i(_, qt, "Â ", "\\ ");
i(_, qt, "Â ", " ");
i(_, qt, "Â ", "\\space");
i(_, qt, "Â ", "\\nobreakspace");
i(o, qt, null, "\\nobreak");
i(o, qt, null, "\\allowbreak");
i(o, Jt, ",", ",");
i(_, Jt, ":", ":");
i(o, Jt, ";", ";");
i(o, w, "âŠ¼", "\\barwedge");
i(o, w, "âŠ»", "\\veebar");
i(o, w, "âŠ™", "\\odot", true);
i(o, w, "âŠ•ï¸", "\\oplus");
i(o, w, "âŠ—", "\\otimes", true);
i(o, f, "âˆ‚", "\\partial", true);
i(o, w, "âŠ˜", "\\oslash", true);
i(o, w, "âŠš", "\\circledcirc", true);
i(o, w, "âŠ¡", "\\boxdot", true);
i(o, w, "â–³", "\\bigtriangleup");
i(o, w, "â–½", "\\bigtriangledown");
i(o, w, "â€ ", "\\dagger");
i(o, w, "â‹„", "\\diamond");
i(o, w, "â—ƒ", "\\triangleleft");
i(o, w, "â–¹", "\\triangleright");
i(o, ut, "{", "\\{");
i(_, f, "{", "\\{");
i(_, f, "{", "\\textbraceleft");
i(o, at, "}", "\\}");
i(_, f, "}", "\\}");
i(_, f, "}", "\\textbraceright");
i(o, ut, "{", "\\lbrace");
i(o, at, "}", "\\rbrace");
i(o, ut, "[", "\\lbrack", true);
i(_, f, "[", "\\lbrack", true);
i(o, at, "]", "\\rbrack", true);
i(_, f, "]", "\\rbrack", true);
i(o, ut, "(", "\\lparen", true);
i(o, at, ")", "\\rparen", true);
i(o, ut, "â¦‡", "\\llparenthesis", true);
i(o, at, "â¦ˆ", "\\rrparenthesis", true);
i(_, f, "<", "\\textless", true);
i(_, f, ">", "\\textgreater", true);
i(o, ut, "âŒŠ", "\\lfloor", true);
i(o, at, "âŒ‹", "\\rfloor", true);
i(o, ut, "âŒˆ", "\\lceil", true);
i(o, at, "âŒ‰", "\\rceil", true);
i(o, f, "\\", "\\backslash");
i(o, f, "|", "|");
i(o, f, "|", "\\vert");
i(_, f, "|", "\\textbar", true);
i(o, f, "â€–", "\\|");
i(o, f, "â€–", "\\Vert");
i(_, f, "â€–", "\\textbardbl");
i(_, f, "~", "\\textasciitilde");
i(_, f, "\\", "\\textbackslash");
i(_, f, "^", "\\textasciicircum");
i(o, d, "â†‘", "\\uparrow", true);
i(o, d, "â‡‘", "\\Uparrow", true);
i(o, d, "â†“", "\\downarrow", true);
i(o, d, "â‡“", "\\Downarrow", true);
i(o, d, "â†•", "\\updownarrow", true);
i(o, d, "â‡•", "\\Updownarrow", true);
i(o, G, "âˆ", "\\coprod");
i(o, G, "â‹", "\\bigvee");
i(o, G, "â‹€", "\\bigwedge");
i(o, G, "â¨„", "\\biguplus");
i(o, G, "â¨„", "\\bigcupplus");
i(o, G, "â¨ƒ", "\\bigcupdot");
i(o, G, "â¨‡", "\\bigdoublevee");
i(o, G, "â¨ˆ", "\\bigdoublewedge");
i(o, G, "â‹‚", "\\bigcap");
i(o, G, "â‹ƒ", "\\bigcup");
i(o, G, "âˆ«", "\\int");
i(o, G, "âˆ«", "\\intop");
i(o, G, "âˆ¬", "\\iint");
i(o, G, "âˆ­", "\\iiint");
i(o, G, "âˆ", "\\prod");
i(o, G, "âˆ‘", "\\sum");
i(o, G, "â¨‚", "\\bigotimes");
i(o, G, "â¨", "\\bigoplus");
i(o, G, "â¨€", "\\bigodot");
i(o, G, "â¨‰", "\\bigtimes");
i(o, G, "âˆ®", "\\oint");
i(o, G, "âˆ¯", "\\oiint");
i(o, G, "âˆ°", "\\oiiint");
i(o, G, "âˆ±", "\\intclockwise");
i(o, G, "âˆ²", "\\varointclockwise");
i(o, G, "â¨Œ", "\\iiiint");
i(o, G, "â¨", "\\intbar");
i(o, G, "â¨", "\\intBar");
i(o, G, "â¨", "\\fint");
i(o, G, "â¨’", "\\rppolint");
i(o, G, "â¨“", "\\scpolint");
i(o, G, "â¨•", "\\pointint");
i(o, G, "â¨–", "\\sqint");
i(o, G, "â¨—", "\\intlarhk");
i(o, G, "â¨˜", "\\intx");
i(o, G, "â¨™", "\\intcap");
i(o, G, "â¨š", "\\intcup");
i(o, G, "â¨…", "\\bigsqcap");
i(o, G, "â¨†", "\\bigsqcup");
i(o, G, "âˆ«", "\\smallint");
i(_, jt, "â€¦", "\\textellipsis");
i(o, jt, "â€¦", "\\mathellipsis");
i(_, jt, "â€¦", "\\ldots", true);
i(o, jt, "â€¦", "\\ldots", true);
i(o, jt, "â‹°", "\\iddots", true);
i(o, jt, "â‹¯", "\\@cdots", true);
i(o, jt, "â‹±", "\\ddots", true);
i(o, f, "â‹®", "\\varvdots");
i(o, V, "ËŠ", "\\acute");
i(o, V, "`", "\\grave");
i(o, V, "Â¨", "\\ddot");
i(o, V, "â€¦", "\\dddot");
i(o, V, "â€¦.", "\\ddddot");
i(o, V, "~", "\\tilde");
i(o, V, "â€¾", "\\bar");
i(o, V, "Ë˜", "\\breve");
i(o, V, "Ë‡", "\\check");
i(o, V, "^", "\\hat");
i(o, V, "â†’", "\\vec");
i(o, V, "Ë™", "\\dot");
i(o, V, "Ëš", "\\mathring");
i(o, O, "Ä±", "\\imath", true);
i(o, O, "È·", "\\jmath", true);
i(o, f, "Ä±", "Ä±");
i(o, f, "È·", "È·");
i(_, f, "Ä±", "\\i", true);
i(_, f, "È·", "\\j", true);
i(_, f, "ÃŸ", "\\ss", true);
i(_, f, "Ã¦", "\\ae", true);
i(_, f, "Å“", "\\oe", true);
i(_, f, "Ã¸", "\\o", true);
i(o, O, "Ã¸", "\\o", true);
i(_, f, "Ã†", "\\AE", true);
i(_, f, "Å’", "\\OE", true);
i(_, f, "Ã˜", "\\O", true);
i(o, O, "Ã˜", "\\O", true);
i(_, V, "ËŠ", "\\'");
i(_, V, "Ë‹", "\\`");
i(_, V, "Ë†", "\\^");
i(_, V, "Ëœ", "\\~");
i(_, V, "Ë‰", "\\=");
i(_, V, "Ë˜", "\\u");
i(_, V, "Ë™", "\\.");
i(_, V, "Â¸", "\\c");
i(_, V, "Ëš", "\\r");
i(_, V, "Ë‡", "\\v");
i(_, V, "Â¨", '\\"');
i(_, V, "Ë", "\\H");
i(o, V, "ËŠ", "\\'");
i(o, V, "Ë‹", "\\`");
i(o, V, "Ë†", "\\^");
i(o, V, "Ëœ", "\\~");
i(o, V, "Ë‰", "\\=");
i(o, V, "Ë˜", "\\u");
i(o, V, "Ë™", "\\.");
i(o, V, "Â¸", "\\c");
i(o, V, "Ëš", "\\r");
i(o, V, "Ë‡", "\\v");
i(o, V, "Â¨", '\\"');
i(o, V, "Ë", "\\H");
var Bs = {
  "--": true,
  "---": true,
  "``": true,
  "''": true
};
i(_, f, "â€“", "--", true);
i(_, f, "â€“", "\\textendash");
i(_, f, "â€”", "---", true);
i(_, f, "â€”", "\\textemdash");
i(_, f, "â€˜", "`", true);
i(_, f, "â€˜", "\\textquoteleft");
i(_, f, "â€™", "'", true);
i(_, f, "â€™", "\\textquoteright");
i(_, f, "â€œ", "``", true);
i(_, f, "â€œ", "\\textquotedblleft");
i(_, f, "â€", "''", true);
i(_, f, "â€", "\\textquotedblright");
i(o, f, "Â°", "\\degree", true);
i(_, f, "Â°", "\\degree");
i(_, f, "Â°", "\\textdegree", true);
i(o, f, "Â£", "\\pounds");
i(o, f, "Â£", "\\mathsterling", true);
i(_, f, "Â£", "\\pounds");
i(_, f, "Â£", "\\textsterling", true);
i(o, f, "âœ ", "\\maltese");
i(_, f, "âœ ", "\\maltese");
i(o, f, "â‚¬", "\\euro", true);
i(_, f, "â‚¬", "\\euro", true);
i(_, f, "â‚¬", "\\texteuro");
i(o, f, "Â©", "\\copyright", true);
i(_, f, "Â©", "\\textcopyright");
i(o, f, "âŒ€", "\\diameter", true);
i(_, f, "âŒ€", "\\diameter");
i(o, f, "ğ›¤", "\\varGamma");
i(o, f, "ğ›¥", "\\varDelta");
i(o, f, "ğ›©", "\\varTheta");
i(o, f, "ğ›¬", "\\varLambda");
i(o, f, "ğ›¯", "\\varXi");
i(o, f, "ğ›±", "\\varPi");
i(o, f, "ğ›´", "\\varSigma");
i(o, f, "ğ›¶", "\\varUpsilon");
i(o, f, "ğ›·", "\\varPhi");
i(o, f, "ğ›¹", "\\varPsi");
i(o, f, "ğ›º", "\\varOmega");
i(_, f, "ğ›¤", "\\varGamma");
i(_, f, "ğ›¥", "\\varDelta");
i(_, f, "ğ›©", "\\varTheta");
i(_, f, "ğ›¬", "\\varLambda");
i(_, f, "ğ›¯", "\\varXi");
i(_, f, "ğ›±", "\\varPi");
i(_, f, "ğ›´", "\\varSigma");
i(_, f, "ğ›¶", "\\varUpsilon");
i(_, f, "ğ›·", "\\varPhi");
i(_, f, "ğ›¹", "\\varPsi");
i(_, f, "ğ›º", "\\varOmega");
var qn = '0123456789/@."';
for (let t = 0; t < qn.length; t++) {
  const e = qn.charAt(t);
  i(o, f, e, e);
}
var Mn = '0123456789!@*()-=+";:?/.,';
for (let t = 0; t < Mn.length; t++) {
  const e = Mn.charAt(t);
  i(_, f, e, e);
}
var ye = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (let t = 0; t < ye.length; t++) {
  const e = ye.charAt(t);
  i(o, O, e, e), i(_, f, e, e);
}
var On = "Ã‡ÃÃÃ§Ã¾â„‚â„â„•â„™â„šâ„â„¤â„â„â„Šâ„‹â„Œâ„â„‘â„’â„“â„˜â„›â„œâ„¬â„°â„±â„³â„­â„¨";
for (let t = 0; t < On.length; t++) {
  const e = On.charAt(t);
  i(o, O, e, e), i(_, f, e, e);
}
var I = "";
for (let t = 0; t < ye.length; t++) {
  I = String.fromCharCode(55349, 56320 + t), i(o, O, I, I), i(_, f, I, I), I = String.fromCharCode(55349, 56372 + t), i(o, O, I, I), i(_, f, I, I), I = String.fromCharCode(55349, 56424 + t), i(o, O, I, I), i(_, f, I, I), I = String.fromCharCode(55349, 56580 + t), i(o, O, I, I), i(_, f, I, I), I = String.fromCharCode(55349, 56736 + t), i(o, O, I, I), i(_, f, I, I), I = String.fromCharCode(55349, 56788 + t), i(o, O, I, I), i(_, f, I, I), I = String.fromCharCode(55349, 56840 + t), i(o, O, I, I), i(_, f, I, I), I = String.fromCharCode(55349, 56944 + t), i(o, O, I, I), i(_, f, I, I), I = String.fromCharCode(55349, 56632 + t), i(o, O, I, I), i(_, f, I, I);
  const e = ye.charAt(t);
  I = String.fromCharCode(55349, 56476 + t), i(o, O, e, I), i(_, f, e, I);
}
for (let t = 0; t < 10; t++)
  I = String.fromCharCode(55349, 57294 + t), i(o, O, I, I), i(_, f, I, I), I = String.fromCharCode(55349, 57314 + t), i(o, O, I, I), i(_, f, I, I), I = String.fromCharCode(55349, 57324 + t), i(o, O, I, I), i(_, f, I, I), I = String.fromCharCode(55349, 57334 + t), i(o, O, I, I), i(_, f, I, I);
var Ls = "([{âŒŠâŒˆâŸ¨âŸ®â°âŸ¦â¦ƒ";
var Fs = ")]}âŒ‹âŒ‰âŸ©âŸ¯â±âŸ¦â¦„";
function zs(t, e, n) {
  const r = [];
  let s = [], a = [], l = 0, u = 0, c = 0;
  for (; u < t.length; ) {
    for (; t[u] instanceof un; )
      t.splice(u, 1, ...t[u].children);
    const m = t[u];
    if (m.attributes && m.attributes.linebreak && m.attributes.linebreak === "newline") {
      a.length > 0 && s.push(new y.MathNode("mrow", a)), s.push(m), a = [];
      const b = new y.MathNode("mtd", s);
      b.style.textAlign = "left", r.push(new y.MathNode("mtr", [b])), s = [], u += 1;
      continue;
    }
    if (a.push(m), m.type && m.type === "mo" && m.children.length === 1 && !Object.hasOwn(m.attributes, "movablelimits")) {
      const b = m.children[0].text;
      if (Ls.indexOf(b) > -1)
        c += 1;
      else if (Fs.indexOf(b) > -1)
        c -= 1;
      else if (c === 0 && e === "=" && b === "=") {
        if (l += 1, l > 1) {
          a.pop();
          const A = new y.MathNode("mrow", a);
          s.push(A), a = [m];
        }
      } else if (c === 0 && e === "tex" && b !== "âˆ‡") {
        const A = u < t.length - 1 ? t[u + 1] : null;
        let x = true;
        if (!(A && A.type === "mtext" && A.attributes.linebreak && A.attributes.linebreak === "nobreak"))
          for (let T = u + 1; T < t.length; T++) {
            const D = t[T];
            if (D.type && D.type === "mspace" && !(D.attributes.linebreak && D.attributes.linebreak === "newline"))
              a.push(D), u += 1, D.attributes && D.attributes.linebreak && D.attributes.linebreak === "nobreak" && (x = false);
            else
              break;
          }
        if (x) {
          const T = new y.MathNode("mrow", a);
          s.push(T), a = [];
        }
      }
    }
    u += 1;
  }
  if (a.length > 0) {
    const m = new y.MathNode("mrow", a);
    s.push(m);
  }
  if (r.length > 0) {
    const m = new y.MathNode("mtd", s);
    m.style.textAlign = "left";
    const b = new y.MathNode("mtr", [m]);
    r.push(b);
    const A = new y.MathNode("mtable", r);
    return n || (A.setAttribute("columnalign", "left"), A.setAttribute("rowspacing", "0em")), A;
  }
  return y.newDocumentFragment(s);
}
var ft = function(t, e, n) {
  return lt[e][t] && lt[e][t].replace && t.charCodeAt(0) !== 55349 && !(Object.prototype.hasOwnProperty.call(Bs, t) && n && (n.fontFamily && n.fontFamily.slice(4, 6) === "tt" || n.font && n.font.slice(4, 6) === "tt")) && (t = lt[e][t].replace), new y.TextNode(t);
};
var En = (t, e) => {
  if (t.children.length === 0 || t.children[t.children.length - 1].type !== "mtext") {
    const n = new y.MathNode(
      "mtext",
      [new y.TextNode(e.children[0].text)]
    );
    t.children.push(n);
  } else
    t.children[t.children.length - 1].children[0].text += e.children[0].text;
};
var hn = (t) => {
  if (t.type !== "mrow" && t.type !== "mstyle" || t.children.length === 0)
    return t;
  const e = new y.MathNode("mrow");
  for (let n = 0; n < t.children.length; n++) {
    const r = t.children[n];
    if (r.type === "mtext" && Object.keys(r.attributes).length === 0)
      En(e, r);
    else if (r.type === "mrow") {
      let s = true;
      for (let a = 0; a < r.children.length; a++)
        if (r.children[a].type !== "mtext" || Object.keys(r.attributes).length !== 0) {
          s = false;
          break;
        }
      if (s)
        for (let a = 0; a < r.children.length; a++) {
          const l = r.children[a];
          En(e, l);
        }
      else
        e.children.push(r);
    } else
      e.children.push(r);
  }
  for (let n = 0; n < e.children.length; n++)
    if (e.children[n].type === "mtext") {
      const r = e.children[n];
      r.children[0].text.charAt(0) === " " && (r.children[0].text = "Â " + r.children[0].text.slice(1));
      const s = r.children[0].text.length;
      s > 0 && r.children[0].text.charAt(s - 1) === " " && (r.children[0].text = r.children[0].text.slice(0, -1) + "Â ");
      for (const [a, l] of Object.entries(t.attributes))
        r.attributes[a] = l;
    }
  return e.children.length === 1 && e.children[0].type === "mtext" ? e.children[0] : e;
};
var $n = /^[0-9]$/;
var js = (t, e) => (t.type === "textord" && t.text === "." || t.type === "atom" && t.text === ",") && // Don't consolidate if there is a space after the comma.
t.loc && e.loc && t.loc.end === e.loc.start;
var Gs = (t) => {
  if (t.length < 2)
    return;
  const e = [];
  let n = false;
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    s.type === "textord" && $n.test(s.text) ? (n || e.push({ start: r }), n = true) : (n && (e[e.length - 1].end = r - 1), n = false);
  }
  n && (e[e.length - 1].end = t.length - 1);
  for (let r = e.length - 1; r > 0; r--)
    e[r - 1].end === e[r].start - 2 && js(t[e[r].start - 1], t[e[r].start]) && (e[r - 1].end = e[r].end, e.splice(r, 1));
  for (let r = e.length - 1; r >= 0; r--) {
    for (let s = e[r].start + 1; s <= e[r].end; s++)
      t[e[r].start].text += t[s].text;
    if (t.splice(e[r].start + 1, e[r].end - e[r].start), t.length > e[r].start + 1) {
      const s = t[e[r].start + 1];
      s.type === "supsub" && s.base && s.base.type === "textord" && $n.test(s.base.text) && (s.base.text = t[e[r].start].text + s.base.text, t.splice(e[r].start, 1));
    }
  }
};
var dn = function(t, e = false) {
  if (t.length === 1 && !(t[0] instanceof un))
    return t[0];
  if (!e) {
    t[0] instanceof ht && t[0].type === "mo" && !t[0].attributes.fence && (t[0].attributes.lspace = "0em", t[0].attributes.rspace = "0em");
    const n = t.length - 1;
    t[n] instanceof ht && t[n].type === "mo" && !t[n].attributes.fence && (t[n].attributes.lspace = "0em", t[n].attributes.rspace = "0em");
  }
  return new y.MathNode("mrow", t);
};
var ce = (t) => t.type === "atom" && t.family === "rel" || t.type === "mclass" && t.mclass === "mrel";
var dt = function(t, e, n = false) {
  if (!n && t.length === 1) {
    const s = et(t[0], e);
    return s instanceof ht && s.type === "mo" && (s.setAttribute("lspace", "0em"), s.setAttribute("rspace", "0em")), [s];
  }
  Gs(t);
  const r = [];
  for (let s = 0; s < t.length; s++) {
    const a = et(t[s], e);
    s < t.length - 1 && ce(t[s]) && ce(t[s + 1]) && a.setAttribute("rspace", "0em"), s > 0 && ce(t[s]) && ce(t[s - 1]) && a.setAttribute("lspace", "0em"), r.push(a);
  }
  return r;
};
var Mt = function(t, e, n = false) {
  return dn(dt(t, e, n), n);
};
var et = function(t, e) {
  if (!t)
    return new y.MathNode("mrow");
  if (be[t.type])
    return be[t.type](t, e);
  throw new q("Got group of unknown type: '" + t.type + "'");
};
var In = (t) => new y.MathNode("mtd", [], [], { padding: "0", width: "50%" });
var Rs = (t, e, n, r) => {
  e = Mt(e[0].body, n), e = hn(e), e.classes.push("tml-tag"), t = new y.MathNode("mtd", [t]);
  const s = [In(), t, In()];
  s[r ? 0 : 2].classes.push(r ? "tml-left" : "tml-right"), s[r ? 0 : 2].children.push(e);
  const a = new y.MathNode("mtr", s, ["tml-tageqn"]), l = new y.MathNode("mtable", [a]);
  return l.style.width = "100%", l.setAttribute("displaystyle", "true"), l;
};
function Us(t, e, n, r) {
  let s = null;
  t.length === 1 && t[0].type === "tag" && (s = t[0].tag, t = t[0].body);
  const a = dt(t, n), l = r.displayMode || r.annotate ? "none" : r.wrap, u = a.length === 0 ? null : a[0];
  let c = a.length === 1 && s === null && u instanceof ht ? a[0] : zs(a, l, r.displayMode);
  if (s && (c = Rs(c, s, n, r.leqno)), r.annotate) {
    const b = new y.MathNode(
      "annotation",
      [new y.TextNode(e)]
    );
    b.setAttribute("encoding", "application/x-tex"), c = new y.MathNode("semantics", [c, b]);
  }
  const m = new y.MathNode("math", [c]);
  return r.xml && m.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), r.displayMode && (m.setAttribute("display", "block"), m.style.display = "block math", m.classes = ["tml-display"]), m;
}
var Mr = "acegÄ±È·mnopqrsuvwxyzÎ±Î³ÎµÎ·Î¹ÎºÎ¼Î½Î¿Ï€ÏÏ‚ÏƒÏ„Ï…Ï‡Ï‰Ï•ğšğœğğ ğ¦ğ§ğ¨ğ©ğªğ«ğ¬ğ®ğ¯ğ°ğ±ğ²ğ³";
var Ws = "ABCDEFGHIJKLMNOPQRSTUVWXYZbdfhkltÎ‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎÎŸÎ Î¡Î£Î¤Î¥Î¦Î§Î¨Î©Î²Î´Î»Î¶Ï†Î¸Ïˆğ€ğğ‚ğƒğ„ğ…ğ†ğ‡ğˆğ‰ğŠğ‹ğŒğğğğğ‘ğ’ğ“ğ”ğ•ğ–ğ—ğ˜ğ™ğ›ğğŸğ¡ğ¤ğ¥ğ­";
var Vs = /* @__PURE__ */ new Set([
  "\\alpha",
  "\\gamma",
  "\\delta",
  "\\epsilon",
  "\\eta",
  "\\iota",
  "\\kappa",
  "\\mu",
  "\\nu",
  "\\pi",
  "\\rho",
  "\\sigma",
  "\\tau",
  "\\upsilon",
  "\\chi",
  "\\psi",
  "\\omega",
  "\\imath",
  "\\jmath"
]);
var Hs = /* @__PURE__ */ new Set([
  "\\Gamma",
  "\\Delta",
  "\\Sigma",
  "\\Omega",
  "\\beta",
  "\\delta",
  "\\lambda",
  "\\theta",
  "\\psi"
]);
var Or = (t, e) => {
  const n = t.isStretchy ? Ae.accentNode(t) : new y.MathNode("mo", [ft(t.label, t.mode)]);
  if (t.label === "\\vec")
    n.style.transform = "scale(0.75) translate(10%, 30%)";
  else if (n.style.mathStyle = "normal", n.style.mathDepth = "0", Xs.has(t.label) && Q.isCharacterBox(t.base)) {
    let s = "";
    const a = t.base.text;
    (Mr.indexOf(a) > -1 || Vs.has(a)) && (s = "tml-xshift"), (Ws.indexOf(a) > -1 || Hs.has(a)) && (s = "tml-capshift"), s && n.classes.push(s);
  }
  return t.isStretchy || n.setAttribute("stretchy", "false"), new y.MathNode(
    t.label === "\\c" ? "munder" : "mover",
    [et(t.base, e), n]
  );
};
var Zs = /* @__PURE__ */ new Set([
  "\\acute",
  "\\grave",
  "\\ddot",
  "\\dddot",
  "\\ddddot",
  "\\tilde",
  "\\bar",
  "\\breve",
  "\\check",
  "\\hat",
  "\\vec",
  "\\dot",
  "\\mathring"
]);
var Xs = /* @__PURE__ */ new Set([
  "\\acute",
  "\\bar",
  "\\breve",
  "\\check",
  "\\dot",
  "\\ddot",
  "\\grave",
  "\\hat",
  "\\mathring",
  "\\'",
  "\\^",
  "\\~",
  "\\=",
  "\\u",
  "\\.",
  '\\"',
  "\\r",
  "\\H",
  "\\v"
]);
var Dn = {
  "\\`": "Ì€",
  "\\'": "Ì",
  "\\^": "Ì‚",
  "\\~": "Ìƒ",
  "\\=": "Ì„",
  "\\u": "Ì†",
  "\\.": "Ì‡",
  '\\"': "Ìˆ",
  "\\r": "ÌŠ",
  "\\H": "Ì‹",
  "\\v": "ÌŒ"
};
E({
  type: "accent",
  names: [
    "\\acute",
    "\\grave",
    "\\ddot",
    "\\dddot",
    "\\ddddot",
    "\\tilde",
    "\\bar",
    "\\breve",
    "\\check",
    "\\hat",
    "\\vec",
    "\\dot",
    "\\mathring",
    "\\overparen",
    "\\widecheck",
    "\\widehat",
    "\\wideparen",
    "\\widetilde",
    "\\overrightarrow",
    "\\overleftarrow",
    "\\Overrightarrow",
    "\\overleftrightarrow",
    "\\overgroup",
    "\\overleftharpoon",
    "\\overrightharpoon"
  ],
  props: {
    numArgs: 1
  },
  handler: (t, e) => {
    const n = Yt(e[0]), r = !Zs.has(t.funcName);
    return {
      type: "accent",
      mode: t.parser.mode,
      label: t.funcName,
      isStretchy: r,
      base: n
    };
  },
  mathmlBuilder: Or
});
E({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\c", "\\u", "\\.", '\\"', "\\r", "\\H", "\\v"],
  props: {
    numArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    argTypes: ["primitive"]
  },
  handler: (t, e) => {
    const n = Yt(e[0]), r = t.parser.mode;
    return r === "math" && t.parser.settings.strict && console.log(`Temml parse error: Command ${t.funcName} is invalid in math mode.`), r === "text" && n.text && n.text.length === 1 && t.funcName in Dn && Mr.indexOf(n.text) > -1 ? {
      type: "textord",
      mode: "text",
      text: n.text + Dn[t.funcName]
    } : {
      type: "accent",
      mode: r,
      label: t.funcName,
      isStretchy: false,
      base: n
    };
  },
  mathmlBuilder: Or
});
E({
  type: "accentUnder",
  names: [
    "\\underleftarrow",
    "\\underrightarrow",
    "\\underleftrightarrow",
    "\\undergroup",
    "\\underparen",
    "\\utilde"
  ],
  props: {
    numArgs: 1
  },
  handler: ({ parser: t, funcName: e }, n) => {
    const r = n[0];
    return {
      type: "accentUnder",
      mode: t.mode,
      label: e,
      base: r
    };
  },
  mathmlBuilder: (t, e) => {
    const n = Ae.accentNode(t);
    return n.style["math-depth"] = 0, new y.MathNode("munder", [
      et(t.base, e),
      n
    ]);
  }
});
var Pn = {
  // Convert to CSS (Postscipt) points, not TeX points
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  pt: 800 / 803,
  // convert TeX point to CSS (Postscript) point
  pc: 12 * 800 / 803,
  // pica
  dd: 1238 / 1157 * 800 / 803,
  // didot
  cc: 14856 / 1157 * 800 / 803,
  // cicero (12 didot)
  nd: 685 / 642 * 800 / 803,
  // new didot
  nc: 1370 / 107 * 800 / 803,
  // new cicero (12 new didot)
  sp: 1 / 65536 * 800 / 803,
  // scaled point (TeX's internal smallest unit)
  mm: 25.4 / 72,
  cm: 2.54 / 72,
  in: 1 / 72,
  px: 96 / 72
};
var Ys = [
  "em",
  "ex",
  "mu",
  "pt",
  "mm",
  "cm",
  "in",
  "px",
  "bp",
  "pc",
  "dd",
  "cc",
  "nd",
  "nc",
  "sp"
];
var Er = function(t) {
  return typeof t != "string" && (t = t.unit), Ys.indexOf(t) > -1;
};
var $r = (t) => {
  const e = Math.max(t - 1, 0);
  return [1, 0.7, 0.5][e];
};
var _t = function(t, e) {
  let n = t.number;
  if (e.maxSize[0] < 0 && n > 0)
    return { number: 0, unit: "em" };
  const r = t.unit;
  switch (r) {
    case "mm":
    case "cm":
    case "in":
    case "px":
      return n * Pn[r] > e.maxSize[1] ? { number: e.maxSize[1], unit: "pt" } : { number: n, unit: r };
    case "em":
    case "ex":
      return r === "ex" && (n *= 0.431), n = Math.min(n / $r(e.level), e.maxSize[0]), { number: Q.round(n), unit: "em" };
    case "bp":
      return n > e.maxSize[1] && (n = e.maxSize[1]), { number: n, unit: "pt" };
    case "pt":
    case "pc":
    case "dd":
    case "cc":
    case "nd":
    case "nc":
    case "sp":
      return n = Math.min(n * Pn[r], e.maxSize[1]), { number: Q.round(n), unit: "pt" };
    case "mu":
      return n = Math.min(n / 18, e.maxSize[0]), { number: Q.round(n), unit: "em" };
    default:
      throw new q("Invalid unit: '" + r + "'");
  }
};
var Tt = (t) => {
  const e = new y.MathNode("mspace");
  return e.setAttribute("width", t + "em"), e;
};
var he = (t, e = 0.3, n = 0) => {
  if (t == null && n === 0)
    return Tt(e);
  const r = t ? [t] : [];
  return e !== 0 && r.unshift(Tt(e)), n > 0 && r.push(Tt(n)), new y.MathNode("mrow", r);
};
var Be = (t, e) => Number(t) / $r(e);
var Qe = (t, e, n, r) => {
  const s = Ae.mathMLnode(t), a = t.slice(1, 3) === "eq", l = t.charAt(1) === "x" ? "1.75" : t.slice(2, 4) === "cd" ? "3.0" : a ? "1.0" : "2.0";
  s.setAttribute("lspace", "0"), s.setAttribute("rspace", a ? "0.5em" : "0");
  const u = r.withLevel(r.level < 2 ? 2 : 3), c = Be(l, u.level), m = Be(l, 3), b = he(null, c.toFixed(4), 0), A = he(null, m.toFixed(4), 0), x = Be(a ? 0 : 0.3, u.level).toFixed(4);
  let T, D;
  const j = e && e.body && // \hphantom        visible content
  (e.body.body || e.body.length > 0);
  if (j) {
    let $ = et(e, u);
    $ = he($, x, x), T = new y.MathNode("mover", [$, A]);
  }
  const nt = n && n.body && (n.body.body || n.body.length > 0);
  if (nt) {
    let $ = et(n, u);
    $ = he($, x, x), D = new y.MathNode("munder", [$, A]);
  }
  let N;
  return !j && !nt ? N = new y.MathNode("mover", [s, b]) : j && nt ? N = new y.MathNode("munderover", [s, D, T]) : j ? N = new y.MathNode("mover", [s, T]) : N = new y.MathNode("munder", [s, D]), l === "3.0" && (N.style.height = "1em"), N.setAttribute("accent", "false"), N;
};
E({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    // The next 5 functions are here only to support mhchem
    "\\yields",
    "\\yieldsLeft",
    "\\mesomerism",
    "\\longrightharpoonup",
    "\\longleftharpoondown",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler({ parser: t, funcName: e }, n, r) {
    return {
      type: "xArrow",
      mode: t.mode,
      name: e,
      body: n[0],
      below: r[0]
    };
  },
  mathmlBuilder(t, e) {
    const r = [Qe(t.name, t.body, t.below, e)];
    return r.unshift(Tt(0.2778)), r.push(Tt(0.2778)), new y.MathNode("mrow", r);
  }
});
var Bn = {
  "\\xtofrom": ["\\xrightarrow", "\\xleftarrow"],
  "\\xleftrightharpoons": ["\\xleftharpoonup", "\\xrightharpoondown"],
  "\\xrightleftharpoons": ["\\xrightharpoonup", "\\xleftharpoondown"],
  "\\yieldsLeftRight": ["\\yields", "\\yieldsLeft"],
  // The next three all get the same harpoon glyphs. Only the lengths and paddings differ.
  "\\equilibrium": ["\\longrightharpoonup", "\\longleftharpoondown"],
  "\\equilibriumRight": ["\\longrightharpoonup", "\\eqleftharpoondown"],
  "\\equilibriumLeft": ["\\eqrightharpoonup", "\\longleftharpoondown"]
};
E({
  type: "stackedArrow",
  names: [
    "\\xtofrom",
    // expfeil
    "\\xleftrightharpoons",
    // mathtools
    "\\xrightleftharpoons",
    // mathtools
    "\\yieldsLeftRight",
    // mhchem
    "\\equilibrium",
    // mhchem
    "\\equilibriumRight",
    "\\equilibriumLeft"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler({ parser: t, funcName: e }, n, r) {
    const s = n[0] ? {
      type: "hphantom",
      mode: t.mode,
      body: n[0]
    } : null, a = r[0] ? {
      type: "hphantom",
      mode: t.mode,
      body: r[0]
    } : null;
    return {
      type: "stackedArrow",
      mode: t.mode,
      name: e,
      body: n[0],
      upperArrowBelow: a,
      lowerArrowBody: s,
      below: r[0]
    };
  },
  mathmlBuilder(t, e) {
    const n = Bn[t.name][0], r = Bn[t.name][1], s = Qe(n, t.body, t.upperArrowBelow, e), a = Qe(r, t.lowerArrowBody, t.below, e);
    let l;
    const u = new y.MathNode("mpadded", [s]);
    if (u.setAttribute("voffset", "0.3em"), u.setAttribute("height", "+0.3em"), u.setAttribute("depth", "-0.3em"), t.name === "\\equilibriumLeft") {
      const c = new y.MathNode("mpadded", [a]);
      c.setAttribute("width", "0.5em"), l = new y.MathNode(
        "mpadded",
        [Tt(0.2778), c, u, Tt(0.2778)]
      );
    } else
      u.setAttribute("width", t.name === "\\equilibriumRight" ? "0.5em" : "0"), l = new y.MathNode(
        "mpadded",
        [Tt(0.2778), u, a, Tt(0.2778)]
      );
    return l.setAttribute("voffset", "-0.18em"), l.setAttribute("height", "-0.18em"), l.setAttribute("depth", "+0.18em"), l;
  }
});
function z(t, e) {
  if (!t || t.type !== e)
    throw new Error(
      `Expected node of type ${e}, but got ` + (t ? `node of type ${t.type}` : String(t))
    );
  return t;
}
function pn(t) {
  const e = Se(t);
  if (!e)
    throw new Error(
      "Expected node of symbol group type, but got " + (t ? `node of type ${t.type}` : String(t))
    );
  return e;
}
function Se(t) {
  return t && (t.type === "atom" || Object.prototype.hasOwnProperty.call(Ps, t.type)) ? t : null;
}
var Ks = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  A: "\\uparrow",
  V: "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
};
var Ln = () => ({ type: "styling", body: [], mode: "math", scriptLevel: "display" });
var Fn = (t) => t.type === "textord" && t.text === "@";
var Qs = (t, e) => (t.type === "mathord" || t.type === "atom") && t.text === e;
function Js(t, e, n) {
  const r = Ks[t];
  switch (r) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return n.callFunction(r, [e[0]], [e[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      const s = n.callFunction("\\\\cdleft", [e[0]], []), a = {
        type: "atom",
        text: r,
        mode: "math",
        family: "rel"
      }, l = n.callFunction("\\Big", [a], []), u = n.callFunction("\\\\cdright", [e[1]], []), c = {
        type: "ordgroup",
        mode: "math",
        body: [s, l, u],
        semisimple: true
      };
      return n.callFunction("\\\\cdparent", [c], []);
    }
    case "\\\\cdlongequal":
      return n.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      const s = { type: "textord", text: "\\Vert", mode: "math" };
      return n.callFunction("\\Big", [s], []);
    }
    default:
      return { type: "textord", text: " ", mode: "math" };
  }
}
function ti(t) {
  const e = [];
  for (t.gullet.beginGroup(), t.gullet.macros.set("\\cr", "\\\\\\relax"), t.gullet.beginGroup(); ; ) {
    e.push(t.parseExpression(false, "\\\\")), t.gullet.endGroup(), t.gullet.beginGroup();
    const s = t.fetch().text;
    if (s === "&" || s === "\\\\")
      t.consume();
    else if (s === "\\end") {
      e[e.length - 1].length === 0 && e.pop();
      break;
    } else
      throw new q("Expected \\\\ or \\cr or \\end", t.nextToken);
  }
  let n = [];
  const r = [n];
  for (let s = 0; s < e.length; s++) {
    const a = e[s];
    let l = Ln();
    for (let u = 0; u < a.length; u++)
      if (!Fn(a[u]))
        l.body.push(a[u]);
      else {
        n.push(l), u += 1;
        const c = pn(a[u]).text, m = new Array(2);
        if (m[0] = { type: "ordgroup", mode: "math", body: [] }, m[1] = { type: "ordgroup", mode: "math", body: [] }, !("=|.".indexOf(c) > -1)) if ("<>AV".indexOf(c) > -1)
          for (let A = 0; A < 2; A++) {
            let x = true;
            for (let T = u + 1; T < a.length; T++) {
              if (Qs(a[T], c)) {
                x = false, u = T;
                break;
              }
              if (Fn(a[T]))
                throw new q(
                  "Missing a " + c + " character to complete a CD arrow.",
                  a[T]
                );
              m[A].body.push(a[T]);
            }
            if (x)
              throw new q(
                "Missing a " + c + " character to complete a CD arrow.",
                a[u]
              );
          }
        else
          throw new q('Expected one of "<>AV=|." after @.');
        const b = Js(c, m, t);
        n.push(b), l = Ln();
      }
    s % 2 === 0 ? n.push(l) : n.shift(), n = [], r.push(n);
  }
  return r.pop(), t.gullet.endGroup(), t.gullet.endGroup(), {
    type: "array",
    mode: "math",
    body: r,
    envClasses: ["jot", "cd"],
    cols: [],
    hLinesBeforeRow: new Array(r.length + 1).fill([])
  };
}
E({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler({ parser: t, funcName: e }, n) {
    return {
      type: "cdlabel",
      mode: t.mode,
      side: e.slice(4),
      label: n[0]
    };
  },
  mathmlBuilder(t, e) {
    let n = new y.MathNode("mrow", [et(t.label, e)]);
    return n = new y.MathNode("mpadded", [n]), n.setAttribute("width", "0"), t.side === "left" && n.setAttribute("lspace", "-1width"), n.setAttribute("voffset", "0.7em"), n = new y.MathNode("mstyle", [n]), n.setAttribute("displaystyle", "false"), n.setAttribute("scriptlevel", "1"), n;
  }
});
E({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler({ parser: t }, e) {
    return {
      type: "cdlabelparent",
      mode: t.mode,
      fragment: e[0]
    };
  },
  mathmlBuilder(t, e) {
    return new y.MathNode("mrow", [et(t.fragment, e)]);
  }
});
E({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler({ parser: t, token: e }, n) {
    const s = z(n[0], "ordgroup").body;
    let a = "";
    for (let u = 0; u < s.length; u++) {
      const c = z(s[u], "textord");
      a += c.text;
    }
    const l = parseInt(a);
    if (isNaN(l))
      throw new q(`\\@char has non-numeric argument ${a}`, e);
    return {
      type: "textord",
      mode: t.mode,
      text: String.fromCodePoint(l)
    };
  }
});
var ei = /^(#[a-f0-9]{3}|#?[a-f0-9]{6})$/i;
var ni = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i;
var ri = /^ *\d{1,3} *(?:, *\d{1,3} *){2}$/;
var si = /^ *[10](?:\.\d*)? *(?:, *[10](?:\.\d*)? *){2}$/;
var ii = /^[a-f0-9]{6}$/i;
var zn = (t) => {
  let e = t.toString(16);
  return e.length === 1 && (e = "0" + e), e;
};
var jn = JSON.parse(`{
  "Apricot": "#ffb484",
  "Aquamarine": "#08b4bc",
  "Bittersweet": "#c84c14",
  "blue": "#0000FF",
  "Blue": "#303494",
  "BlueGreen": "#08b4bc",
  "BlueViolet": "#503c94",
  "BrickRed": "#b8341c",
  "brown": "#BF8040",
  "Brown": "#802404",
  "BurntOrange": "#f8941c",
  "CadetBlue": "#78749c",
  "CarnationPink": "#f884b4",
  "Cerulean": "#08a4e4",
  "CornflowerBlue": "#40ace4",
  "cyan": "#00FFFF",
  "Cyan": "#08acec",
  "Dandelion": "#ffbc44",
  "darkgray": "#404040",
  "DarkOrchid": "#a8548c",
  "Emerald": "#08ac9c",
  "ForestGreen": "#089c54",
  "Fuchsia": "#90348c",
  "Goldenrod": "#ffdc44",
  "gray": "#808080",
  "Gray": "#98949c",
  "green": "#00FF00",
  "Green": "#08a44c",
  "GreenYellow": "#e0e474",
  "JungleGreen": "#08ac9c",
  "Lavender": "#f89cc4",
  "lightgray": "#c0c0c0",
  "lime": "#BFFF00",
  "LimeGreen": "#90c43c",
  "magenta": "#FF00FF",
  "Magenta": "#f0048c",
  "Mahogany": "#b0341c",
  "Maroon": "#b03434",
  "Melon": "#f89c7c",
  "MidnightBlue": "#086494",
  "Mulberry": "#b03c94",
  "NavyBlue": "#086cbc",
  "olive": "#7F7F00",
  "OliveGreen": "#407c34",
  "orange": "#FF8000",
  "Orange": "#f8843c",
  "OrangeRed": "#f0145c",
  "Orchid": "#b074ac",
  "Peach": "#f8945c",
  "Periwinkle": "#8074bc",
  "PineGreen": "#088c74",
  "pink": "#ff7f7f",
  "Plum": "#98248c",
  "ProcessBlue": "#08b4ec",
  "purple": "#BF0040",
  "Purple": "#a0449c",
  "RawSienna": "#983c04",
  "red": "#ff0000",
  "Red": "#f01c24",
  "RedOrange": "#f86434",
  "RedViolet": "#a0246c",
  "Rhodamine": "#f0549c",
  "Royallue": "#0874bc",
  "RoyalPurple": "#683c9c",
  "RubineRed": "#f0047c",
  "Salmon": "#f8948c",
  "SeaGreen": "#30bc9c",
  "Sepia": "#701404",
  "SkyBlue": "#48c4dc",
  "SpringGreen": "#c8dc64",
  "Tan": "#e09c74",
  "teal": "#007F7F",
  "TealBlue": "#08acb4",
  "Thistle": "#d884b4",
  "Turquoise": "#08b4cc",
  "violet": "#800080",
  "Violet": "#60449c",
  "VioletRed": "#f054a4",
  "WildStrawberry": "#f0246c",
  "yellow": "#FFFF00",
  "Yellow": "#fff404",
  "YellowGreen": "#98cc6c",
  "YellowOrange": "#ffa41c"
}`);
var Gt = (t, e) => {
  let n = "";
  if (t === "HTML") {
    if (!ei.test(e))
      throw new q("Invalid HTML input.");
    n = e;
  } else if (t === "RGB") {
    if (!ri.test(e))
      throw new q("Invalid RGB input.");
    e.split(",").map((r) => {
      n += zn(Number(r.trim()));
    });
  } else {
    if (!si.test(e))
      throw new q("Invalid rbg input.");
    e.split(",").map((r) => {
      const s = Number(r.trim());
      if (s > 1)
        throw new q("Color rgb input must be < 1.");
      n += zn(Number((s * 255).toFixed(0)));
    });
  }
  return n.charAt(0) !== "#" && (n = "#" + n), n;
};
var Kt = (t, e, n) => {
  const r = `\\\\color@${t}`;
  if (!ni.exec(t))
    throw new q("Invalid color: '" + t + "'", n);
  return ii.test(t) ? "#" + t : (t.charAt(0) === "#" || (e.has(r) ? t = e.get(r).tokens[0].text : jn[t] && (t = jn[t])), t);
};
var Ir = (t, e) => {
  let n = dt(t.body, e.withColor(t.color));
  return n = n.map((r) => (r.style.color = t.color, r)), y.newDocumentFragment(n);
};
E({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw", "original"]
  },
  handler({ parser: t, token: e }, n, r) {
    const s = r[0] && z(r[0], "raw").string;
    let a = "";
    if (s) {
      const u = z(n[0], "raw").string;
      a = Gt(s, u);
    } else
      a = Kt(z(n[0], "raw").string, t.gullet.macros, e);
    const l = n[1];
    return {
      type: "color",
      mode: t.mode,
      color: a,
      body: it(l)
    };
  },
  mathmlBuilder: Ir
});
E({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw"]
  },
  handler({ parser: t, breakOnTokenText: e, token: n }, r, s) {
    const a = s[0] && z(s[0], "raw").string;
    let l = "";
    if (a) {
      const c = z(r[0], "raw").string;
      l = Gt(a, c);
    } else
      l = Kt(z(r[0], "raw").string, t.gullet.macros, n);
    const u = t.parseExpression(true, e, true);
    return {
      type: "color",
      mode: t.mode,
      color: l,
      body: u
    };
  },
  mathmlBuilder: Ir
});
E({
  type: "color",
  names: ["\\definecolor"],
  props: {
    numArgs: 3,
    allowedInText: true,
    argTypes: ["raw", "raw", "raw"]
  },
  handler({ parser: t, funcName: e, token: n }, r) {
    const s = z(r[0], "raw").string;
    if (!/^[A-Za-z]+$/.test(s))
      throw new q("Color name must be latin letters.", n);
    const a = z(r[1], "raw").string;
    if (!["HTML", "RGB", "rgb"].includes(a))
      throw new q("Color model must be HTML, RGB, or rgb.", n);
    const l = z(r[2], "raw").string, u = Gt(a, l);
    return t.gullet.macros.set(`\\\\color@${s}`, { tokens: [{ text: u }], numArgs: 0 }), { type: "internal", mode: t.mode };
  }
  // No mathmlBuilder. The point of \definecolor is to set a macro.
});
E({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: true
  },
  handler({ parser: t }, e, n) {
    const r = t.gullet.future().text === "[" ? t.parseSizeGroup(true) : null, s = !t.settings.displayMode;
    return {
      type: "cr",
      mode: t.mode,
      newLine: s,
      size: r && z(r, "size").value
    };
  },
  // The following builder is called only at the top level,
  // not within tabular/array environments.
  mathmlBuilder(t, e) {
    const n = new y.MathNode("mo");
    if (t.newLine && (n.setAttribute("linebreak", "newline"), t.size)) {
      const r = _t(t.size, e);
      n.setAttribute("height", r.number + r.unit);
    }
    return n;
  }
});
var Je = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
};
var we = (t) => {
  const e = t.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(e))
    throw new q("Expected a control sequence", t);
  return e;
};
var ai = (t) => {
  let e = t.gullet.popToken();
  return e.text === "=" && (e = t.gullet.popToken(), e.text === " " && (e = t.gullet.popToken())), e;
};
var Dr = (t, e, n, r) => {
  let s = t.gullet.macros.get(n.text);
  s == null && (n.noexpand = true, s = {
    tokens: [n],
    numArgs: 0,
    // reproduce the same behavior in expansion
    unexpandable: !t.gullet.isExpandable(n.text)
  }), t.gullet.macros.set(e, s, r);
};
E({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // canâ€™t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler({ parser: t, funcName: e }) {
    t.consumeSpaces();
    const n = t.fetch();
    if (Je[n.text])
      return (e === "\\global" || e === "\\\\globallong") && (n.text = Je[n.text]), z(t.parseFunction(), "internal");
    throw new q("Invalid token after macro prefix", n);
  }
});
E({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser: t, funcName: e }) {
    let n = t.gullet.popToken();
    const r = n.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(r))
      throw new q("Expected a control sequence", n);
    let s = 0, a;
    const l = [[]];
    for (; t.gullet.future().text !== "{"; )
      if (n = t.gullet.popToken(), n.text === "#") {
        if (t.gullet.future().text === "{") {
          a = t.gullet.future(), l[s].push("{");
          break;
        }
        if (n = t.gullet.popToken(), !/^[1-9]$/.test(n.text))
          throw new q(`Invalid argument number "${n.text}"`);
        if (parseInt(n.text) !== s + 1)
          throw new q(`Argument number "${n.text}" out of order`);
        s++, l.push([]);
      } else {
        if (n.text === "EOF")
          throw new q("Expected a macro definition");
        l[s].push(n.text);
      }
    let { tokens: u } = t.gullet.consumeArg();
    if (a && u.unshift(a), e === "\\edef" || e === "\\xdef") {
      if (u = t.gullet.expandTokens(u), u.length > t.gullet.settings.maxExpand)
        throw new q("Too many expansions in an " + e);
      u.reverse();
    }
    return t.gullet.macros.set(
      r,
      { tokens: u, numArgs: s, delimiters: l },
      e === Je[e]
    ), { type: "internal", mode: t.mode };
  }
});
E({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // canâ€™t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser: t, funcName: e }) {
    const n = we(t.gullet.popToken());
    t.gullet.consumeSpaces();
    const r = ai(t);
    return Dr(t, n, r, e === "\\\\globallet"), { type: "internal", mode: t.mode };
  }
});
E({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // canâ€™t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser: t, funcName: e }) {
    const n = we(t.gullet.popToken()), r = t.gullet.popToken(), s = t.gullet.popToken();
    return Dr(t, n, s, e === "\\\\globalfuture"), t.gullet.pushToken(s), t.gullet.pushToken(r), { type: "internal", mode: t.mode };
  }
});
E({
  type: "internal",
  names: ["\\newcommand", "\\renewcommand", "\\providecommand"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser: t, funcName: e }) {
    let n = "";
    const r = t.gullet.popToken();
    r.text === "{" ? (n = we(t.gullet.popToken()), t.gullet.popToken()) : n = we(r);
    const s = t.gullet.isDefined(n);
    if (s && e === "\\newcommand")
      throw new q(
        `\\newcommand{${n}} attempting to redefine ${n}; use \\renewcommand`
      );
    if (!s && e === "\\renewcommand")
      throw new q(
        `\\renewcommand{${n}} when command ${n} does not yet exist; use \\newcommand`
      );
    let a = 0;
    if (t.gullet.future().text === "[") {
      let u = t.gullet.popToken();
      if (u = t.gullet.popToken(), !/^[0-9]$/.test(u.text))
        throw new q(`Invalid number of arguments: "${u.text}"`);
      if (a = parseInt(u.text), u = t.gullet.popToken(), u.text !== "]")
        throw new q(`Invalid argument "${u.text}"`);
    }
    const { tokens: l } = t.gullet.consumeArg();
    return t.gullet.macros.set(
      n,
      { tokens: l, numArgs: a }
    ), { type: "internal", mode: t.mode };
  }
});
var tn = {
  "\\bigl": { mclass: "mopen", size: 1 },
  "\\Bigl": { mclass: "mopen", size: 2 },
  "\\biggl": { mclass: "mopen", size: 3 },
  "\\Biggl": { mclass: "mopen", size: 4 },
  "\\bigr": { mclass: "mclose", size: 1 },
  "\\Bigr": { mclass: "mclose", size: 2 },
  "\\biggr": { mclass: "mclose", size: 3 },
  "\\Biggr": { mclass: "mclose", size: 4 },
  "\\bigm": { mclass: "mrel", size: 1 },
  "\\Bigm": { mclass: "mrel", size: 2 },
  "\\biggm": { mclass: "mrel", size: 3 },
  "\\Biggm": { mclass: "mrel", size: 4 },
  "\\big": { mclass: "mord", size: 1 },
  "\\Big": { mclass: "mord", size: 2 },
  "\\bigg": { mclass: "mord", size: 3 },
  "\\Bigg": { mclass: "mord", size: 4 }
};
var Pr = [
  "(",
  "\\lparen",
  ")",
  "\\rparen",
  "[",
  "\\lbrack",
  "]",
  "\\rbrack",
  "\\{",
  "\\lbrace",
  "\\}",
  "\\rbrace",
  "â¦‡",
  "\\llparenthesis",
  "â¦ˆ",
  "\\rrparenthesis",
  "\\lfloor",
  "\\rfloor",
  "âŒŠ",
  "âŒ‹",
  "\\lceil",
  "\\rceil",
  "âŒˆ",
  "âŒ‰",
  "<",
  ">",
  "\\langle",
  "âŸ¨",
  "\\rangle",
  "âŸ©",
  "\\lAngle",
  "âŸª",
  "\\rAngle",
  "âŸ«",
  "\\llangle",
  "â¦‰",
  "\\rrangle",
  "â¦Š",
  "\\lt",
  "\\gt",
  "\\lvert",
  "\\rvert",
  "\\lVert",
  "\\rVert",
  "\\lgroup",
  "\\rgroup",
  "âŸ®",
  "âŸ¯",
  "\\lmoustache",
  "\\rmoustache",
  "â°",
  "â±",
  "\\llbracket",
  "\\rrbracket",
  "âŸ¦",
  "âŸ¦",
  "\\lBrace",
  "\\rBrace",
  "â¦ƒ",
  "â¦„",
  "/",
  "\\backslash",
  "|",
  "\\vert",
  "\\|",
  "\\Vert",
  "\\uparrow",
  "\\Uparrow",
  "\\downarrow",
  "\\Downarrow",
  "\\updownarrow",
  "\\Updownarrow",
  "."
];
var oi = ["}", "\\left", "\\middle", "\\right"];
var Ne = (t) => t.length > 0 && (Pr.includes(t) || tn[t] || oi.includes(t));
var Gn = [0, 1.2, 1.8, 2.4, 3];
function Qt(t, e) {
  const n = Se(t);
  if (n && Pr.includes(n.text))
    return ["/", "â„"].includes(n.text) && (n.text = "âˆ•"), ["<", "\\lt"].includes(n.text) && (n.text = "âŸ¨"), [">", "\\gt"].includes(n.text) && (n.text = "âŸ©"), n.text === "\\backslash" && (n.text = "âˆ–"), n;
  throw n ? new q(`Invalid delimiter '${n.text}' after '${e.funcName}'`, t) : new q(`Invalid delimiter type '${t.type}'`, t);
}
E({
  type: "delimsizing",
  names: [
    "\\bigl",
    "\\Bigl",
    "\\biggl",
    "\\Biggl",
    "\\bigr",
    "\\Bigr",
    "\\biggr",
    "\\Biggr",
    "\\bigm",
    "\\Bigm",
    "\\biggm",
    "\\Biggm",
    "\\big",
    "\\Big",
    "\\bigg",
    "\\Bigg"
  ],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (t, e) => {
    const n = Qt(e[0], t);
    return {
      type: "delimsizing",
      mode: t.parser.mode,
      size: tn[t.funcName].size,
      mclass: tn[t.funcName].mclass,
      delim: n.text
    };
  },
  mathmlBuilder: (t) => {
    const e = [];
    t.delim === "." && (t.delim = ""), e.push(ft(t.delim, t.mode));
    const n = new y.MathNode("mo", e);
    return t.mclass === "mopen" || t.mclass === "mclose" ? n.setAttribute("fence", "true") : n.setAttribute("fence", "false"), (t.delim === "âˆ–" || t.delim === "\\vert" || t.delim === "|" || t.delim.indexOf("arrow") > -1) && n.setAttribute("stretchy", "true"), n.setAttribute("symmetric", "true"), n.setAttribute("minsize", Gn[t.size] + "em"), n.setAttribute("maxsize", Gn[t.size] + "em"), n;
  }
});
function li(t) {
  if (!t.body)
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
}
E({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (t, e) => ({
    type: "leftright-right",
    mode: t.parser.mode,
    delim: Qt(e[0], t).text
  })
});
E({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (t, e) => {
    const n = Qt(e[0], t), r = t.parser;
    ++r.leftrightDepth;
    let s = r.parseExpression(false, null, true), a = r.fetch();
    for (; a.text === "\\middle"; ) {
      r.consume();
      const u = r.fetch().text;
      if (!lt.math[u])
        throw new q(`Invalid delimiter '${u}' after '\\middle'`);
      Qt({ type: "atom", mode: "math", text: u }, { funcName: "\\middle" }), s.push({ type: "middle", mode: "math", delim: u }), r.consume(), s = s.concat(r.parseExpression(false, null, true)), a = r.fetch();
    }
    --r.leftrightDepth, r.expect("\\right", false);
    const l = z(r.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: r.mode,
      body: s,
      left: n.text,
      right: l.delim
    };
  },
  mathmlBuilder: (t, e) => {
    li(t);
    const n = dt(t.body, e);
    t.left === "." && (t.left = "");
    const r = new y.MathNode("mo", [ft(t.left, t.mode)]);
    r.setAttribute("fence", "true"), r.setAttribute("form", "prefix"), (t.left === "âˆ–" || t.left.indexOf("arrow") > -1) && r.setAttribute("stretchy", "true"), n.unshift(r), t.right === "." && (t.right = "");
    const s = new y.MathNode("mo", [ft(t.right, t.mode)]);
    return s.setAttribute("fence", "true"), s.setAttribute("form", "postfix"), (t.right === "âˆ–" || t.right.indexOf("arrow") > -1) && s.setAttribute("stretchy", "true"), n.push(s), dn(n);
  }
});
E({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (t, e) => {
    const n = Qt(e[0], t);
    if (!t.parser.leftrightDepth)
      throw new q("\\middle without preceding \\left", n);
    return {
      type: "middle",
      mode: t.parser.mode,
      delim: n.text
    };
  },
  mathmlBuilder: (t, e) => {
    const n = ft(t.delim, t.mode), r = new y.MathNode("mo", [n]);
    return r.setAttribute("fence", "true"), t.delim.indexOf("arrow") > -1 && r.setAttribute("stretchy", "true"), r.setAttribute("form", "prefix"), r.setAttribute("lspace", "0.05em"), r.setAttribute("rspace", "0.05em"), r;
  }
});
var Rn = (t) => {
  const e = new y.MathNode("mspace");
  return e.setAttribute("width", "3pt"), e;
};
var te = (t, e) => {
  let n;
  switch (t.label.indexOf("colorbox") > -1 || t.label === "\\boxed" ? n = new y.MathNode("mrow", [
    Rn(),
    et(t.body, e),
    Rn()
  ]) : n = new y.MathNode("menclose", [et(t.body, e)]), t.label) {
    case "\\overline":
      n.setAttribute("notation", "top"), n.classes.push("tml-overline");
      break;
    case "\\underline":
      n.setAttribute("notation", "bottom"), n.classes.push("tml-underline");
      break;
    case "\\cancel":
      n.setAttribute("notation", "updiagonalstrike"), n.children.push(new y.MathNode("mrow", [], ["tml-cancel", "upstrike"]));
      break;
    case "\\bcancel":
      n.setAttribute("notation", "downdiagonalstrike"), n.children.push(new y.MathNode("mrow", [], ["tml-cancel", "downstrike"]));
      break;
    case "\\sout":
      n.setAttribute("notation", "horizontalstrike"), n.children.push(new y.MathNode("mrow", [], ["tml-cancel", "sout"]));
      break;
    case "\\xcancel":
      n.setAttribute("notation", "updiagonalstrike downdiagonalstrike"), n.classes.push("tml-xcancel");
      break;
    case "\\longdiv":
      n.setAttribute("notation", "longdiv"), n.classes.push("longdiv-top"), n.children.push(new y.MathNode("mrow", [], ["longdiv-arc"]));
      break;
    case "\\phase":
      n.setAttribute("notation", "phasorangle"), n.classes.push("phasor-bottom"), n.children.push(new y.MathNode("mrow", [], ["phasor-angle"]));
      break;
    case "\\textcircled":
      n.setAttribute("notation", "circle"), n.classes.push("circle-pad"), n.children.push(new y.MathNode("mrow", [], ["textcircle"]));
      break;
    case "\\angl":
      n.setAttribute("notation", "actuarial"), n.classes.push("actuarial");
      break;
    case "\\boxed":
      n.setAttribute("notation", "box"), n.classes.push("tml-box"), n.setAttribute("scriptlevel", "0"), n.setAttribute("displaystyle", "true");
      break;
    case "\\fbox":
      n.setAttribute("notation", "box"), n.classes.push("tml-fbox");
      break;
    case "\\fcolorbox":
    case "\\colorbox": {
      const r = { padding: "3pt 0 3pt 0" };
      t.label === "\\fcolorbox" && (r.border = "0.0667em solid " + String(t.borderColor)), n.style = r;
      break;
    }
  }
  return t.backgroundColor && n.setAttribute("mathbackground", t.backgroundColor), n;
};
E({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw", "text"]
  },
  handler({ parser: t, funcName: e }, n, r) {
    const s = r[0] && z(r[0], "raw").string;
    let a = "";
    if (s) {
      const u = z(n[0], "raw").string;
      a = Gt(s, u);
    } else
      a = Kt(z(n[0], "raw").string, t.gullet.macros);
    const l = n[1];
    return {
      type: "enclose",
      mode: t.mode,
      label: e,
      backgroundColor: a,
      body: l
    };
  },
  mathmlBuilder: te
});
E({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw", "raw", "text"]
  },
  handler({ parser: t, funcName: e }, n, r) {
    const s = r[0] && z(r[0], "raw").string;
    let a = "", l;
    if (s) {
      const c = z(n[0], "raw").string, m = z(n[0], "raw").string;
      a = Gt(s, c), l = Gt(s, m);
    } else
      a = Kt(z(n[0], "raw").string, t.gullet.macros), l = Kt(z(n[1], "raw").string, t.gullet.macros);
    const u = n[2];
    return {
      type: "enclose",
      mode: t.mode,
      label: e,
      backgroundColor: l,
      borderColor: a,
      body: u
    };
  },
  mathmlBuilder: te
});
E({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: true
  },
  handler({ parser: t }, e) {
    return {
      type: "enclose",
      mode: t.mode,
      label: "\\fbox",
      body: e[0]
    };
  }
});
E({
  type: "enclose",
  names: [
    "\\angl",
    "\\cancel",
    "\\bcancel",
    "\\xcancel",
    "\\sout",
    "\\overline",
    "\\boxed",
    "\\longdiv",
    "\\phase"
  ],
  props: {
    numArgs: 1
  },
  handler({ parser: t, funcName: e }, n) {
    const r = n[0];
    return {
      type: "enclose",
      mode: t.mode,
      label: e,
      body: r
    };
  },
  mathmlBuilder: te
});
E({
  type: "enclose",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler({ parser: t, funcName: e }, n) {
    const r = n[0];
    return {
      type: "enclose",
      mode: t.mode,
      label: e,
      body: r
    };
  },
  mathmlBuilder: te
});
E({
  type: "enclose",
  names: ["\\textcircled"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: true,
    allowedInText: true
  },
  handler({ parser: t, funcName: e }, n) {
    const r = n[0];
    return {
      type: "enclose",
      mode: t.mode,
      label: e,
      body: r
    };
  },
  mathmlBuilder: te
});
var Br = {};
function yt({ type: t, names: e, props: n, handler: r, mathmlBuilder: s }) {
  const a = {
    type: t,
    numArgs: n.numArgs || 0,
    allowedInText: false,
    numOptionalArgs: 0,
    handler: r
  };
  for (let l = 0; l < e.length; ++l)
    Br[e[l]] = a;
  s && (be[t] = s);
}
var ot = {
  DISPLAY: 0,
  TEXT: 1,
  SCRIPT: 2,
  SCRIPTSCRIPT: 3
};
var Lr = {};
function h(t, e) {
  Lr[t] = e;
}
var ui = Lr;
h("\\noexpand", function(t) {
  const e = t.popToken();
  return t.isExpandable(e.text) && (e.noexpand = true, e.treatAsRelax = true), { tokens: [e], numArgs: 0 };
});
h("\\expandafter", function(t) {
  const e = t.popToken();
  return t.expandOnce(true), { tokens: [e], numArgs: 0 };
});
h("\\@firstoftwo", function(t) {
  return { tokens: t.consumeArgs(2)[0], numArgs: 0 };
});
h("\\@secondoftwo", function(t) {
  return { tokens: t.consumeArgs(2)[1], numArgs: 0 };
});
h("\\@ifnextchar", function(t) {
  const e = t.consumeArgs(3);
  t.consumeSpaces();
  const n = t.future();
  return e[0].length === 1 && e[0][0].text === n.text ? { tokens: e[1], numArgs: 0 } : { tokens: e[2], numArgs: 0 };
});
h("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
h("\\TextOrMath", function(t) {
  const e = t.consumeArgs(2);
  return t.mode === "text" ? { tokens: e[0], numArgs: 0 } : { tokens: e[1], numArgs: 0 };
});
var en = (t) => {
  let e = "";
  for (let n = t.length - 1; n > -1; n--)
    e += t[n].text;
  return e;
};
var mn = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
var Un = (t) => {
  const e = t.future().text;
  return e === "EOF" ? [null, ""] : [mn[e.charAt(0)], e];
};
var Wn = (t, e, n) => {
  for (let r = 1; r < e.length; r++) {
    const s = mn[e.charAt(r)];
    t *= n, t += s;
  }
  return t;
};
h("\\char", function(t) {
  let e = t.popToken(), n, r = "";
  if (e.text === "'")
    n = 8, e = t.popToken();
  else if (e.text === '"')
    n = 16, e = t.popToken();
  else if (e.text === "`")
    if (e = t.popToken(), e.text[0] === "\\")
      r = e.text.charCodeAt(1);
    else {
      if (e.text === "EOF")
        throw new q("\\char` missing argument");
      r = e.text.charCodeAt(0);
    }
  else
    n = 10;
  if (n) {
    let s = e.text;
    if (r = mn[s.charAt(0)], r == null || r >= n)
      throw new q(`Invalid base-${n} digit ${e.text}`);
    r = Wn(r, s, n);
    let a;
    for ([a, s] = Un(t); a != null && a < n; )
      r *= n, r += a, r = Wn(r, s, n), t.popToken(), [a, s] = Un(t);
  }
  return `\\@char{${r}}`;
});
function fn(t) {
  const e = t.consumeArgs(1)[0];
  let n = "", r = e[e.length - 1].loc.start;
  for (let s = e.length - 1; s >= 0; s--) {
    const a = e[s].loc.start;
    a > r && (n += " ", r = a), n += e[s].text, r += e[s].text.length;
  }
  return n;
}
h("\\surd", "\\sqrt{\\vphantom{|}}");
h("âŠ•", "\\oplus");
h("\\long", "");
h("\\bgroup", "{");
h("\\egroup", "}");
h("~", "\\nobreakspace");
h("\\lq", "`");
h("\\rq", "'");
h("\\aa", "\\r a");
h("\\Bbbk", "\\Bbb{k}");
h("\\mathstrut", "\\vphantom{(}");
h("\\underbar", "\\underline{\\text{#1}}");
h("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
h("â‹®", "\\vdots");
h("\\arraystretch", "1");
h("\\arraycolsep", "6pt");
h("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
h("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
h("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
h("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
var Vn = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcap": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\bigtimes": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
h("\\dots", function(t) {
  let e = "\\dotso";
  const n = t.expandAfterFuture().text;
  return n in Vn ? e = Vn[n] : (n.slice(0, 4) === "\\not" || n in lt.math && ["bin", "rel"].includes(lt.math[n].group)) && (e = "\\dotsb"), e;
});
var gn = {
  // \rightdelim@ checks for the following:
  ")": true,
  "]": true,
  "\\rbrack": true,
  "\\}": true,
  "\\rbrace": true,
  "\\rangle": true,
  "\\rceil": true,
  "\\rfloor": true,
  "\\rgroup": true,
  "\\rmoustache": true,
  "\\right": true,
  "\\bigr": true,
  "\\biggr": true,
  "\\Bigr": true,
  "\\Biggr": true,
  // \extra@ also tests for the following:
  $: true,
  // \extrap@ checks for the following:
  ";": true,
  ".": true,
  ",": true
};
h("\\dotso", function(t) {
  return t.future().text in gn ? "\\ldots\\," : "\\ldots";
});
h("\\dotsc", function(t) {
  const e = t.future().text;
  return e in gn && e !== "," ? "\\ldots\\," : "\\ldots";
});
h("\\cdots", function(t) {
  return t.future().text in gn ? "\\@cdots\\," : "\\@cdots";
});
h("\\dotsb", "\\cdots");
h("\\dotsm", "\\cdots");
h("\\dotsi", "\\!\\cdots");
h("\\idotsint", "\\dotsi");
h("\\dotsx", "\\ldots\\,");
h("\\DOTSI", "\\relax");
h("\\DOTSB", "\\relax");
h("\\DOTSX", "\\relax");
h("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
h("\\,", "{\\tmspace+{3mu}{.1667em}}");
h("\\thinspace", "\\,");
h("\\>", "\\mskip{4mu}");
h("\\:", "{\\tmspace+{4mu}{.2222em}}");
h("\\medspace", "\\:");
h("\\;", "{\\tmspace+{5mu}{.2777em}}");
h("\\thickspace", "\\;");
h("\\!", "{\\tmspace-{3mu}{.1667em}}");
h("\\negthinspace", "\\!");
h("\\negmedspace", "{\\tmspace-{4mu}{.2222em}}");
h("\\negthickspace", "{\\tmspace-{5mu}{.277em}}");
h("\\enspace", "\\kern.5em ");
h("\\enskip", "\\hskip.5em\\relax");
h("\\quad", "\\hskip1em\\relax");
h("\\qquad", "\\hskip2em\\relax");
h("\\AA", "\\TextOrMath{\\Angstrom}{\\mathring{A}}\\relax");
h("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
h("\\tag@paren", "\\tag@literal{({#1})}");
h("\\tag@literal", (t) => {
  if (t.macros.get("\\df@tag"))
    throw new q("Multiple \\tag");
  return "\\def\\df@tag{\\text{#1}}";
});
h("\\bmod", "\\mathbin{\\text{mod}}");
h(
  "\\pod",
  "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)"
);
h("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
h(
  "\\mod",
  "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1"
);
h("\\newline", "\\\\\\relax");
h("\\TeX", "\\textrm{T}\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125em\\textrm{X}");
h(
  "\\LaTeX",
  "\\textrm{L}\\kern-.35em\\raisebox{0.2em}{\\scriptstyle A}\\kern-.15em\\TeX"
);
h(
  "\\Temml",
  // eslint-disable-next-line max-len
  "\\textrm{T}\\kern-0.2em\\lower{0.2em}{\\textrm{E}}\\kern-0.08em{\\textrm{M}\\kern-0.08em\\raise{0.2em}\\textrm{M}\\kern-0.08em\\textrm{L}}"
);
h("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
h("\\@hspace", "\\hskip #1\\relax");
h("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
h("\\colon", '\\mathpunct{\\char"3a}');
h("\\prescript", "\\pres@cript{_{#1}^{#2}}{}{#3}");
h("\\ordinarycolon", '\\char"3a');
h("\\vcentcolon", "\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}}");
h("\\coloneq", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"2212}');
h("\\Coloneq", '\\mathrel{\\char"2237\\char"2212}');
h("\\Eqqcolon", '\\mathrel{\\char"3d\\char"2237}');
h("\\Eqcolon", '\\mathrel{\\char"2212\\char"2237}');
h("\\colonapprox", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"2248}');
h("\\Colonapprox", '\\mathrel{\\char"2237\\char"2248}');
h("\\colonsim", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"223c}');
h("\\Colonsim", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"223c}');
h("\\ratio", "\\vcentcolon");
h("\\coloncolon", "\\dblcolon");
h("\\colonequals", "\\coloneqq");
h("\\coloncolonequals", "\\Coloneqq");
h("\\equalscolon", "\\eqqcolon");
h("\\equalscoloncolon", "\\Eqqcolon");
h("\\colonminus", "\\coloneq");
h("\\coloncolonminus", "\\Coloneq");
h("\\minuscolon", "\\eqcolon");
h("\\minuscoloncolon", "\\Eqcolon");
h("\\coloncolonapprox", "\\Colonapprox");
h("\\coloncolonsim", "\\Colonsim");
h("\\notni", "\\mathrel{\\char`âˆŒ}");
h("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
h("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
h("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
h("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
h("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{\\text{lim}}}");
h("\\varliminf", "\\DOTSB\\operatorname*{\\underline{\\text{lim}}}");
h("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{\\text{lim}}}");
h("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{\\text{lim}}}");
h("\\centerdot", "{\\medspace\\rule{0.167em}{0.189em}\\medspace}");
h("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
h("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
h("\\plim", "\\DOTSB\\operatorname*{plim}");
h("\\leftmodels", "\\mathop{\\reflectbox{$\\models$}}");
h("\\bra", "\\mathinner{\\langle{#1}|}");
h("\\ket", "\\mathinner{|{#1}\\rangle}");
h("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
h("\\Bra", "\\left\\langle#1\\right|");
h("\\Ket", "\\left|#1\\right\\rangle");
var Fr = (t, e) => {
  const r = `}\\,\\middle${e[0] === "|" ? "\\vert" : "\\Vert"}\\,{`;
  return t.slice(0, e.index) + r + t.slice(e.index + e[0].length);
};
h("\\Braket", function(t) {
  let e = fn(t);
  const n = /\|\||\||\\\|/g;
  let r;
  for (; (r = n.exec(e)) !== null; )
    e = Fr(e, r);
  return "\\left\\langle{" + e + "}\\right\\rangle";
});
h("\\Set", function(t) {
  let e = fn(t);
  const n = /\|\||\||\\\|/.exec(e);
  return n && (e = Fr(e, n)), "\\left\\{\\:{" + e + "}\\:\\right\\}";
});
h("\\set", function(t) {
  return "\\{{" + fn(t).replace(/\|/, "}\\mid{") + "}\\}";
});
h("\\angln", "{\\angl n}");
h("\\odv", "\\@ifstar\\odv@next\\odv@numerator");
h("\\odv@numerator", "\\frac{\\mathrm{d}#1}{\\mathrm{d}#2}");
h("\\odv@next", "\\frac{\\mathrm{d}}{\\mathrm{d}#2}#1");
h("\\pdv", "\\@ifstar\\pdv@next\\pdv@numerator");
var zr = (t) => {
  const e = t[0][0].text, n = en(t[1]).split(","), r = String(n.length), s = r === "1" ? "\\partial" : `\\partial^${r}`;
  let a = "";
  return n.map((l) => {
    a += "\\partial " + l.trim() + "\\,";
  }), [e, s, a.replace(/\\,$/, "")];
};
h("\\pdv@numerator", function(t) {
  const [e, n, r] = zr(t.consumeArgs(2));
  return `\\frac{${n} ${e}}{${r}}`;
});
h("\\pdv@next", function(t) {
  const [e, n, r] = zr(t.consumeArgs(2));
  return `\\frac{${n}}{${r}} ${e}`;
});
h("\\upalpha", "\\up@greek{\\alpha}");
h("\\upbeta", "\\up@greek{\\beta}");
h("\\upgamma", "\\up@greek{\\gamma}");
h("\\updelta", "\\up@greek{\\delta}");
h("\\upepsilon", "\\up@greek{\\epsilon}");
h("\\upzeta", "\\up@greek{\\zeta}");
h("\\upeta", "\\up@greek{\\eta}");
h("\\uptheta", "\\up@greek{\\theta}");
h("\\upiota", "\\up@greek{\\iota}");
h("\\upkappa", "\\up@greek{\\kappa}");
h("\\uplambda", "\\up@greek{\\lambda}");
h("\\upmu", "\\up@greek{\\mu}");
h("\\upnu", "\\up@greek{\\nu}");
h("\\upxi", "\\up@greek{\\xi}");
h("\\upomicron", "\\up@greek{\\omicron}");
h("\\uppi", "\\up@greek{\\pi}");
h("\\upalpha", "\\up@greek{\\alpha}");
h("\\uprho", "\\up@greek{\\rho}");
h("\\upsigma", "\\up@greek{\\sigma}");
h("\\uptau", "\\up@greek{\\tau}");
h("\\upupsilon", "\\up@greek{\\upsilon}");
h("\\upphi", "\\up@greek{\\phi}");
h("\\upchi", "\\up@greek{\\chi}");
h("\\uppsi", "\\up@greek{\\psi}");
h("\\upomega", "\\up@greek{\\omega}");
h("\\invamp", '\\mathbin{\\char"214b}');
h("\\parr", '\\mathbin{\\char"214b}');
h("\\with", '\\mathbin{\\char"26}');
h("\\multimapinv", '\\mathrel{\\char"27dc}');
h("\\multimapboth", '\\mathrel{\\char"29df}');
h("\\scoh", '{\\mkern5mu\\char"2322\\mkern5mu}');
h("\\sincoh", '{\\mkern5mu\\char"2323\\mkern5mu}');
h("\\coh", `{\\mkern5mu\\rule{}{0.7em}\\mathrlap{\\smash{\\raise2mu{\\char"2322}}}
{\\smash{\\lower4mu{\\char"2323}}}\\mkern5mu}`);
h("\\incoh", `{\\mkern5mu\\rule{}{0.7em}\\mathrlap{\\smash{\\raise2mu{\\char"2323}}}
{\\smash{\\lower4mu{\\char"2322}}}\\mkern5mu}`);
h("\\standardstate", "\\text{\\tiny\\char`â¦µ}");
h("\\ce", function(t) {
  return jr(t.consumeArgs(1)[0], "ce");
});
h("\\pu", function(t) {
  return jr(t.consumeArgs(1)[0], "pu");
});
h("\\uniDash", "{\\rule{0.672em}{0.06em}}");
h("\\triDash", "{\\rule{0.15em}{0.06em}\\kern2mu\\rule{0.15em}{0.06em}\\kern2mu\\rule{0.15em}{0.06em}}");
h("\\tripleDash", "\\kern0.075em\\raise0.25em{\\triDash}\\kern0.075em");
h("\\tripleDashOverLine", "\\kern0.075em\\mathrlap{\\raise0.125em{\\uniDash}}\\raise0.34em{\\triDash}\\kern0.075em");
h("\\tripleDashOverDoubleLine", "\\kern0.075em\\mathrlap{\\mathrlap{\\raise0.48em{\\triDash}}\\raise0.27em{\\uniDash}}{\\raise0.05em{\\uniDash}}\\kern0.075em");
h("\\tripleDashBetweenDoubleLine", "\\kern0.075em\\mathrlap{\\mathrlap{\\raise0.48em{\\uniDash}}\\raise0.27em{\\triDash}}{\\raise0.05em{\\uniDash}}\\kern0.075em");
var jr = function(t, e) {
  for (var n = "", r = t.length && t[t.length - 1].loc.start, s = t.length - 1; s >= 0; s--)
    t[s].loc.start > r && (n += " ", r = t[s].loc.start), n += t[s].text, r += t[s].text.length;
  var a = rt.go(C.go(n, e));
  return a;
};
var C = {
  //
  // Parses mchem \ce syntax
  //
  // Call like
  //   go("H2O");
  //
  go: function(t, e) {
    if (!t)
      return [];
    e === void 0 && (e = "ce");
    var n = "0", r = {};
    r.parenthesisLevel = 0, t = t.replace(/\n/g, " "), t = t.replace(/[\u2212\u2013\u2014\u2010]/g, "-"), t = t.replace(/[\u2026]/g, "...");
    for (var s, a = 10, l = []; ; ) {
      s !== t ? (a = 10, s = t) : a--;
      var u = C.stateMachines[e], c = u.transitions[n] || u.transitions["*"];
      t:
        for (var m = 0; m < c.length; m++) {
          var b = C.patterns.match_(c[m].pattern, t);
          if (b) {
            for (var A = c[m].task, x = 0; x < A.action_.length; x++) {
              var T;
              if (u.actions[A.action_[x].type_])
                T = u.actions[A.action_[x].type_](r, b.match_, A.action_[x].option);
              else if (C.actions[A.action_[x].type_])
                T = C.actions[A.action_[x].type_](r, b.match_, A.action_[x].option);
              else
                throw ["MhchemBugA", "mhchem bug A. Please report. (" + A.action_[x].type_ + ")"];
              C.concatArray(l, T);
            }
            if (n = A.nextState || n, t.length > 0) {
              if (A.revisit || (t = b.remainder), !A.toContinue)
                break t;
            } else
              return l;
          }
        }
      if (a <= 0)
        throw ["MhchemBugU", "mhchem bug U. Please report."];
    }
  },
  concatArray: function(t, e) {
    if (e)
      if (Array.isArray(e))
        for (var n = 0; n < e.length; n++)
          t.push(e[n]);
      else
        t.push(e);
  },
  patterns: {
    //
    // Matching patterns
    // either regexps or function that return null or {match_:"a", remainder:"bc"}
    //
    patterns: {
      // property names must not look like integers ("2") for correct property traversal order, later on
      empty: /^$/,
      else: /^./,
      else2: /^./,
      space: /^\s/,
      "space A": /^\s(?=[A-Z\\$])/,
      space$: /^\s$/,
      "a-z": /^[a-z]/,
      x: /^x/,
      x$: /^x$/,
      i$: /^i$/,
      letters: /^(?:[a-zA-Z\u03B1-\u03C9\u0391-\u03A9?@]|(?:\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))))+/,
      "\\greek": /^\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))/,
      "one lowercase latin letter $": /^(?:([a-z])(?:$|[^a-zA-Z]))$/,
      "$one lowercase latin letter$ $": /^\$(?:([a-z])(?:$|[^a-zA-Z]))\$$/,
      "one lowercase greek letter $": /^(?:\$?[\u03B1-\u03C9]\$?|\$?\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega)\s*\$?)(?:\s+|\{\}|(?![a-zA-Z]))$/,
      digits: /^[0-9]+/,
      "-9.,9": /^[+\-]?(?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))/,
      "-9.,9 no missing 0": /^[+\-]?[0-9]+(?:[.,][0-9]+)?/,
      "(-)(9.,9)(e)(99)": function(t) {
        var e = t.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))?(\((?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))\))?(?:([eE]|\s*(\*|x|\\times|\u00D7)\s*10\^)([+\-]?[0-9]+|\{[+\-]?[0-9]+\}))?/);
        return e && e[0] ? { match_: e.splice(1), remainder: t.substr(e[0].length) } : null;
      },
      "(-)(9)^(-9)": function(t) {
        var e = t.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+)?)\^([+\-]?[0-9]+|\{[+\-]?[0-9]+\})/);
        return e && e[0] ? { match_: e.splice(1), remainder: t.substr(e[0].length) } : null;
      },
      "state of aggregation $": function(t) {
        var e = C.patterns.findObserveGroups(t, "", /^\([a-z]{1,3}(?=[\),])/, ")", "");
        if (e && e.remainder.match(/^($|[\s,;\)\]\}])/))
          return e;
        var n = t.match(/^(?:\((?:\\ca\s?)?\$[amothc]\$\))/);
        return n ? { match_: n[0], remainder: t.substr(n[0].length) } : null;
      },
      "_{(state of aggregation)}$": /^_\{(\([a-z]{1,3}\))\}/,
      "{[(": /^(?:\\\{|\[|\()/,
      ")]}": /^(?:\)|\]|\\\})/,
      ", ": /^[,;]\s*/,
      ",": /^[,;]/,
      ".": /^[.]/,
      ". ": /^([.\u22C5\u00B7\u2022])\s*/,
      "...": /^\.\.\.(?=$|[^.])/,
      "* ": /^([*])\s*/,
      "^{(...)}": function(t) {
        return C.patterns.findObserveGroups(t, "^{", "", "", "}");
      },
      "^($...$)": function(t) {
        return C.patterns.findObserveGroups(t, "^", "$", "$", "");
      },
      "^a": /^\^([0-9]+|[^\\_])/,
      "^\\x{}{}": function(t) {
        return C.patterns.findObserveGroups(t, "^", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true);
      },
      "^\\x{}": function(t) {
        return C.patterns.findObserveGroups(t, "^", /^\\[a-zA-Z]+\{/, "}", "");
      },
      "^\\x": /^\^(\\[a-zA-Z]+)\s*/,
      "^(-1)": /^\^(-?\d+)/,
      "'": /^'/,
      "_{(...)}": function(t) {
        return C.patterns.findObserveGroups(t, "_{", "", "", "}");
      },
      "_($...$)": function(t) {
        return C.patterns.findObserveGroups(t, "_", "$", "$", "");
      },
      _9: /^_([+\-]?[0-9]+|[^\\])/,
      "_\\x{}{}": function(t) {
        return C.patterns.findObserveGroups(t, "_", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true);
      },
      "_\\x{}": function(t) {
        return C.patterns.findObserveGroups(t, "_", /^\\[a-zA-Z]+\{/, "}", "");
      },
      "_\\x": /^_(\\[a-zA-Z]+)\s*/,
      "^_": /^(?:\^(?=_)|\_(?=\^)|[\^_]$)/,
      "{}": /^\{\}/,
      "{...}": function(t) {
        return C.patterns.findObserveGroups(t, "", "{", "}", "");
      },
      "{(...)}": function(t) {
        return C.patterns.findObserveGroups(t, "{", "", "", "}");
      },
      "$...$": function(t) {
        return C.patterns.findObserveGroups(t, "", "$", "$", "");
      },
      "${(...)}$": function(t) {
        return C.patterns.findObserveGroups(t, "${", "", "", "}$");
      },
      "$(...)$": function(t) {
        return C.patterns.findObserveGroups(t, "$", "", "", "$");
      },
      "=<>": /^[=<>]/,
      "#": /^[#\u2261]/,
      "+": /^\+/,
      "-$": /^-(?=[\s_},;\]/]|$|\([a-z]+\))/,
      // -space -, -; -] -/ -$ -state-of-aggregation
      "-9": /^-(?=[0-9])/,
      "- orbital overlap": /^-(?=(?:[spd]|sp)(?:$|[\s,;\)\]\}]))/,
      "-": /^-/,
      "pm-operator": /^(?:\\pm|\$\\pm\$|\+-|\+\/-)/,
      operator: /^(?:\+|(?:[\-=<>]|<<|>>|\\approx|\$\\approx\$)(?=\s|$|-?[0-9]))/,
      arrowUpDown: /^(?:v|\(v\)|\^|\(\^\))(?=$|[\s,;\)\]\}])/,
      "\\bond{(...)}": function(t) {
        return C.patterns.findObserveGroups(t, "\\bond{", "", "", "}");
      },
      "->": /^(?:<->|<-->|->|<-|<=>>|<<=>|<=>|[\u2192\u27F6\u21CC])/,
      CMT: /^[CMT](?=\[)/,
      "[(...)]": function(t) {
        return C.patterns.findObserveGroups(t, "[", "", "", "]");
      },
      "1st-level escape": /^(&|\\\\|\\hline)\s*/,
      "\\,": /^(?:\\[,\ ;:])/,
      // \\x - but output no space before
      "\\x{}{}": function(t) {
        return C.patterns.findObserveGroups(t, "", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true);
      },
      "\\x{}": function(t) {
        return C.patterns.findObserveGroups(t, "", /^\\[a-zA-Z]+\{/, "}", "");
      },
      "\\ca": /^\\ca(?:\s+|(?![a-zA-Z]))/,
      "\\x": /^(?:\\[a-zA-Z]+\s*|\\[_&{}%])/,
      orbital: /^(?:[0-9]{1,2}[spdfgh]|[0-9]{0,2}sp)(?=$|[^a-zA-Z])/,
      // only those with numbers in front, because the others will be formatted correctly anyway
      others: /^[\/~|]/,
      "\\frac{(...)}": function(t) {
        return C.patterns.findObserveGroups(t, "\\frac{", "", "", "}", "{", "", "", "}");
      },
      "\\overset{(...)}": function(t) {
        return C.patterns.findObserveGroups(t, "\\overset{", "", "", "}", "{", "", "", "}");
      },
      "\\underset{(...)}": function(t) {
        return C.patterns.findObserveGroups(t, "\\underset{", "", "", "}", "{", "", "", "}");
      },
      "\\underbrace{(...)}": function(t) {
        return C.patterns.findObserveGroups(t, "\\underbrace{", "", "", "}_", "{", "", "", "}");
      },
      "\\color{(...)}0": function(t) {
        return C.patterns.findObserveGroups(t, "\\color{", "", "", "}");
      },
      "\\color{(...)}{(...)}1": function(t) {
        return C.patterns.findObserveGroups(t, "\\color{", "", "", "}", "{", "", "", "}");
      },
      "\\color(...){(...)}2": function(t) {
        return C.patterns.findObserveGroups(t, "\\color", "\\", "", /^(?=\{)/, "{", "", "", "}");
      },
      "\\ce{(...)}": function(t) {
        return C.patterns.findObserveGroups(t, "\\ce{", "", "", "}");
      },
      oxidation$: /^(?:[+-][IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
      "d-oxidation$": /^(?:[+-]?\s?[IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
      // 0 could be oxidation or charge
      "roman numeral": /^[IVX]+/,
      "1/2$": /^[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+(?:\$[a-z]\$|[a-z])?$/,
      amount: function(t) {
        var e;
        if (e = t.match(/^(?:(?:(?:\([+\-]?[0-9]+\/[0-9]+\)|[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+|[+\-]?[0-9]+[.,][0-9]+|[+\-]?\.[0-9]+|[+\-]?[0-9]+)(?:[a-z](?=\s*[A-Z]))?)|[+\-]?[a-z](?=\s*[A-Z])|\+(?!\s))/), e)
          return { match_: e[0], remainder: t.substr(e[0].length) };
        var n = C.patterns.findObserveGroups(t, "", "$", "$", "");
        return n && (e = n.match_.match(/^\$(?:\(?[+\-]?(?:[0-9]*[a-z]?[+\-])?[0-9]*[a-z](?:[+\-][0-9]*[a-z]?)?\)?|\+|-)\$$/), e) ? { match_: e[0], remainder: t.substr(e[0].length) } : null;
      },
      amount2: function(t) {
        return this.amount(t);
      },
      "(KV letters),": /^(?:[A-Z][a-z]{0,2}|i)(?=,)/,
      formula$: function(t) {
        if (t.match(/^\([a-z]+\)$/))
          return null;
        var e = t.match(/^(?:[a-z]|(?:[0-9\ \+\-\,\.\(\)]+[a-z])+[0-9\ \+\-\,\.\(\)]*|(?:[a-z][0-9\ \+\-\,\.\(\)]+)+[a-z]?)$/);
        return e ? { match_: e[0], remainder: t.substr(e[0].length) } : null;
      },
      uprightEntities: /^(?:pH|pOH|pC|pK|iPr|iBu)(?=$|[^a-zA-Z])/,
      "/": /^\s*(\/)\s*/,
      "//": /^\s*(\/\/)\s*/,
      "*": /^\s*[*.]\s*/
    },
    findObserveGroups: function(t, e, n, r, s, a, l, u, c, m) {
      var b = function(N, $) {
        if (typeof $ == "string")
          return N.indexOf($) !== 0 ? null : $;
        var R = N.match($);
        return R ? R[0] : null;
      }, A = function(N, $, R) {
        for (var K = 0; $ < N.length; ) {
          var X = N.charAt($), Y = b(N.substr($), R);
          if (Y !== null && K === 0)
            return { endMatchBegin: $, endMatchEnd: $ + Y.length };
          if (X === "{")
            K++;
          else if (X === "}") {
            if (K === 0)
              throw ["ExtraCloseMissingOpen", "Extra close brace or missing open brace"];
            K--;
          }
          $++;
        }
        return K > 0, null;
      }, x = b(t, e);
      if (x === null || (t = t.substr(x.length), x = b(t, n), x === null))
        return null;
      var T = A(t, x.length, r || s);
      if (T === null)
        return null;
      var D = t.substring(0, r ? T.endMatchEnd : T.endMatchBegin);
      if (a || l) {
        var j = this.findObserveGroups(t.substr(T.endMatchEnd), a, l, u, c);
        if (j === null)
          return null;
        var nt = [D, j.match_];
        return {
          match_: m ? nt.join("") : nt,
          remainder: j.remainder
        };
      } else
        return {
          match_: D,
          remainder: t.substr(T.endMatchEnd)
        };
    },
    //
    // Matching function
    // e.g. match("a", input) will look for the regexp called "a" and see if it matches
    // returns null or {match_:"a", remainder:"bc"}
    //
    match_: function(t, e) {
      var n = C.patterns.patterns[t];
      if (n === void 0)
        throw ["MhchemBugP", "mhchem bug P. Please report. (" + t + ")"];
      if (typeof n == "function")
        return C.patterns.patterns[t](e);
      var r = e.match(n);
      if (r) {
        var s;
        return r[2] ? s = [r[1], r[2]] : r[1] ? s = r[1] : s = r[0], { match_: s, remainder: e.substr(r[0].length) };
      }
      return null;
    }
  },
  //
  // Generic state machine actions
  //
  actions: {
    "a=": function(t, e) {
      t.a = (t.a || "") + e;
    },
    "b=": function(t, e) {
      t.b = (t.b || "") + e;
    },
    "p=": function(t, e) {
      t.p = (t.p || "") + e;
    },
    "o=": function(t, e) {
      t.o = (t.o || "") + e;
    },
    "q=": function(t, e) {
      t.q = (t.q || "") + e;
    },
    "d=": function(t, e) {
      t.d = (t.d || "") + e;
    },
    "rm=": function(t, e) {
      t.rm = (t.rm || "") + e;
    },
    "text=": function(t, e) {
      t.text_ = (t.text_ || "") + e;
    },
    insert: function(t, e, n) {
      return { type_: n };
    },
    "insert+p1": function(t, e, n) {
      return { type_: n, p1: e };
    },
    "insert+p1+p2": function(t, e, n) {
      return { type_: n, p1: e[0], p2: e[1] };
    },
    copy: function(t, e) {
      return e;
    },
    rm: function(t, e) {
      return { type_: "rm", p1: e || "" };
    },
    text: function(t, e) {
      return C.go(e, "text");
    },
    "{text}": function(t, e) {
      var n = ["{"];
      return C.concatArray(n, C.go(e, "text")), n.push("}"), n;
    },
    "tex-math": function(t, e) {
      return C.go(e, "tex-math");
    },
    "tex-math tight": function(t, e) {
      return C.go(e, "tex-math tight");
    },
    bond: function(t, e, n) {
      return { type_: "bond", kind_: n || e };
    },
    "color0-output": function(t, e) {
      return { type_: "color0", color: e[0] };
    },
    ce: function(t, e) {
      return C.go(e);
    },
    "1/2": function(t, e) {
      var n = [];
      e.match(/^[+\-]/) && (n.push(e.substr(0, 1)), e = e.substr(1));
      var r = e.match(/^([0-9]+|\$[a-z]\$|[a-z])\/([0-9]+)(\$[a-z]\$|[a-z])?$/);
      return r[1] = r[1].replace(/\$/g, ""), n.push({ type_: "frac", p1: r[1], p2: r[2] }), r[3] && (r[3] = r[3].replace(/\$/g, ""), n.push({ type_: "tex-math", p1: r[3] })), n;
    },
    "9,9": function(t, e) {
      return C.go(e, "9,9");
    }
  },
  //
  // createTransitions
  // convert  { 'letter': { 'state': { action_: 'output' } } }  to  { 'state' => [ { pattern: 'letter', task: { action_: [{type_: 'output'}] } } ] }
  // with expansion of 'a|b' to 'a' and 'b' (at 2 places)
  //
  createTransitions: function(t) {
    var e, n, r, s, a = {};
    for (e in t)
      for (n in t[e])
        for (r = n.split("|"), t[e][n].stateArray = r, s = 0; s < r.length; s++)
          a[r[s]] = [];
    for (e in t)
      for (n in t[e])
        for (r = t[e][n].stateArray || [], s = 0; s < r.length; s++) {
          var l = t[e][n];
          if (l.action_) {
            l.action_ = [].concat(l.action_);
            for (var u = 0; u < l.action_.length; u++)
              typeof l.action_[u] == "string" && (l.action_[u] = { type_: l.action_[u] });
          } else
            l.action_ = [];
          for (var c = e.split("|"), m = 0; m < c.length; m++)
            if (r[s] === "*")
              for (var b in a)
                a[b].push({ pattern: c[m], task: l });
            else
              a[r[s]].push({ pattern: c[m], task: l });
        }
    return a;
  },
  stateMachines: {}
};
C.stateMachines = {
  //
  // \ce state machines
  //
  //#region ce
  ce: {
    // main parser
    transitions: C.createTransitions({
      empty: {
        "*": { action_: "output" }
      },
      else: {
        "0|1|2": { action_: "beginsWithBond=false", revisit: true, toContinue: true }
      },
      oxidation$: {
        0: { action_: "oxidation-output" }
      },
      CMT: {
        r: { action_: "rdt=", nextState: "rt" },
        rd: { action_: "rqt=", nextState: "rdt" }
      },
      arrowUpDown: {
        "0|1|2|as": { action_: ["sb=false", "output", "operator"], nextState: "1" }
      },
      uprightEntities: {
        "0|1|2": { action_: ["o=", "output"], nextState: "1" }
      },
      orbital: {
        "0|1|2|3": { action_: "o=", nextState: "o" }
      },
      "->": {
        "0|1|2|3": { action_: "r=", nextState: "r" },
        "a|as": { action_: ["output", "r="], nextState: "r" },
        "*": { action_: ["output", "r="], nextState: "r" }
      },
      "+": {
        o: { action_: "d= kv", nextState: "d" },
        "d|D": { action_: "d=", nextState: "d" },
        q: { action_: "d=", nextState: "qd" },
        "qd|qD": { action_: "d=", nextState: "qd" },
        dq: { action_: ["output", "d="], nextState: "d" },
        3: { action_: ["sb=false", "output", "operator"], nextState: "0" }
      },
      amount: {
        "0|2": { action_: "a=", nextState: "a" }
      },
      "pm-operator": {
        "0|1|2|a|as": { action_: ["sb=false", "output", { type_: "operator", option: "\\pm" }], nextState: "0" }
      },
      operator: {
        "0|1|2|a|as": { action_: ["sb=false", "output", "operator"], nextState: "0" }
      },
      "-$": {
        "o|q": { action_: ["charge or bond", "output"], nextState: "qd" },
        d: { action_: "d=", nextState: "d" },
        D: { action_: ["output", { type_: "bond", option: "-" }], nextState: "3" },
        q: { action_: "d=", nextState: "qd" },
        qd: { action_: "d=", nextState: "qd" },
        "qD|dq": { action_: ["output", { type_: "bond", option: "-" }], nextState: "3" }
      },
      "-9": {
        "3|o": { action_: ["output", { type_: "insert", option: "hyphen" }], nextState: "3" }
      },
      "- orbital overlap": {
        o: { action_: ["output", { type_: "insert", option: "hyphen" }], nextState: "2" },
        d: { action_: ["output", { type_: "insert", option: "hyphen" }], nextState: "2" }
      },
      "-": {
        "0|1|2": { action_: [{ type_: "output", option: 1 }, "beginsWithBond=true", { type_: "bond", option: "-" }], nextState: "3" },
        3: { action_: { type_: "bond", option: "-" } },
        a: { action_: ["output", { type_: "insert", option: "hyphen" }], nextState: "2" },
        as: { action_: [{ type_: "output", option: 2 }, { type_: "bond", option: "-" }], nextState: "3" },
        b: { action_: "b=" },
        o: { action_: { type_: "- after o/d", option: false }, nextState: "2" },
        q: { action_: { type_: "- after o/d", option: false }, nextState: "2" },
        "d|qd|dq": { action_: { type_: "- after o/d", option: true }, nextState: "2" },
        "D|qD|p": { action_: ["output", { type_: "bond", option: "-" }], nextState: "3" }
      },
      amount2: {
        "1|3": { action_: "a=", nextState: "a" }
      },
      letters: {
        "0|1|2|3|a|as|b|p|bp|o": { action_: "o=", nextState: "o" },
        "q|dq": { action_: ["output", "o="], nextState: "o" },
        "d|D|qd|qD": { action_: "o after d", nextState: "o" }
      },
      digits: {
        o: { action_: "q=", nextState: "q" },
        "d|D": { action_: "q=", nextState: "dq" },
        q: { action_: ["output", "o="], nextState: "o" },
        a: { action_: "o=", nextState: "o" }
      },
      "space A": {
        "b|p|bp": {}
      },
      space: {
        a: { nextState: "as" },
        0: { action_: "sb=false" },
        "1|2": { action_: "sb=true" },
        "r|rt|rd|rdt|rdq": { action_: "output", nextState: "0" },
        "*": { action_: ["output", "sb=true"], nextState: "1" }
      },
      "1st-level escape": {
        "1|2": { action_: ["output", { type_: "insert+p1", option: "1st-level escape" }] },
        "*": { action_: ["output", { type_: "insert+p1", option: "1st-level escape" }], nextState: "0" }
      },
      "[(...)]": {
        "r|rt": { action_: "rd=", nextState: "rd" },
        "rd|rdt": { action_: "rq=", nextState: "rdq" }
      },
      "...": {
        "o|d|D|dq|qd|qD": { action_: ["output", { type_: "bond", option: "..." }], nextState: "3" },
        "*": { action_: [{ type_: "output", option: 1 }, { type_: "insert", option: "ellipsis" }], nextState: "1" }
      },
      ". |* ": {
        "*": { action_: ["output", { type_: "insert", option: "addition compound" }], nextState: "1" }
      },
      "state of aggregation $": {
        "*": { action_: ["output", "state of aggregation"], nextState: "1" }
      },
      "{[(": {
        "a|as|o": { action_: ["o=", "output", "parenthesisLevel++"], nextState: "2" },
        "0|1|2|3": { action_: ["o=", "output", "parenthesisLevel++"], nextState: "2" },
        "*": { action_: ["output", "o=", "output", "parenthesisLevel++"], nextState: "2" }
      },
      ")]}": {
        "0|1|2|3|b|p|bp|o": { action_: ["o=", "parenthesisLevel--"], nextState: "o" },
        "a|as|d|D|q|qd|qD|dq": { action_: ["output", "o=", "parenthesisLevel--"], nextState: "o" }
      },
      ", ": {
        "*": { action_: ["output", "comma"], nextState: "0" }
      },
      "^_": {
        // ^ and _ without a sensible argument
        "*": {}
      },
      "^{(...)}|^($...$)": {
        "0|1|2|as": { action_: "b=", nextState: "b" },
        p: { action_: "b=", nextState: "bp" },
        "3|o": { action_: "d= kv", nextState: "D" },
        q: { action_: "d=", nextState: "qD" },
        "d|D|qd|qD|dq": { action_: ["output", "d="], nextState: "D" }
      },
      "^a|^\\x{}{}|^\\x{}|^\\x|'": {
        "0|1|2|as": { action_: "b=", nextState: "b" },
        p: { action_: "b=", nextState: "bp" },
        "3|o": { action_: "d= kv", nextState: "d" },
        q: { action_: "d=", nextState: "qd" },
        "d|qd|D|qD": { action_: "d=" },
        dq: { action_: ["output", "d="], nextState: "d" }
      },
      "_{(state of aggregation)}$": {
        "d|D|q|qd|qD|dq": { action_: ["output", "q="], nextState: "q" }
      },
      "_{(...)}|_($...$)|_9|_\\x{}{}|_\\x{}|_\\x": {
        "0|1|2|as": { action_: "p=", nextState: "p" },
        b: { action_: "p=", nextState: "bp" },
        "3|o": { action_: "q=", nextState: "q" },
        "d|D": { action_: "q=", nextState: "dq" },
        "q|qd|qD|dq": { action_: ["output", "q="], nextState: "q" }
      },
      "=<>": {
        "0|1|2|3|a|as|o|q|d|D|qd|qD|dq": { action_: [{ type_: "output", option: 2 }, "bond"], nextState: "3" }
      },
      "#": {
        "0|1|2|3|a|as|o": { action_: [{ type_: "output", option: 2 }, { type_: "bond", option: "#" }], nextState: "3" }
      },
      "{}": {
        "*": { action_: { type_: "output", option: 1 }, nextState: "1" }
      },
      "{...}": {
        "0|1|2|3|a|as|b|p|bp": { action_: "o=", nextState: "o" },
        "o|d|D|q|qd|qD|dq": { action_: ["output", "o="], nextState: "o" }
      },
      "$...$": {
        a: { action_: "a=" },
        // 2$n$
        "0|1|2|3|as|b|p|bp|o": { action_: "o=", nextState: "o" },
        // not 'amount'
        "as|o": { action_: "o=" },
        "q|d|D|qd|qD|dq": { action_: ["output", "o="], nextState: "o" }
      },
      "\\bond{(...)}": {
        "*": { action_: [{ type_: "output", option: 2 }, "bond"], nextState: "3" }
      },
      "\\frac{(...)}": {
        "*": { action_: [{ type_: "output", option: 1 }, "frac-output"], nextState: "3" }
      },
      "\\overset{(...)}": {
        "*": { action_: [{ type_: "output", option: 2 }, "overset-output"], nextState: "3" }
      },
      "\\underset{(...)}": {
        "*": { action_: [{ type_: "output", option: 2 }, "underset-output"], nextState: "3" }
      },
      "\\underbrace{(...)}": {
        "*": { action_: [{ type_: "output", option: 2 }, "underbrace-output"], nextState: "3" }
      },
      "\\color{(...)}{(...)}1|\\color(...){(...)}2": {
        "*": { action_: [{ type_: "output", option: 2 }, "color-output"], nextState: "3" }
      },
      "\\color{(...)}0": {
        "*": { action_: [{ type_: "output", option: 2 }, "color0-output"] }
      },
      "\\ce{(...)}": {
        "*": { action_: [{ type_: "output", option: 2 }, "ce"], nextState: "3" }
      },
      "\\,": {
        "*": { action_: [{ type_: "output", option: 1 }, "copy"], nextState: "1" }
      },
      "\\x{}{}|\\x{}|\\x": {
        "0|1|2|3|a|as|b|p|bp|o|c0": { action_: ["o=", "output"], nextState: "3" },
        "*": { action_: ["output", "o=", "output"], nextState: "3" }
      },
      others: {
        "*": { action_: [{ type_: "output", option: 1 }, "copy"], nextState: "3" }
      },
      else2: {
        a: { action_: "a to o", nextState: "o", revisit: true },
        as: { action_: ["output", "sb=true"], nextState: "1", revisit: true },
        "r|rt|rd|rdt|rdq": { action_: ["output"], nextState: "0", revisit: true },
        "*": { action_: ["output", "copy"], nextState: "3" }
      }
    }),
    actions: {
      "o after d": function(t, e) {
        var n;
        if ((t.d || "").match(/^[0-9]+$/)) {
          var r = t.d;
          t.d = void 0, n = this.output(t), t.b = r;
        } else
          n = this.output(t);
        return C.actions["o="](t, e), n;
      },
      "d= kv": function(t, e) {
        t.d = e, t.dType = "kv";
      },
      "charge or bond": function(t, e) {
        if (t.beginsWithBond) {
          var n = [];
          return C.concatArray(n, this.output(t)), C.concatArray(n, C.actions.bond(t, e, "-")), n;
        } else
          t.d = e;
      },
      "- after o/d": function(t, e, n) {
        var r = C.patterns.match_("orbital", t.o || ""), s = C.patterns.match_("one lowercase greek letter $", t.o || ""), a = C.patterns.match_("one lowercase latin letter $", t.o || ""), l = C.patterns.match_("$one lowercase latin letter$ $", t.o || ""), u = e === "-" && (r && r.remainder === "" || s || a || l);
        u && !t.a && !t.b && !t.p && !t.d && !t.q && !r && a && (t.o = "$" + t.o + "$");
        var c = [];
        return u ? (C.concatArray(c, this.output(t)), c.push({ type_: "hyphen" })) : (r = C.patterns.match_("digits", t.d || ""), n && r && r.remainder === "" ? (C.concatArray(c, C.actions["d="](t, e)), C.concatArray(c, this.output(t))) : (C.concatArray(c, this.output(t)), C.concatArray(c, C.actions.bond(t, e, "-")))), c;
      },
      "a to o": function(t) {
        t.o = t.a, t.a = void 0;
      },
      "sb=true": function(t) {
        t.sb = true;
      },
      "sb=false": function(t) {
        t.sb = false;
      },
      "beginsWithBond=true": function(t) {
        t.beginsWithBond = true;
      },
      "beginsWithBond=false": function(t) {
        t.beginsWithBond = false;
      },
      "parenthesisLevel++": function(t) {
        t.parenthesisLevel++;
      },
      "parenthesisLevel--": function(t) {
        t.parenthesisLevel--;
      },
      "state of aggregation": function(t, e) {
        return { type_: "state of aggregation", p1: C.go(e, "o") };
      },
      comma: function(t, e) {
        var n = e.replace(/\s*$/, ""), r = n !== e;
        return r && t.parenthesisLevel === 0 ? { type_: "comma enumeration L", p1: n } : { type_: "comma enumeration M", p1: n };
      },
      output: function(t, e, n) {
        var r;
        if (!t.r)
          r = [], !t.a && !t.b && !t.p && !t.o && !t.q && !t.d && !n || (t.sb && r.push({ type_: "entitySkip" }), !t.o && !t.q && !t.d && !t.b && !t.p && n !== 2 ? (t.o = t.a, t.a = void 0) : !t.o && !t.q && !t.d && (t.b || t.p) ? (t.o = t.a, t.d = t.b, t.q = t.p, t.a = t.b = t.p = void 0) : t.o && t.dType === "kv" && C.patterns.match_("d-oxidation$", t.d || "") ? t.dType = "oxidation" : t.o && t.dType === "kv" && !t.q && (t.dType = void 0), r.push({
            type_: "chemfive",
            a: C.go(t.a, "a"),
            b: C.go(t.b, "bd"),
            p: C.go(t.p, "pq"),
            o: C.go(t.o, "o"),
            q: C.go(t.q, "pq"),
            d: C.go(t.d, t.dType === "oxidation" ? "oxidation" : "bd"),
            dType: t.dType
          }));
        else {
          var s;
          t.rdt === "M" ? s = C.go(t.rd, "tex-math") : t.rdt === "T" ? s = [{ type_: "text", p1: t.rd || "" }] : s = C.go(t.rd);
          var a;
          t.rqt === "M" ? a = C.go(t.rq, "tex-math") : t.rqt === "T" ? a = [{ type_: "text", p1: t.rq || "" }] : a = C.go(t.rq), r = {
            type_: "arrow",
            r: t.r,
            rd: s,
            rq: a
          };
        }
        for (var l in t)
          l !== "parenthesisLevel" && l !== "beginsWithBond" && delete t[l];
        return r;
      },
      "oxidation-output": function(t, e) {
        var n = ["{"];
        return C.concatArray(n, C.go(e, "oxidation")), n.push("}"), n;
      },
      "frac-output": function(t, e) {
        return { type_: "frac-ce", p1: C.go(e[0]), p2: C.go(e[1]) };
      },
      "overset-output": function(t, e) {
        return { type_: "overset", p1: C.go(e[0]), p2: C.go(e[1]) };
      },
      "underset-output": function(t, e) {
        return { type_: "underset", p1: C.go(e[0]), p2: C.go(e[1]) };
      },
      "underbrace-output": function(t, e) {
        return { type_: "underbrace", p1: C.go(e[0]), p2: C.go(e[1]) };
      },
      "color-output": function(t, e) {
        return { type_: "color", color1: e[0], color2: C.go(e[1]) };
      },
      "r=": function(t, e) {
        t.r = e;
      },
      "rdt=": function(t, e) {
        t.rdt = e;
      },
      "rd=": function(t, e) {
        t.rd = e;
      },
      "rqt=": function(t, e) {
        t.rqt = e;
      },
      "rq=": function(t, e) {
        t.rq = e;
      },
      operator: function(t, e, n) {
        return { type_: "operator", kind_: n || e };
      }
    }
  },
  a: {
    transitions: C.createTransitions({
      empty: {
        "*": {}
      },
      "1/2$": {
        0: { action_: "1/2" }
      },
      else: {
        0: { nextState: "1", revisit: true }
      },
      "$(...)$": {
        "*": { action_: "tex-math tight", nextState: "1" }
      },
      ",": {
        "*": { action_: { type_: "insert", option: "commaDecimal" } }
      },
      else2: {
        "*": { action_: "copy" }
      }
    }),
    actions: {}
  },
  o: {
    transitions: C.createTransitions({
      empty: {
        "*": {}
      },
      "1/2$": {
        0: { action_: "1/2" }
      },
      else: {
        0: { nextState: "1", revisit: true }
      },
      letters: {
        "*": { action_: "rm" }
      },
      "\\ca": {
        "*": { action_: { type_: "insert", option: "circa" } }
      },
      "\\x{}{}|\\x{}|\\x": {
        "*": { action_: "copy" }
      },
      "${(...)}$|$(...)$": {
        "*": { action_: "tex-math" }
      },
      "{(...)}": {
        "*": { action_: "{text}" }
      },
      else2: {
        "*": { action_: "copy" }
      }
    }),
    actions: {}
  },
  text: {
    transitions: C.createTransitions({
      empty: {
        "*": { action_: "output" }
      },
      "{...}": {
        "*": { action_: "text=" }
      },
      "${(...)}$|$(...)$": {
        "*": { action_: "tex-math" }
      },
      "\\greek": {
        "*": { action_: ["output", "rm"] }
      },
      "\\,|\\x{}{}|\\x{}|\\x": {
        "*": { action_: ["output", "copy"] }
      },
      else: {
        "*": { action_: "text=" }
      }
    }),
    actions: {
      output: function(t) {
        if (t.text_) {
          var e = { type_: "text", p1: t.text_ };
          for (var n in t)
            delete t[n];
          return e;
        }
      }
    }
  },
  pq: {
    transitions: C.createTransitions({
      empty: {
        "*": {}
      },
      "state of aggregation $": {
        "*": { action_: "state of aggregation" }
      },
      i$: {
        0: { nextState: "!f", revisit: true }
      },
      "(KV letters),": {
        0: { action_: "rm", nextState: "0" }
      },
      formula$: {
        0: { nextState: "f", revisit: true }
      },
      "1/2$": {
        0: { action_: "1/2" }
      },
      else: {
        0: { nextState: "!f", revisit: true }
      },
      "${(...)}$|$(...)$": {
        "*": { action_: "tex-math" }
      },
      "{(...)}": {
        "*": { action_: "text" }
      },
      "a-z": {
        f: { action_: "tex-math" }
      },
      letters: {
        "*": { action_: "rm" }
      },
      "-9.,9": {
        "*": { action_: "9,9" }
      },
      ",": {
        "*": { action_: { type_: "insert+p1", option: "comma enumeration S" } }
      },
      "\\color{(...)}{(...)}1|\\color(...){(...)}2": {
        "*": { action_: "color-output" }
      },
      "\\color{(...)}0": {
        "*": { action_: "color0-output" }
      },
      "\\ce{(...)}": {
        "*": { action_: "ce" }
      },
      "\\,|\\x{}{}|\\x{}|\\x": {
        "*": { action_: "copy" }
      },
      else2: {
        "*": { action_: "copy" }
      }
    }),
    actions: {
      "state of aggregation": function(t, e) {
        return { type_: "state of aggregation subscript", p1: C.go(e, "o") };
      },
      "color-output": function(t, e) {
        return { type_: "color", color1: e[0], color2: C.go(e[1], "pq") };
      }
    }
  },
  bd: {
    transitions: C.createTransitions({
      empty: {
        "*": {}
      },
      x$: {
        0: { nextState: "!f", revisit: true }
      },
      formula$: {
        0: { nextState: "f", revisit: true }
      },
      else: {
        0: { nextState: "!f", revisit: true }
      },
      "-9.,9 no missing 0": {
        "*": { action_: "9,9" }
      },
      ".": {
        "*": { action_: { type_: "insert", option: "electron dot" } }
      },
      "a-z": {
        f: { action_: "tex-math" }
      },
      x: {
        "*": { action_: { type_: "insert", option: "KV x" } }
      },
      letters: {
        "*": { action_: "rm" }
      },
      "'": {
        "*": { action_: { type_: "insert", option: "prime" } }
      },
      "${(...)}$|$(...)$": {
        "*": { action_: "tex-math" }
      },
      "{(...)}": {
        "*": { action_: "text" }
      },
      "\\color{(...)}{(...)}1|\\color(...){(...)}2": {
        "*": { action_: "color-output" }
      },
      "\\color{(...)}0": {
        "*": { action_: "color0-output" }
      },
      "\\ce{(...)}": {
        "*": { action_: "ce" }
      },
      "\\,|\\x{}{}|\\x{}|\\x": {
        "*": { action_: "copy" }
      },
      else2: {
        "*": { action_: "copy" }
      }
    }),
    actions: {
      "color-output": function(t, e) {
        return { type_: "color", color1: e[0], color2: C.go(e[1], "bd") };
      }
    }
  },
  oxidation: {
    transitions: C.createTransitions({
      empty: {
        "*": {}
      },
      "roman numeral": {
        "*": { action_: "roman-numeral" }
      },
      "${(...)}$|$(...)$": {
        "*": { action_: "tex-math" }
      },
      else: {
        "*": { action_: "copy" }
      }
    }),
    actions: {
      "roman-numeral": function(t, e) {
        return { type_: "roman numeral", p1: e || "" };
      }
    }
  },
  "tex-math": {
    transitions: C.createTransitions({
      empty: {
        "*": { action_: "output" }
      },
      "\\ce{(...)}": {
        "*": { action_: ["output", "ce"] }
      },
      "{...}|\\,|\\x{}{}|\\x{}|\\x": {
        "*": { action_: "o=" }
      },
      else: {
        "*": { action_: "o=" }
      }
    }),
    actions: {
      output: function(t) {
        if (t.o) {
          var e = { type_: "tex-math", p1: t.o };
          for (var n in t)
            delete t[n];
          return e;
        }
      }
    }
  },
  "tex-math tight": {
    transitions: C.createTransitions({
      empty: {
        "*": { action_: "output" }
      },
      "\\ce{(...)}": {
        "*": { action_: ["output", "ce"] }
      },
      "{...}|\\,|\\x{}{}|\\x{}|\\x": {
        "*": { action_: "o=" }
      },
      "-|+": {
        "*": { action_: "tight operator" }
      },
      else: {
        "*": { action_: "o=" }
      }
    }),
    actions: {
      "tight operator": function(t, e) {
        t.o = (t.o || "") + "{" + e + "}";
      },
      output: function(t) {
        if (t.o) {
          var e = { type_: "tex-math", p1: t.o };
          for (var n in t)
            delete t[n];
          return e;
        }
      }
    }
  },
  "9,9": {
    transitions: C.createTransitions({
      empty: {
        "*": {}
      },
      ",": {
        "*": { action_: "comma" }
      },
      else: {
        "*": { action_: "copy" }
      }
    }),
    actions: {
      comma: function() {
        return { type_: "commaDecimal" };
      }
    }
  },
  //#endregion
  //
  // \pu state machines
  //
  //#region pu
  pu: {
    transitions: C.createTransitions({
      empty: {
        "*": { action_: "output" }
      },
      space$: {
        "*": { action_: ["output", "space"] }
      },
      "{[(|)]}": {
        "0|a": { action_: "copy" }
      },
      "(-)(9)^(-9)": {
        0: { action_: "number^", nextState: "a" }
      },
      "(-)(9.,9)(e)(99)": {
        0: { action_: "enumber", nextState: "a" }
      },
      space: {
        "0|a": {}
      },
      "pm-operator": {
        "0|a": { action_: { type_: "operator", option: "\\pm" }, nextState: "0" }
      },
      operator: {
        "0|a": { action_: "copy", nextState: "0" }
      },
      "//": {
        d: { action_: "o=", nextState: "/" }
      },
      "/": {
        d: { action_: "o=", nextState: "/" }
      },
      "{...}|else": {
        "0|d": { action_: "d=", nextState: "d" },
        a: { action_: ["space", "d="], nextState: "d" },
        "/|q": { action_: "q=", nextState: "q" }
      }
    }),
    actions: {
      enumber: function(t, e) {
        var n = [];
        return e[0] === "+-" || e[0] === "+/-" ? n.push("\\pm ") : e[0] && n.push(e[0]), e[1] && (C.concatArray(n, C.go(e[1], "pu-9,9")), e[2] && (e[2].match(/[,.]/) ? C.concatArray(n, C.go(e[2], "pu-9,9")) : n.push(e[2])), e[3] = e[4] || e[3], e[3] && (e[3] = e[3].trim(), e[3] === "e" || e[3].substr(0, 1) === "*" ? n.push({ type_: "cdot" }) : n.push({ type_: "times" }))), e[3] && n.push("10^{" + e[5] + "}"), n;
      },
      "number^": function(t, e) {
        var n = [];
        return e[0] === "+-" || e[0] === "+/-" ? n.push("\\pm ") : e[0] && n.push(e[0]), C.concatArray(n, C.go(e[1], "pu-9,9")), n.push("^{" + e[2] + "}"), n;
      },
      operator: function(t, e, n) {
        return { type_: "operator", kind_: n || e };
      },
      space: function() {
        return { type_: "pu-space-1" };
      },
      output: function(t) {
        var e, n = C.patterns.match_("{(...)}", t.d || "");
        n && n.remainder === "" && (t.d = n.match_);
        var r = C.patterns.match_("{(...)}", t.q || "");
        if (r && r.remainder === "" && (t.q = r.match_), t.d && (t.d = t.d.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C"), t.d = t.d.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F")), t.q) {
          t.q = t.q.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C"), t.q = t.q.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
          var s = {
            d: C.go(t.d, "pu"),
            q: C.go(t.q, "pu")
          };
          t.o === "//" ? e = { type_: "pu-frac", p1: s.d, p2: s.q } : (e = s.d, s.d.length > 1 || s.q.length > 1 ? e.push({ type_: " / " }) : e.push({ type_: "/" }), C.concatArray(e, s.q));
        } else
          e = C.go(t.d, "pu-2");
        for (var a in t)
          delete t[a];
        return e;
      }
    }
  },
  "pu-2": {
    transitions: C.createTransitions({
      empty: {
        "*": { action_: "output" }
      },
      "*": {
        "*": { action_: ["output", "cdot"], nextState: "0" }
      },
      "\\x": {
        "*": { action_: "rm=" }
      },
      space: {
        "*": { action_: ["output", "space"], nextState: "0" }
      },
      "^{(...)}|^(-1)": {
        1: { action_: "^(-1)" }
      },
      "-9.,9": {
        0: { action_: "rm=", nextState: "0" },
        1: { action_: "^(-1)", nextState: "0" }
      },
      "{...}|else": {
        "*": { action_: "rm=", nextState: "1" }
      }
    }),
    actions: {
      cdot: function() {
        return { type_: "tight cdot" };
      },
      "^(-1)": function(t, e) {
        t.rm += "^{" + e + "}";
      },
      space: function() {
        return { type_: "pu-space-2" };
      },
      output: function(t) {
        var e = [];
        if (t.rm) {
          var n = C.patterns.match_("{(...)}", t.rm || "");
          n && n.remainder === "" ? e = C.go(n.match_, "pu") : e = { type_: "rm", p1: t.rm };
        }
        for (var r in t)
          delete t[r];
        return e;
      }
    }
  },
  "pu-9,9": {
    transitions: C.createTransitions({
      empty: {
        0: { action_: "output-0" },
        o: { action_: "output-o" }
      },
      ",": {
        0: { action_: ["output-0", "comma"], nextState: "o" }
      },
      ".": {
        0: { action_: ["output-0", "copy"], nextState: "o" }
      },
      else: {
        "*": { action_: "text=" }
      }
    }),
    actions: {
      comma: function() {
        return { type_: "commaDecimal" };
      },
      "output-0": function(t) {
        var e = [];
        if (t.text_ = t.text_ || "", t.text_.length > 4) {
          var n = t.text_.length % 3;
          n === 0 && (n = 3);
          for (var r = t.text_.length - 3; r > 0; r -= 3)
            e.push(t.text_.substr(r, 3)), e.push({ type_: "1000 separator" });
          e.push(t.text_.substr(0, n)), e.reverse();
        } else
          e.push(t.text_);
        for (var s in t)
          delete t[s];
        return e;
      },
      "output-o": function(t) {
        var e = [];
        if (t.text_ = t.text_ || "", t.text_.length > 4) {
          for (var n = t.text_.length - 3, r = 0; r < n; r += 3)
            e.push(t.text_.substr(r, 3)), e.push({ type_: "1000 separator" });
          e.push(t.text_.substr(r));
        } else
          e.push(t.text_);
        for (var s in t)
          delete t[s];
        return e;
      }
    }
  }
  //#endregion
};
var rt = {
  go: function(t, e) {
    if (!t)
      return "";
    for (var n = "", r = false, s = 0; s < t.length; s++) {
      var a = t[s];
      typeof a == "string" ? n += a : (n += rt._go2(a), a.type_ === "1st-level escape" && (r = true));
    }
    return !e && !r && n && (n = "{" + n + "}"), n;
  },
  _goInner: function(t) {
    return t && rt.go(t, true);
  },
  _go2: function(t) {
    var e;
    switch (t.type_) {
      case "chemfive":
        e = "";
        var n = {
          a: rt._goInner(t.a),
          b: rt._goInner(t.b),
          p: rt._goInner(t.p),
          o: rt._goInner(t.o),
          q: rt._goInner(t.q),
          d: rt._goInner(t.d)
        };
        n.a && (n.a.match(/^[+\-]/) && (n.a = "{" + n.a + "}"), e += n.a + "\\,"), (n.b || n.p) && (e += "{\\vphantom{X}}", e += "^{\\hphantom{" + (n.b || "") + "}}_{\\hphantom{" + (n.p || "") + "}}", e += "{\\vphantom{X}}", e += "^{\\vphantom{2}\\mathllap{" + (n.b || "") + "}}", e += "_{\\vphantom{2}\\mathllap{" + (n.p || "") + "}}"), n.o && (n.o.match(/^[+\-]/) && (n.o = "{" + n.o + "}"), e += n.o), t.dType === "kv" ? ((n.d || n.q) && (e += "{\\vphantom{X}}"), n.d && (e += "^{" + n.d + "}"), n.q && (e += "_{" + n.q + "}")) : t.dType === "oxidation" ? (n.d && (e += "{\\vphantom{X}}", e += "^{" + n.d + "}"), n.q && (e += "{{}}", e += "_{" + n.q + "}")) : (n.q && (e += "{{}}", e += "_{" + n.q + "}"), n.d && (e += "{{}}", e += "^{" + n.d + "}"));
        break;
      case "rm":
        e = "\\mathrm{" + t.p1 + "}";
        break;
      case "text":
        t.p1.match(/[\^_]/) ? (t.p1 = t.p1.replace(" ", "~").replace("-", "\\text{-}"), e = "\\mathrm{" + t.p1 + "}") : e = "\\text{" + t.p1 + "}";
        break;
      case "roman numeral":
        e = "\\mathrm{" + t.p1 + "}";
        break;
      case "state of aggregation":
        e = "\\mskip2mu " + rt._goInner(t.p1);
        break;
      case "state of aggregation subscript":
        e = "\\mskip1mu " + rt._goInner(t.p1);
        break;
      case "bond":
        if (e = rt._getBond(t.kind_), !e)
          throw ["MhchemErrorBond", "mhchem Error. Unknown bond type (" + t.kind_ + ")"];
        break;
      case "frac":
        var r = "\\frac{" + t.p1 + "}{" + t.p2 + "}";
        e = "\\mathchoice{\\textstyle" + r + "}{" + r + "}{" + r + "}{" + r + "}";
        break;
      case "pu-frac":
        var s = "\\frac{" + rt._goInner(t.p1) + "}{" + rt._goInner(t.p2) + "}";
        e = "\\mathchoice{\\textstyle" + s + "}{" + s + "}{" + s + "}{" + s + "}";
        break;
      case "tex-math":
        e = t.p1 + " ";
        break;
      case "frac-ce":
        e = "\\frac{" + rt._goInner(t.p1) + "}{" + rt._goInner(t.p2) + "}";
        break;
      case "overset":
        e = "\\overset{" + rt._goInner(t.p1) + "}{" + rt._goInner(t.p2) + "}";
        break;
      case "underset":
        e = "\\underset{" + rt._goInner(t.p1) + "}{" + rt._goInner(t.p2) + "}";
        break;
      case "underbrace":
        e = "\\underbrace{" + rt._goInner(t.p1) + "}_{" + rt._goInner(t.p2) + "}";
        break;
      case "color":
        e = "{\\color{" + t.color1 + "}{" + rt._goInner(t.color2) + "}}";
        break;
      case "color0":
        e = "\\color{" + t.color + "}";
        break;
      case "arrow":
        var a = {
          rd: rt._goInner(t.rd),
          rq: rt._goInner(t.rq)
        }, l = rt._getArrow(t.r);
        a.rq && (l += "[{\\rm " + a.rq + "}]"), a.rd ? l += "{\\rm " + a.rd + "}" : l += "{}", e = l;
        break;
      case "operator":
        e = rt._getOperator(t.kind_);
        break;
      case "1st-level escape":
        e = t.p1 + " ";
        break;
      case "space":
        e = " ";
        break;
      case "entitySkip":
        e = "~";
        break;
      case "pu-space-1":
        e = "~";
        break;
      case "pu-space-2":
        e = "\\mkern3mu ";
        break;
      case "1000 separator":
        e = "\\mkern2mu ";
        break;
      case "commaDecimal":
        e = "{,}";
        break;
      case "comma enumeration L":
        e = "{" + t.p1 + "}\\mkern6mu ";
        break;
      case "comma enumeration M":
        e = "{" + t.p1 + "}\\mkern3mu ";
        break;
      case "comma enumeration S":
        e = "{" + t.p1 + "}\\mkern1mu ";
        break;
      case "hyphen":
        e = "\\text{-}";
        break;
      case "addition compound":
        e = "\\,{\\cdot}\\,";
        break;
      case "electron dot":
        e = "\\mkern1mu \\text{\\textbullet}\\mkern1mu ";
        break;
      case "KV x":
        e = "{\\times}";
        break;
      case "prime":
        e = "\\prime ";
        break;
      case "cdot":
        e = "\\cdot ";
        break;
      case "tight cdot":
        e = "\\mkern1mu{\\cdot}\\mkern1mu ";
        break;
      case "times":
        e = "\\times ";
        break;
      case "circa":
        e = "{\\sim}";
        break;
      case "^":
        e = "uparrow";
        break;
      case "v":
        e = "downarrow";
        break;
      case "ellipsis":
        e = "\\ldots ";
        break;
      case "/":
        e = "/";
        break;
      case " / ":
        e = "\\,/\\,";
        break;
      default:
        throw ["MhchemBugT", "mhchem bug T. Please report."];
    }
    return e;
  },
  _getArrow: function(t) {
    switch (t) {
      case "->":
        return "\\yields";
      case "â†’":
        return "\\yields";
      case "âŸ¶":
        return "\\yields";
      case "<-":
        return "\\yieldsLeft";
      case "<->":
        return "\\mesomerism";
      case "<-->":
        return "\\yieldsLeftRight";
      case "<=>":
        return "\\equilibrium";
      case "â‡Œ":
        return "\\equilibrium";
      case "<=>>":
        return "\\equilibriumRight";
      case "<<=>":
        return "\\equilibriumLeft";
      default:
        throw ["MhchemBugT", "mhchem bug T. Please report."];
    }
  },
  _getBond: function(t) {
    switch (t) {
      case "-":
        return "{-}";
      case "1":
        return "{-}";
      case "=":
        return "{=}";
      case "2":
        return "{=}";
      case "#":
        return "{\\equiv}";
      case "3":
        return "{\\equiv}";
      case "~":
        return "{\\tripleDash}";
      case "~-":
        return "{\\tripleDashOverLine}";
      case "~=":
        return "{\\tripleDashOverDoubleLine}";
      case "~--":
        return "{\\tripleDashOverDoubleLine}";
      case "-~-":
        return "{\\tripleDashBetweenDoubleLine}";
      case "...":
        return "{{\\cdot}{\\cdot}{\\cdot}}";
      case "....":
        return "{{\\cdot}{\\cdot}{\\cdot}{\\cdot}}";
      case "->":
        return "{\\rightarrow}";
      case "<-":
        return "{\\leftarrow}";
      case "<":
        return "{<}";
      case ">":
        return "{>}";
      default:
        throw ["MhchemBugT", "mhchem bug T. Please report."];
    }
  },
  _getOperator: function(t) {
    switch (t) {
      case "+":
        return " {}+{} ";
      case "-":
        return " {}-{} ";
      case "=":
        return " {}={} ";
      case "<":
        return " {}<{} ";
      case ">":
        return " {}>{} ";
      case "<<":
        return " {}\\ll{} ";
      case ">>":
        return " {}\\gg{} ";
      case "\\pm":
        return " {}\\pm{} ";
      case "\\approx":
        return " {}\\approx{} ";
      case "$\\approx$":
        return " {}\\approx{} ";
      case "v":
        return " \\downarrow{} ";
      case "(v)":
        return " \\downarrow{} ";
      case "^":
        return " \\uparrow{} ";
      case "(^)":
        return " \\uparrow{} ";
      default:
        throw ["MhchemBugT", "mhchem bug T. Please report."];
    }
  }
};
h("\\darr", "\\downarrow");
h("\\dArr", "\\Downarrow");
h("\\Darr", "\\Downarrow");
h("\\lang", "\\langle");
h("\\rang", "\\rangle");
h("\\uarr", "\\uparrow");
h("\\uArr", "\\Uparrow");
h("\\Uarr", "\\Uparrow");
h("\\N", "\\mathbb{N}");
h("\\R", "\\mathbb{R}");
h("\\Z", "\\mathbb{Z}");
h("\\alef", "\\aleph");
h("\\alefsym", "\\aleph");
h("\\bull", "\\bullet");
h("\\clubs", "\\clubsuit");
h("\\cnums", "\\mathbb{C}");
h("\\Complex", "\\mathbb{C}");
h("\\Dagger", "\\ddagger");
h("\\diamonds", "\\diamondsuit");
h("\\empty", "\\emptyset");
h("\\exist", "\\exists");
h("\\harr", "\\leftrightarrow");
h("\\hArr", "\\Leftrightarrow");
h("\\Harr", "\\Leftrightarrow");
h("\\hearts", "\\heartsuit");
h("\\image", "\\Im");
h("\\infin", "\\infty");
h("\\isin", "\\in");
h("\\larr", "\\leftarrow");
h("\\lArr", "\\Leftarrow");
h("\\Larr", "\\Leftarrow");
h("\\lrarr", "\\leftrightarrow");
h("\\lrArr", "\\Leftrightarrow");
h("\\Lrarr", "\\Leftrightarrow");
h("\\natnums", "\\mathbb{N}");
h("\\plusmn", "\\pm");
h("\\rarr", "\\rightarrow");
h("\\rArr", "\\Rightarrow");
h("\\Rarr", "\\Rightarrow");
h("\\real", "\\Re");
h("\\reals", "\\mathbb{R}");
h("\\Reals", "\\mathbb{R}");
h("\\sdot", "\\cdot");
h("\\sect", "\\S");
h("\\spades", "\\spadesuit");
h("\\sub", "\\subset");
h("\\sube", "\\subseteq");
h("\\supe", "\\supseteq");
h("\\thetasym", "\\vartheta");
h("\\weierp", "\\wp");
h("\\quantity", "{\\left\\{ #1 \\right\\}}");
h("\\qty", "{\\left\\{ #1 \\right\\}}");
h("\\pqty", "{\\left( #1 \\right)}");
h("\\bqty", "{\\left[ #1 \\right]}");
h("\\vqty", "{\\left\\vert #1 \\right\\vert}");
h("\\Bqty", "{\\left\\{ #1 \\right\\}}");
h("\\absolutevalue", "{\\left\\vert #1 \\right\\vert}");
h("\\abs", "{\\left\\vert #1 \\right\\vert}");
h("\\norm", "{\\left\\Vert #1 \\right\\Vert}");
h("\\evaluated", "{\\left.#1 \\right\\vert}");
h("\\eval", "{\\left.#1 \\right\\vert}");
h("\\order", "{\\mathcal{O} \\left( #1 \\right)}");
h("\\commutator", "{\\left[ #1 , #2 \\right]}");
h("\\comm", "{\\left[ #1 , #2 \\right]}");
h("\\anticommutator", "{\\left\\{ #1 , #2 \\right\\}}");
h("\\acomm", "{\\left\\{ #1 , #2 \\right\\}}");
h("\\poissonbracket", "{\\left\\{ #1 , #2 \\right\\}}");
h("\\pb", "{\\left\\{ #1 , #2 \\right\\}}");
h("\\vectorbold", "{\\boldsymbol{ #1 }}");
h("\\vb", "{\\boldsymbol{ #1 }}");
h("\\vectorarrow", "{\\vec{\\boldsymbol{ #1 }}}");
h("\\va", "{\\vec{\\boldsymbol{ #1 }}}");
h("\\vectorunit", "{{\\boldsymbol{\\hat{ #1 }}}}");
h("\\vu", "{{\\boldsymbol{\\hat{ #1 }}}}");
h("\\dotproduct", "\\mathbin{\\boldsymbol\\cdot}");
h("\\vdot", "{\\boldsymbol\\cdot}");
h("\\crossproduct", "\\mathbin{\\boldsymbol\\times}");
h("\\cross", "\\mathbin{\\boldsymbol\\times}");
h("\\cp", "\\mathbin{\\boldsymbol\\times}");
h("\\gradient", "{\\boldsymbol\\nabla}");
h("\\grad", "{\\boldsymbol\\nabla}");
h("\\divergence", "{\\grad\\vdot}");
h("\\curl", "{\\grad\\cross}");
h("\\laplacian", "\\nabla^2");
h("\\tr", "{\\operatorname{tr}}");
h("\\Tr", "{\\operatorname{Tr}}");
h("\\rank", "{\\operatorname{rank}}");
h("\\erf", "{\\operatorname{erf}}");
h("\\Res", "{\\operatorname{Res}}");
h("\\principalvalue", "{\\mathcal{P}}");
h("\\pv", "{\\mathcal{P}}");
h("\\PV", "{\\operatorname{P.V.}}");
h("\\qqtext", "{\\quad\\text{ #1 }\\quad}");
h("\\qq", "{\\quad\\text{ #1 }\\quad}");
h("\\qcomma", "{\\text{,}\\quad}");
h("\\qc", "{\\text{,}\\quad}");
h("\\qcc", "{\\quad\\text{c.c.}\\quad}");
h("\\qif", "{\\quad\\text{if}\\quad}");
h("\\qthen", "{\\quad\\text{then}\\quad}");
h("\\qelse", "{\\quad\\text{else}\\quad}");
h("\\qotherwise", "{\\quad\\text{otherwise}\\quad}");
h("\\qunless", "{\\quad\\text{unless}\\quad}");
h("\\qgiven", "{\\quad\\text{given}\\quad}");
h("\\qusing", "{\\quad\\text{using}\\quad}");
h("\\qassume", "{\\quad\\text{assume}\\quad}");
h("\\qsince", "{\\quad\\text{since}\\quad}");
h("\\qlet", "{\\quad\\text{let}\\quad}");
h("\\qfor", "{\\quad\\text{for}\\quad}");
h("\\qall", "{\\quad\\text{all}\\quad}");
h("\\qeven", "{\\quad\\text{even}\\quad}");
h("\\qodd", "{\\quad\\text{odd}\\quad}");
h("\\qinteger", "{\\quad\\text{integer}\\quad}");
h("\\qand", "{\\quad\\text{and}\\quad}");
h("\\qor", "{\\quad\\text{or}\\quad}");
h("\\qas", "{\\quad\\text{as}\\quad}");
h("\\qin", "{\\quad\\text{in}\\quad}");
h("\\differential", "{\\text{d}}");
h("\\dd", "{\\text{d}}");
h("\\derivative", "{\\frac{\\text{d}{ #1 }}{\\text{d}{ #2 }}}");
h("\\dv", "{\\frac{\\text{d}{ #1 }}{\\text{d}{ #2 }}}");
h("\\partialderivative", "{\\frac{\\partial{ #1 }}{\\partial{ #2 }}}");
h("\\variation", "{\\delta}");
h("\\var", "{\\delta}");
h("\\functionalderivative", "{\\frac{\\delta{ #1 }}{\\delta{ #2 }}}");
h("\\fdv", "{\\frac{\\delta{ #1 }}{\\delta{ #2 }}}");
h("\\innerproduct", "{\\left\\langle {#1} \\mid { #2} \\right\\rangle}");
h(
  "\\outerproduct",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}"
);
h(
  "\\dyad",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}"
);
h(
  "\\ketbra",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}"
);
h(
  "\\op",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}"
);
h("\\expectationvalue", "{\\left\\langle {#1 } \\right\\rangle}");
h("\\expval", "{\\left\\langle {#1 } \\right\\rangle}");
h("\\ev", "{\\left\\langle {#1 } \\right\\rangle}");
h(
  "\\matrixelement",
  "{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}"
);
h(
  "\\matrixel",
  "{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}"
);
h(
  "\\mel",
  "{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}"
);
function Hn(t) {
  const e = [];
  t.consumeSpaces();
  let n = t.fetch().text;
  for (n === "\\relax" && (t.consume(), t.consumeSpaces(), n = t.fetch().text); n === "\\hline" || n === "\\hdashline"; )
    t.consume(), e.push(n === "\\hdashline"), t.consumeSpaces(), n = t.fetch().text;
  return e;
}
var ee = (t) => {
  if (!t.parser.settings.displayMode)
    throw new q(`{${t.envName}} can be used only in display mode.`);
};
var ci = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/;
var Gr = (t) => {
  let e = t.get("\\arraystretch");
  typeof e != "string" && (e = en(e.tokens)), e = isNaN(e) ? null : Number(e);
  let n = t.get("\\arraycolsep");
  typeof n != "string" && (n = en(n.tokens));
  const r = ci.exec(n), s = r ? { number: +(r[1] + r[2]), unit: r[3] } : null;
  return [e, s];
};
var hi = (t, e, n) => {
  let r;
  const s = t.tags.shift();
  if (s)
    if (s.body)
      r = Mt(s.body, e, true), r.classes = ["tml-tag"];
    else
      return r = new y.MathNode("mtext", [], []), r;
  else {
    if (t.envClasses.includes("multline") && (t.leqno && n !== 0 || !t.leqno && n !== t.body.length - 1))
      return r = new y.MathNode("mtext", [], []), r;
    r = new y.MathNode("mtext", [new Cr(["tml-eqn"])]);
  }
  return r;
};
function Ot(t, {
  cols: e,
  // [{ type: string , align: l|c|r|null }]
  envClasses: n,
  // align(ed|at|edat) | array | cases | cd | small | multline
  addEqnNum: r,
  // boolean
  singleRow: s,
  // boolean
  emptySingleRow: a,
  // boolean
  maxNumCols: l,
  // number
  leqno: u,
  // boolean
  arraystretch: c,
  // number  | null
  arraycolsep: m
  // size value | null
}, b) {
  t.gullet.beginGroup(), s || t.gullet.macros.set("\\cr", "\\\\\\relax"), r && (t.gullet.macros.set("\\tag", "\\@ifstar\\envtag@literal\\envtag@paren"), t.gullet.macros.set("\\envtag@paren", "\\env@tag{{(\\text{#1})}}"), t.gullet.macros.set("\\envtag@literal", "\\env@tag{\\text{#1}}"), t.gullet.macros.set("\\notag", "\\env@notag"), t.gullet.macros.set("\\nonumber", "\\env@notag")), t.gullet.beginGroup();
  let A = [];
  const x = [A], T = [], D = [];
  let j;
  const nt = [];
  for (nt.push(Hn(t)); ; ) {
    let N = t.parseExpression(false, s ? "\\end" : "\\\\");
    if (r && !j) {
      for (let R = 0; R < N.length; R++)
        if (N[R].type === "envTag" || N[R].type === "noTag") {
          j = N[R].type === "envTag" ? N.splice(R, 1)[0].body.body[0] : { body: null };
          break;
        }
    }
    t.gullet.endGroup(), t.gullet.beginGroup(), N = {
      type: "ordgroup",
      mode: t.mode,
      body: N,
      semisimple: true
    }, A.push(N);
    const $ = t.fetch().text;
    if ($ === "&") {
      if (l && A.length === l)
        if (n.includes("array")) {
          if (t.settings.strict)
            throw new q(
              "Too few columns specified in the {array} column argument.",
              t.nextToken
            );
        } else throw l === 2 ? new q(
          "The split environment accepts no more than two columns",
          t.nextToken
        ) : new q(
          "The equation environment accepts only one column",
          t.nextToken
        );
      t.consume();
    } else if ($ === "\\end") {
      A.length === 1 && N.body.length === 0 && (x.length > 1 || !a) && x.pop(), nt.length < x.length + 1 && nt.push([]);
      break;
    } else if ($ === "\\\\") {
      t.consume();
      let R;
      t.gullet.future().text !== " " && (R = t.parseSizeGroup(true)), T.push(R ? R.value : null), D.push(j), nt.push(Hn(t)), A = [], j = null, x.push(A);
    } else
      throw new q("Expected & or \\\\ or \\cr or \\end", t.nextToken);
  }
  return t.gullet.endGroup(), t.gullet.endGroup(), D.push(j), {
    type: "array",
    mode: t.mode,
    body: x,
    cols: e,
    rowGaps: T,
    hLinesBeforeRow: nt,
    envClasses: n,
    addEqnNum: r,
    scriptLevel: b,
    tags: D,
    leqno: u,
    arraystretch: c,
    arraycolsep: m
  };
}
function Rr(t) {
  return t.slice(0, 1) === "d" ? "display" : "text";
}
var di = {
  c: "center ",
  l: "left ",
  r: "right "
};
var Zn = (t) => {
  const e = new y.MathNode("mtd", []);
  return e.style = { padding: "0", width: "50%" }, t.envClasses.includes("multline") && (e.style.width = "7.5%"), e;
};
var wt = function(t, e) {
  const n = [], r = t.body.length, s = t.hLinesBeforeRow;
  for (let u = 0; u < r; u++) {
    const c = t.body[u], m = [], b = t.scriptLevel === "text" ? ot.TEXT : t.scriptLevel === "script" ? ot.SCRIPT : ot.DISPLAY;
    for (let x = 0; x < c.length; x++) {
      const T = new y.MathNode(
        "mtd",
        [et(c[x], e.withLevel(b))]
      );
      if (t.envClasses.includes("multline")) {
        const D = u === 0 ? "left" : u === r - 1 ? "right" : "center";
        T.setAttribute("columnalign", D), D !== "center" && T.classes.push("tml-" + D);
      }
      m.push(T);
    }
    if (t.addEqnNum) {
      m.unshift(Zn(t)), m.push(Zn(t));
      const x = hi(t, e.withLevel(b), u);
      t.leqno ? (m[0].children.push(x), m[0].classes.push("tml-left")) : (m[m.length - 1].children.push(x), m[m.length - 1].classes.push("tml-right"));
    }
    const A = new y.MathNode("mtr", m, []);
    u === 0 && s[0].length > 0 && (s[0].length === 2 ? A.children.forEach((x) => {
      x.style.borderTop = "0.15em double";
    }) : A.children.forEach((x) => {
      x.style.borderTop = s[0][0] ? "0.06em dashed" : "0.06em solid";
    })), s[u + 1].length > 0 && (s[u + 1].length === 2 ? A.children.forEach((x) => {
      x.style.borderBottom = "0.15em double";
    }) : A.children.forEach((x) => {
      x.style.borderBottom = s[u + 1][0] ? "0.06em dashed" : "0.06em solid";
    })), n.push(A);
  }
  if (t.envClasses.length > 0) {
    let u = t.envClasses.includes("jot") ? "0.7" : t.envClasses.includes("small") ? "0.35" : "0.5";
    t.arraystretch && t.arraystretch !== 1 && (u = String(1.4 * t.arraystretch - 0.8));
    let c = t.envClasses.includes("abut") || t.envClasses.includes("cases") ? "0" : t.envClasses.includes("small") ? "0.1389" : t.envClasses.includes("cd") ? "0.25" : "0.4", m = "em";
    if (t.arraycolsep) {
      const T = _t(t.arraycolsep, e);
      c = T.number, m = T.unit;
    }
    const b = n.length === 0 ? 0 : n[0].children.length, A = (T, D) => T === 0 && D === 0 || T === b - 1 && D === 1 ? "0" : t.envClasses[0] !== "align" ? c : D === 1 ? "0" : t.addEqnNum ? T % 2 ? "1" : "0" : T % 2 ? "0" : "1";
    for (let T = 0; T < n.length; T++)
      for (let D = 0; D < n[T].children.length; D++)
        n[T].children[D].style.padding = `${u}ex ${A(D, 1)}${m} ${u}ex ${A(D, 0)}${m}`;
    const x = t.envClasses.includes("align") || t.envClasses.includes("alignat");
    for (let T = 0; T < n.length; T++) {
      const D = n[T];
      if (x) {
        for (let j = 0; j < D.children.length; j++)
          D.children[j].classes = ["tml-" + (j % 2 ? "left" : "right")];
        if (t.addEqnNum) {
          const j = t.leqno ? 0 : D.children.length - 1;
          D.children[j].classes = ["tml-" + (t.leqno ? "left" : "right")];
        }
      }
      if (D.children.length > 1 && t.envClasses.includes("cases") && (D.children[1].style.padding = D.children[1].style.padding.replace(/0em$/, "1em")), t.envClasses.includes("cases") || t.envClasses.includes("subarray"))
        for (const j of D.children)
          j.classes.push("tml-left");
    }
  } else
    for (let u = 0; u < n.length; u++)
      n[u].children[0].style.paddingLeft = "0em", n[u].children.length === n[0].children.length && (n[u].children[n[u].children.length - 1].style.paddingRight = "0em");
  let a = new y.MathNode("mtable", n);
  t.scriptLevel === "display" && a.setAttribute("displaystyle", "true"), (t.addEqnNum || t.envClasses.includes("multline")) && (a.style.width = "100%");
  let l = "";
  if (t.cols && t.cols.length > 0) {
    const u = t.cols;
    let c = false, m = 0, b = u.length;
    for (; u[m].type === "separator"; )
      m += 1;
    for (; u[b - 1].type === "separator"; )
      b -= 1;
    if (u[0].type === "separator") {
      const x = u[1].type === "separator" ? "0.15em double" : u[0].separator === "|" ? "0.06em solid " : "0.06em dashed ";
      for (const T of a.children)
        T.children[0].style.borderLeft = x;
    }
    let A = t.addEqnNum ? 0 : -1;
    for (let x = m; x < b; x++)
      if (u[x].type === "align") {
        const T = di[u[x].align];
        l += T, A += 1;
        for (const D of a.children)
          T.trim() !== "center" && A < D.children.length && (D.children[A].classes = ["tml-" + T.trim()]);
        c = true;
      } else if (u[x].type === "separator") {
        if (c) {
          const T = u[x + 1].type === "separator" ? "0.15em double" : u[x].separator === "|" ? "0.06em solid" : "0.06em dashed";
          for (const D of a.children)
            A < D.children.length && (D.children[A].style.borderRight = T);
        }
        c = false;
      }
    if (u[u.length - 1].type === "separator") {
      const x = u[u.length - 2].type === "separator" ? "0.15em double" : u[u.length - 1].separator === "|" ? "0.06em solid" : "0.06em dashed";
      for (const T of a.children)
        T.children[T.children.length - 1].style.borderRight = x, T.children[T.children.length - 1].style.paddingRight = "0.4em";
    }
  }
  return t.addEqnNum && (l = "left " + (l.length > 0 ? l : "center ") + "right "), l && a.setAttribute("columnalign", l.trim()), t.envClasses.includes("small") && (a = new y.MathNode("mstyle", [a]), a.setAttribute("scriptlevel", "1")), a;
};
var Ur = function(t, e) {
  t.envName.indexOf("ed") === -1 && ee(t);
  const n = [], r = Ot(
    t.parser,
    {
      cols: n,
      addEqnNum: t.envName === "align" || t.envName === "alignat",
      emptySingleRow: true,
      envClasses: ["abut", "jot"],
      // set row spacing & provisional column spacing
      maxNumCols: t.envName === "split" ? 2 : void 0,
      leqno: t.parser.settings.leqno
    },
    "display"
  );
  let s, a = 0;
  const l = t.envName.indexOf("at") > -1;
  if (e[0] && l) {
    let u = "";
    for (let c = 0; c < e[0].body.length; c++) {
      const m = z(e[0].body[c], "textord");
      u += m.text;
    }
    if (isNaN(u))
      throw new q("The alignat enviroment requires a numeric first argument.");
    s = Number(u), a = s * 2;
  }
  r.body.forEach(function(u) {
    if (l) {
      const c = u.length / 2;
      if (s < c)
        throw new q(
          `Too many math in a row: expected ${s}, but got ${c}`,
          u[0]
        );
    } else a < u.length && (a = u.length);
  });
  for (let u = 0; u < a; ++u) {
    let c = "r";
    u % 2 === 1 && (c = "l"), n[u] = {
      type: "align",
      align: c
    };
  }
  return t.envName === "split" || (l ? r.envClasses.push("alignat") : r.envClasses[0] = "align"), r;
};
yt({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    const s = (Se(e[0]) ? [e[0]] : z(e[0], "ordgroup").body).map(function(c) {
      const b = pn(c).text;
      if ("lcr".indexOf(b) !== -1)
        return {
          type: "align",
          align: b
        };
      if (b === "|")
        return {
          type: "separator",
          separator: "|"
        };
      if (b === ":")
        return {
          type: "separator",
          separator: ":"
        };
      throw new q("Unknown column alignment: " + b, c);
    }), [a, l] = Gr(t.parser.gullet.macros), u = {
      cols: s,
      envClasses: ["array"],
      maxNumCols: s.length,
      arraystretch: a,
      arraycolsep: l
    };
    return Ot(t.parser, u, Rr(t.envName));
  },
  mathmlBuilder: wt
});
yt({
  type: "array",
  names: [
    "matrix",
    "pmatrix",
    "bmatrix",
    "Bmatrix",
    "vmatrix",
    "Vmatrix",
    "matrix*",
    "pmatrix*",
    "bmatrix*",
    "Bmatrix*",
    "vmatrix*",
    "Vmatrix*"
  ],
  props: {
    numArgs: 0
  },
  handler(t) {
    const e = {
      matrix: null,
      pmatrix: ["(", ")"],
      bmatrix: ["[", "]"],
      Bmatrix: ["\\{", "\\}"],
      vmatrix: ["|", "|"],
      Vmatrix: ["\\Vert", "\\Vert"]
    }[t.envName.replace("*", "")];
    let n = "c";
    const r = {
      envClasses: [],
      cols: []
    };
    if (t.envName.charAt(t.envName.length - 1) === "*") {
      const u = t.parser;
      if (u.consumeSpaces(), u.fetch().text === "[") {
        if (u.consume(), u.consumeSpaces(), n = u.fetch().text, "lcr".indexOf(n) === -1)
          throw new q("Expected l or c or r", u.nextToken);
        u.consume(), u.consumeSpaces(), u.expect("]"), u.consume(), r.cols = [];
      }
    }
    const s = Ot(t.parser, r, "text");
    s.cols = new Array(s.body[0].length).fill({ type: "align", align: n });
    const [a, l] = Gr(t.parser.gullet.macros);
    return e ? {
      type: "leftright",
      mode: t.mode,
      body: [s],
      left: e[0],
      right: e[1],
      rightColor: void 0,
      // \right uninfluenced by \color in array
      arraystretch: a,
      arraycolsep: l
    } : s;
  },
  mathmlBuilder: wt
});
yt({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(t) {
    const e = { type: "small" }, n = Ot(t.parser, e, "script");
    return n.envClasses = ["small"], n;
  },
  mathmlBuilder: wt
});
yt({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    const s = (Se(e[0]) ? [e[0]] : z(e[0], "ordgroup").body).map(function(l) {
      const c = pn(l).text;
      if ("lc".indexOf(c) !== -1)
        return {
          type: "align",
          align: c
        };
      throw new q("Unknown column alignment: " + c, l);
    });
    if (s.length > 1)
      throw new q("{subarray} can contain only one column");
    let a = {
      cols: s,
      envClasses: ["small"]
    };
    if (a = Ot(t.parser, a, "script"), a.body.length > 0 && a.body[0].length > 1)
      throw new q("{subarray} can contain only one column");
    return a;
  },
  mathmlBuilder: wt
});
yt({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(t) {
    const e = {
      cols: [],
      envClasses: ["cases"]
    }, n = Ot(t.parser, e, Rr(t.envName));
    return {
      type: "leftright",
      mode: t.mode,
      body: [n],
      left: t.envName.indexOf("r") > -1 ? "." : "\\{",
      right: t.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  mathmlBuilder: wt
});
yt({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: Ur,
  mathmlBuilder: wt
});
yt({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: Ur,
  mathmlBuilder: wt
});
yt({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(t) {
    t.envName !== "gathered" && ee(t);
    const e = {
      cols: [],
      envClasses: ["abut", "jot"],
      addEqnNum: t.envName === "gather",
      emptySingleRow: true,
      leqno: t.parser.settings.leqno
    };
    return Ot(t.parser, e, "display");
  },
  mathmlBuilder: wt
});
yt({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(t) {
    ee(t);
    const e = {
      addEqnNum: t.envName === "equation",
      emptySingleRow: true,
      singleRow: true,
      maxNumCols: 1,
      envClasses: ["align"],
      leqno: t.parser.settings.leqno
    };
    return Ot(t.parser, e, "display");
  },
  mathmlBuilder: wt
});
yt({
  type: "array",
  names: ["multline", "multline*"],
  props: {
    numArgs: 0
  },
  handler(t) {
    ee(t);
    const e = {
      addEqnNum: t.envName === "multline",
      maxNumCols: 1,
      envClasses: ["jot", "multline"],
      leqno: t.parser.settings.leqno
    };
    return Ot(t.parser, e, "display");
  },
  mathmlBuilder: wt
});
yt({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(t) {
    return ee(t), ti(t.parser);
  },
  mathmlBuilder: wt
});
E({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: true
  },
  handler(t, e) {
    throw new q(`${t.funcName} valid only within array environment`);
  }
});
var Xn = Br;
E({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler({ parser: t, funcName: e }, n) {
    const r = n[0];
    if (r.type !== "ordgroup")
      throw new q("Invalid environment name", r);
    let s = "";
    for (let a = 0; a < r.body.length; ++a)
      s += z(r.body[a], "textord").text;
    if (e === "\\begin") {
      if (!Object.prototype.hasOwnProperty.call(Xn, s))
        throw new q("No such environment: " + s, r);
      const a = Xn[s], { args: l, optArgs: u } = t.parseArguments("\\begin{" + s + "}", a), c = {
        mode: t.mode,
        envName: s,
        parser: t
      }, m = a.handler(c, l, u);
      t.expect("\\end", false);
      const b = t.nextToken, A = z(t.parseFunction(), "environment");
      if (A.name !== s)
        throw new q(
          `Mismatch: \\begin{${s}} matched by \\end{${A.name}}`,
          b
        );
      return m;
    }
    return {
      type: "environment",
      mode: t.mode,
      name: s,
      nameGroup: r
    };
  }
});
E({
  type: "envTag",
  names: ["\\env@tag"],
  props: {
    numArgs: 1,
    argTypes: ["math"]
  },
  handler({ parser: t }, e) {
    return {
      type: "envTag",
      mode: t.mode,
      body: e[0]
    };
  },
  mathmlBuilder(t, e) {
    return new y.MathNode("mrow");
  }
});
E({
  type: "noTag",
  names: ["\\env@notag"],
  props: {
    numArgs: 0
  },
  handler({ parser: t }) {
    return {
      type: "noTag",
      mode: t.mode
    };
  },
  mathmlBuilder(t, e) {
    return new y.MathNode("mrow");
  }
});
var pi = (t, e) => {
  if (e !== "mathrm" || t.body.type !== "ordgroup" || t.body.body.length === 1 || t.body.body[0].type !== "mathord")
    return false;
  for (let n = 1; n < t.body.body.length; n++) {
    const r = t.body.body[n].type;
    if (!(r === "mathord" || r === "textord" && !isNaN(t.body.body[n].text)))
      return false;
  }
  return true;
};
var Wr = (t, e) => {
  const n = t.font, r = e.withFont(n), s = et(t.body, r);
  if (s.children.length === 0)
    return s;
  if (n === "boldsymbol" && ["mo", "mpadded", "mrow"].includes(s.type))
    return s.style.fontWeight = "bold", s;
  if (pi(t, n)) {
    const u = s.children[0].children[0];
    delete u.attributes.mathvariant;
    for (let m = 1; m < s.children.length; m++)
      u.children[0].text += s.children[m].type === "mn" ? s.children[m].children[0].text : s.children[m].children[0].children[0].text;
    const c = new y.MathNode("mtext", new y.TextNode("â€‹"));
    return new y.MathNode("mrow", [c, u]);
  }
  let a = s.children[0].type === "mo";
  for (let u = 1; u < s.children.length; u++)
    s.children[u].type === "mo" && n === "boldsymbol" && (s.children[u].style.fontWeight = "bold"), s.children[u].type !== "mi" && (a = false), (s.children[u].attributes && s.children[u].attributes.mathvariant || "") !== "normal" && (a = false);
  if (!a)
    return s;
  const l = s.children[0];
  for (let u = 1; u < s.children.length; u++)
    l.children.push(s.children[u].children[0]);
  if (l.attributes.mathvariant && l.attributes.mathvariant === "normal") {
    const u = new y.MathNode("mtext", new y.TextNode("â€‹"));
    return new y.MathNode("mrow", [u, l]);
  }
  return l;
};
var Yn = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
E({
  type: "font",
  names: [
    // styles
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    "\\up@greek",
    "\\boldsymbol",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases
    "\\Bbb",
    "\\bm",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: true
  },
  handler: ({ parser: t, funcName: e }, n) => {
    const r = Yt(n[0]);
    let s = e;
    return s in Yn && (s = Yn[s]), {
      type: "font",
      mode: t.mode,
      font: s.slice(1),
      body: r
    };
  },
  mathmlBuilder: Wr
});
E({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: ({ parser: t, funcName: e, breakOnTokenText: n }, r) => {
    const { mode: s } = t, a = t.parseExpression(true, n, true), l = `math${e.slice(1)}`;
    return {
      type: "font",
      mode: s,
      font: l,
      body: {
        type: "ordgroup",
        mode: t.mode,
        body: a
      }
    };
  },
  mathmlBuilder: Wr
});
var Kn = ["display", "text", "script", "scriptscript"];
var mi = { auto: -1, display: 0, text: 0, script: 1, scriptscript: 2 };
var bn = (t, e) => {
  const n = t.scriptLevel === "auto" ? e.incrementLevel() : t.scriptLevel === "display" ? e.withLevel(ot.TEXT) : t.scriptLevel === "text" ? e.withLevel(ot.SCRIPT) : e.withLevel(ot.SCRIPTSCRIPT);
  let r = new y.MathNode("mfrac", [
    et(t.numer, n),
    et(t.denom, n)
  ]);
  if (!t.hasBarLine)
    r.setAttribute("linethickness", "0px");
  else if (t.barSize) {
    const s = _t(t.barSize, e);
    r.setAttribute("linethickness", s.number + s.unit);
  }
  if (t.leftDelim != null || t.rightDelim != null) {
    const s = [];
    if (t.leftDelim != null) {
      const a = new y.MathNode("mo", [
        new y.TextNode(t.leftDelim.replace("\\", ""))
      ]);
      a.setAttribute("fence", "true"), s.push(a);
    }
    if (s.push(r), t.rightDelim != null) {
      const a = new y.MathNode("mo", [
        new y.TextNode(t.rightDelim.replace("\\", ""))
      ]);
      a.setAttribute("fence", "true"), s.push(a);
    }
    r = dn(s);
  }
  return t.scriptLevel !== "auto" && (r = new y.MathNode("mstyle", [r]), r.setAttribute("displaystyle", String(t.scriptLevel === "display")), r.setAttribute("scriptlevel", mi[t.scriptLevel])), r;
};
E({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // canâ€™t be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: true
  },
  handler: ({ parser: t, funcName: e }, n) => {
    const r = n[0], s = n[1];
    let a = false, l = null, u = null, c = "auto";
    switch (e) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        a = true;
        break;
      case "\\\\atopfrac":
        a = false;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        l = "(", u = ")";
        break;
      case "\\\\bracefrac":
        l = "\\{", u = "\\}";
        break;
      case "\\\\brackfrac":
        l = "[", u = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (e) {
      case "\\dfrac":
      case "\\dbinom":
        c = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        c = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: t.mode,
      continued: false,
      numer: r,
      denom: s,
      hasBarLine: a,
      leftDelim: l,
      rightDelim: u,
      scriptLevel: c,
      barSize: null
    };
  },
  mathmlBuilder: bn
});
E({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: ({ parser: t, funcName: e }, n) => {
    const r = n[0], s = n[1];
    return {
      type: "genfrac",
      mode: t.mode,
      continued: true,
      numer: r,
      denom: s,
      hasBarLine: true,
      leftDelim: null,
      rightDelim: null,
      scriptLevel: "display",
      barSize: null
    };
  }
});
E({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: true
  },
  handler({ parser: t, funcName: e, token: n }) {
    let r;
    switch (e) {
      case "\\over":
        r = "\\frac";
        break;
      case "\\choose":
        r = "\\binom";
        break;
      case "\\atop":
        r = "\\\\atopfrac";
        break;
      case "\\brace":
        r = "\\\\bracefrac";
        break;
      case "\\brack":
        r = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: t.mode,
      replaceWith: r,
      token: n
    };
  }
});
var Qn = function(t) {
  let e = null;
  return t.length > 0 && (e = t, e = e === "." ? null : e), e;
};
E({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: true,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler({ parser: t }, e) {
    const n = e[4], r = e[5], s = Yt(e[0]), a = s.type === "atom" && s.family === "open" ? Qn(s.text) : null, l = Yt(e[1]), u = l.type === "atom" && l.family === "close" ? Qn(l.text) : null, c = z(e[2], "size");
    let m, b = null;
    c.isBlank ? m = true : (b = c.value, m = b.number > 0);
    let A = "auto", x = e[3];
    if (x.type === "ordgroup") {
      if (x.body.length > 0) {
        const T = z(x.body[0], "textord");
        A = Kn[Number(T.text)];
      }
    } else
      x = z(x, "textord"), A = Kn[Number(x.text)];
    return {
      type: "genfrac",
      mode: t.mode,
      numer: n,
      denom: r,
      continued: false,
      hasBarLine: m,
      barSize: b,
      leftDelim: a,
      rightDelim: u,
      scriptLevel: A
    };
  },
  mathmlBuilder: bn
});
E({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: true
  },
  handler({ parser: t, funcName: e, token: n }, r) {
    return {
      type: "infix",
      mode: t.mode,
      replaceWith: "\\\\abovefrac",
      barSize: z(r[0], "size").value,
      token: n
    };
  }
});
E({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: ({ parser: t, funcName: e }, n) => {
    const r = n[0], s = _s(z(n[1], "infix").barSize), a = n[2], l = s.number > 0;
    return {
      type: "genfrac",
      mode: t.mode,
      numer: r,
      denom: a,
      continued: false,
      hasBarLine: l,
      barSize: s,
      leftDelim: null,
      rightDelim: null,
      scriptLevel: "auto"
    };
  },
  mathmlBuilder: bn
});
E({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInArgument: true,
    allowedInText: false
  },
  handler({ parser: t }, e) {
    return {
      type: "hbox",
      mode: t.mode,
      body: it(e[0])
    };
  },
  mathmlBuilder(t, e) {
    const n = e.withLevel(ot.TEXT), r = Mt(t.body, n);
    return hn(r);
  }
});
var fi = (t, e) => {
  const n = Ae.mathMLnode(t.label);
  return n.style["math-depth"] = 0, new y.MathNode(t.isOver ? "mover" : "munder", [
    et(t.base, e),
    n
  ]);
};
E({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler({ parser: t, funcName: e }, n) {
    return {
      type: "horizBrace",
      mode: t.mode,
      label: e,
      isOver: /^\\over/.test(e),
      base: n[0]
    };
  },
  mathmlBuilder: fi
});
E({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: true
  },
  handler: ({ parser: t, token: e }, n) => {
    const r = n[1], s = z(n[0], "url").url;
    if (!t.settings.isTrusted({
      command: "\\href",
      url: s
    }))
      throw new q('Function "\\href" is not trusted', e);
    return {
      type: "href",
      mode: t.mode,
      href: s,
      body: it(r)
    };
  },
  mathmlBuilder: (t, e) => {
    let n = Mt(t.body, e);
    return n instanceof ht || (n = new ht("mrow", [n])), n.setAttribute("href", t.href), n;
  }
});
E({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: true
  },
  handler: ({ parser: t, token: e }, n) => {
    const r = z(n[0], "url").url;
    if (!t.settings.isTrusted({
      command: "\\url",
      url: r
    }))
      throw new q('Function "\\url" is not trusted', e);
    const s = [];
    for (let l = 0; l < r.length; l++) {
      let u = r[l];
      u === "~" && (u = "\\textasciitilde"), s.push({
        type: "textord",
        mode: "text",
        text: u
      });
    }
    const a = {
      type: "text",
      mode: t.mode,
      font: "\\texttt",
      body: s
    };
    return {
      type: "href",
      mode: t.mode,
      href: r,
      body: it(a)
    };
  }
});
E({
  type: "html",
  names: ["\\class", "\\id", "\\style", "\\data"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: true
  },
  handler: ({ parser: t, funcName: e, token: n }, r) => {
    const s = z(r[0], "raw").string, a = r[1];
    if (t.settings.strict)
      throw new q(`Function "${e}" is disabled in strict mode`, n);
    let l;
    const u = {};
    switch (e) {
      case "\\class":
        u.class = s, l = {
          command: "\\class",
          class: s
        };
        break;
      case "\\id":
        u.id = s, l = {
          command: "\\id",
          id: s
        };
        break;
      case "\\style":
        u.style = s, l = {
          command: "\\style",
          style: s
        };
        break;
      case "\\data": {
        const c = s.split(",");
        for (let m = 0; m < c.length; m++) {
          const b = c[m].split("=");
          if (b.length !== 2)
            throw new q("Error parsing key-value for \\data");
          u["data-" + b[0].trim()] = b[1].trim();
        }
        l = {
          command: "\\data",
          attributes: u
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    if (!t.settings.isTrusted(l))
      throw new q(`Function "${e}" is not trusted`, n);
    return {
      type: "html",
      mode: t.mode,
      attributes: u,
      body: it(a)
    };
  },
  mathmlBuilder: (t, e) => {
    const n = Mt(t.body, e), r = [];
    t.attributes.class && r.push(...t.attributes.class.trim().split(/\s+/)), n.classes = r;
    for (const s in t.attributes)
      s !== "class" && Object.prototype.hasOwnProperty.call(t.attributes, s) && n.setAttribute(s, t.attributes[s]);
    return n;
  }
});
var Le = function(t) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(t))
    return { number: +t, unit: "bp" };
  {
    const e = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(t);
    if (!e)
      throw new q("Invalid size: '" + t + "' in \\includegraphics");
    const n = {
      number: +(e[1] + e[2]),
      // sign + magnitude, cast to number
      unit: e[3]
    };
    if (!Er(n))
      throw new q("Invalid unit: '" + n.unit + "' in \\includegraphics.");
    return n;
  }
};
E({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: false
  },
  handler: ({ parser: t, token: e }, n, r) => {
    let s = { number: 0, unit: "em" }, a = { number: 0.9, unit: "em" }, l = { number: 0, unit: "em" }, u = "";
    if (r[0]) {
      const b = z(r[0], "raw").string.split(",");
      for (let A = 0; A < b.length; A++) {
        const x = b[A].split("=");
        if (x.length === 2) {
          const T = x[1].trim();
          switch (x[0].trim()) {
            case "alt":
              u = T;
              break;
            case "width":
              s = Le(T);
              break;
            case "height":
              a = Le(T);
              break;
            case "totalheight":
              l = Le(T);
              break;
            default:
              throw new q("Invalid key: '" + x[0] + "' in \\includegraphics.");
          }
        }
      }
    }
    const c = z(n[0], "url").url;
    if (u === "" && (u = c, u = u.replace(/^.*[\\/]/, ""), u = u.substring(0, u.lastIndexOf("."))), !t.settings.isTrusted({
      command: "\\includegraphics",
      url: c
    }))
      throw new q('Function "\\includegraphics" is not trusted', e);
    return {
      type: "includegraphics",
      mode: t.mode,
      alt: u,
      width: s,
      height: a,
      totalheight: l,
      src: c
    };
  },
  mathmlBuilder: (t, e) => {
    const n = _t(t.height, e), r = { number: 0, unit: "em" };
    t.totalheight.number > 0 && t.totalheight.unit === n.unit && t.totalheight.number > n.number && (r.number = t.totalheight.number - n.number, r.unit = n.unit);
    let s = 0;
    t.width.number > 0 && (s = _t(t.width, e));
    const a = { height: n.number + r.number + "em" };
    s.number > 0 && (a.width = s.number + s.unit), r.number > 0 && (a.verticalAlign = -r.number + r.unit);
    const l = new Ms(t.src, t.alt, a);
    return l.height = n, l.depth = r, new y.MathNode("mtext", [l]);
  }
});
E({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: true,
    allowedInText: true
  },
  handler({ parser: t, funcName: e, token: n }, r) {
    const s = z(r[0], "size");
    if (t.settings.strict) {
      const a = e[1] === "m", l = s.value.unit === "mu";
      if (a) {
        if (!l)
          throw new q(`LaTeX's ${e} supports only mu units, not ${s.value.unit} units`, n);
        if (t.mode !== "math")
          throw new q(`LaTeX's ${e} works only in math mode`, n);
      } else if (l)
        throw new q(`LaTeX's ${e} doesn't support mu units`, n);
    }
    return {
      type: "kern",
      mode: t.mode,
      dimension: s.value
    };
  },
  mathmlBuilder(t, e) {
    const n = _t(t.dimension, e), r = n.unit === "em" ? Vr(n.number) : "";
    if (t.mode === "text" && r.length > 0) {
      const s = new y.TextNode(r);
      return new y.MathNode("mtext", [s]);
    } else {
      const s = new y.MathNode("mspace");
      return s.setAttribute("width", n.number + n.unit), n.number < 0 && (s.style.marginLeft = n.number + n.unit), s;
    }
  }
});
var Vr = function(t) {
  return t >= 0.05555 && t <= 0.05556 ? "â€Š" : t >= 0.1666 && t <= 0.1667 ? "â€‰" : t >= 0.2222 && t <= 0.2223 ? "â€…" : t >= 0.2777 && t <= 0.2778 ? "â€…â€Š" : "";
};
var Hr = /[^A-Za-z_0-9-]/g;
E({
  type: "label",
  names: ["\\label"],
  props: {
    numArgs: 1,
    argTypes: ["raw"]
  },
  handler({ parser: t }, e) {
    return {
      type: "label",
      mode: t.mode,
      string: e[0].string.replace(Hr, "")
    };
  },
  mathmlBuilder(t, e) {
    const n = new y.MathNode("mrow", [], ["tml-label"]);
    return t.string.length > 0 && n.setAttribute("id", t.string), n;
  }
});
var gi = ["\\clap", "\\llap", "\\rlap"];
E({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap", "\\clap", "\\llap", "\\rlap"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser: t, funcName: e, token: n }, r) => {
    if (gi.includes(e)) {
      if (t.settings.strict && t.mode !== "text")
        throw new q(`{${e}} can be used only in text mode.
 Try \\math${e.slice(1)}`, n);
      e = e.slice(1);
    } else
      e = e.slice(5);
    const s = r[0];
    return {
      type: "lap",
      mode: t.mode,
      alignment: e,
      body: s
    };
  },
  mathmlBuilder: (t, e) => {
    let n;
    if (t.alignment === "llap") {
      const a = dt(it(t.body), e), l = new y.MathNode("mphantom", a);
      n = new y.MathNode("mpadded", [l]), n.setAttribute("width", "0px");
    }
    const r = et(t.body, e);
    let s;
    if (t.alignment === "llap" ? (r.style.position = "absolute", r.style.right = "0", r.style.bottom = "0", s = new y.MathNode("mpadded", [n, r])) : s = new y.MathNode("mpadded", [r]), t.alignment === "rlap")
      t.body.body.length > 0 && t.body.body[0].type === "genfrac" && s.setAttribute("lspace", "0.16667em");
    else {
      const a = t.alignment === "llap" ? "-1" : "-0.5";
      s.setAttribute("lspace", a + "width"), t.alignment === "llap" ? s.style.position = "relative" : (s.style.display = "flex", s.style.justifyContent = "center");
    }
    return s.setAttribute("width", "0px"), s;
  }
});
E({
  type: "ordgroup",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler({ funcName: t, parser: e }, n) {
    const r = e.mode;
    e.switchMode("math");
    const s = t === "\\(" ? "\\)" : "$", a = e.parseExpression(false, s);
    return e.expect(s), e.switchMode(r), {
      type: "ordgroup",
      mode: e.mode,
      body: a
    };
  }
});
E({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler(t, e) {
    throw new q(`Mismatched ${t.funcName}`, e);
  }
});
var bi = (t, e) => {
  switch (e.level) {
    case ot.DISPLAY:
      return t.display;
    case ot.TEXT:
      return t.text;
    case ot.SCRIPT:
      return t.script;
    case ot.SCRIPTSCRIPT:
      return t.scriptscript;
    default:
      return t.text;
  }
};
E({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: true
  },
  handler: ({ parser: t }, e) => ({
    type: "mathchoice",
    mode: t.mode,
    display: it(e[0]),
    text: it(e[1]),
    script: it(e[2]),
    scriptscript: it(e[3])
  }),
  mathmlBuilder: (t, e) => {
    const n = bi(t, e);
    return Mt(n, e);
  }
});
var xi = ["text", "textord", "mathord", "atom"];
var Pt = (t) => {
  const e = new y.MathNode("mspace");
  return e.setAttribute("width", t + "em"), e;
};
function Zr(t, e) {
  let n;
  const r = dt(t.body, e);
  if (t.mclass === "minner")
    n = new y.MathNode("mpadded", r);
  else if (t.mclass === "mord")
    t.isCharacterBox || r[0].type === "mathord" ? (n = r[0], n.type = "mi", n.children.length === 1 && n.children[0].text && n.children[0].text === "âˆ‡" && n.setAttribute("mathvariant", "normal")) : n = new y.MathNode("mi", r);
  else {
    n = new y.MathNode("mrow", r), t.mustPromote ? (n = r[0], n.type = "mo", t.isCharacterBox && t.body[0].text && /[A-Za-z]/.test(t.body[0].text) && n.setAttribute("mathvariant", "italic")) : n = new y.MathNode("mrow", r);
    const s = e.level < 2;
    n.type === "mrow" ? s && (t.mclass === "mbin" ? (n.children.unshift(Pt(0.2222)), n.children.push(Pt(0.2222))) : t.mclass === "mrel" ? (n.children.unshift(Pt(0.2778)), n.children.push(Pt(0.2778))) : t.mclass === "mpunct" ? n.children.push(Pt(0.1667)) : t.mclass === "minner" && (n.children.unshift(Pt(0.0556)), n.children.push(Pt(0.0556)))) : t.mclass === "mbin" ? (n.attributes.lspace = s ? "0.2222em" : "0", n.attributes.rspace = s ? "0.2222em" : "0") : t.mclass === "mrel" ? (n.attributes.lspace = s ? "0.2778em" : "0", n.attributes.rspace = s ? "0.2778em" : "0") : t.mclass === "mpunct" ? (n.attributes.lspace = "0em", n.attributes.rspace = s ? "0.1667em" : "0") : t.mclass === "mopen" || t.mclass === "mclose" ? (n.attributes.lspace = "0em", n.attributes.rspace = "0em") : t.mclass === "minner" && s && (n.attributes.lspace = "0.0556em", n.attributes.width = "+0.1111em"), t.mclass === "mopen" || t.mclass === "mclose" || (delete n.attributes.stretchy, delete n.attributes.form);
  }
  return n;
}
E({
  type: "mclass",
  names: [
    "\\mathord",
    "\\mathbin",
    "\\mathrel",
    "\\mathopen",
    "\\mathclose",
    "\\mathpunct",
    "\\mathinner"
  ],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler({ parser: t, funcName: e }, n) {
    const r = n[0], s = Q.isCharacterBox(r);
    let a = true;
    const l = { type: "mathord", text: "", mode: t.mode }, u = r.body ? r.body : [r];
    for (const c of u)
      if (xi.includes(c.type))
        lt[t.mode][c.text] ? l.text += lt[t.mode][c.text].replace : c.text ? l.text += c.text : c.body && c.body.map((m) => {
          l.text += m.text;
        });
      else {
        a = false;
        break;
      }
    return {
      type: "mclass",
      mode: t.mode,
      mclass: "m" + e.slice(5),
      body: it(a ? l : r),
      isCharacterBox: s,
      mustPromote: a
    };
  },
  mathmlBuilder: Zr
});
var yi = (t) => {
  const e = t.type === "ordgroup" && t.body.length ? t.body[0] : t;
  return e.type === "atom" && (e.family === "bin" || e.family === "rel") ? "m" + e.family : "mord";
};
E({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler({ parser: t }, e) {
    return {
      type: "mclass",
      mode: t.mode,
      mclass: yi(e[0]),
      body: it(e[1]),
      isCharacterBox: Q.isCharacterBox(e[1])
    };
  }
});
E({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler({ parser: t, funcName: e }, n) {
    const r = n[1], s = n[0], a = {
      type: "op",
      mode: r.mode,
      limits: true,
      alwaysHandleSupSub: true,
      parentIsSupSub: false,
      symbol: false,
      stack: true,
      suppressBaseShift: e !== "\\stackrel",
      body: it(r)
    };
    return {
      type: "supsub",
      mode: s.mode,
      base: a,
      sup: e === "\\underset" ? null : s,
      sub: e === "\\underset" ? s : null
    };
  },
  mathmlBuilder: Zr
});
var de = (t, e, n) => {
  if (!t)
    return n;
  const r = et(t, e);
  return r.type === "mrow" && r.children.length === 0 ? n : r;
};
E({
  type: "multiscript",
  names: ["\\sideset", "\\pres@cript"],
  // See macros.js for \prescript
  props: {
    numArgs: 3
  },
  handler({ parser: t, funcName: e, token: n }, r) {
    if (r[2].body.length === 0)
      throw new q(e + "cannot parse an empty base.");
    const s = r[2].body[0];
    if (t.settings.strict && e === "\\sideset" && !s.symbol)
      throw new q("The base of \\sideset must be a big operator. Try \\prescript.");
    if (r[0].body.length > 0 && r[0].body[0].type !== "supsub" || r[1].body.length > 0 && r[1].body[0].type !== "supsub")
      throw new q("\\sideset can parse only subscripts and superscripts in its first two arguments", n);
    const a = r[0].body.length > 0 ? r[0].body[0] : null, l = r[1].body.length > 0 ? r[1].body[0] : null;
    return !a && !l ? s : a ? {
      type: "multiscript",
      mode: t.mode,
      isSideset: e === "\\sideset",
      prescripts: a,
      postscripts: l,
      base: s
    } : {
      type: "styling",
      mode: t.mode,
      scriptLevel: "text",
      body: [{
        type: "supsub",
        mode: t.mode,
        base: s,
        sup: l.sup,
        sub: l.sub
      }]
    };
  },
  mathmlBuilder(t, e) {
    const n = et(t.base, e), r = new y.MathNode("mprescripts"), s = new y.MathNode("none");
    let a = [];
    const l = de(t.prescripts.sub, e, s), u = de(t.prescripts.sup, e, s);
    if (t.isSideset && (l.setAttribute("style", "text-align: left;"), u.setAttribute("style", "text-align: left;")), t.postscripts) {
      const c = de(t.postscripts.sub, e, s), m = de(t.postscripts.sup, e, s);
      a = [n, c, m, r, l, u];
    } else
      a = [n, r, l, u];
    return new y.MathNode("mmultiscripts", a);
  }
});
E({
  type: "not",
  names: ["\\not"],
  props: {
    numArgs: 1,
    primitive: true,
    allowedInText: false
  },
  handler({ parser: t }, e) {
    const n = Q.isCharacterBox(e[0]);
    let r;
    return n ? (r = it(e[0]), r[0].text.charAt(0) === "\\" && (r[0].text = lt.math[r[0].text].replace), r[0].text = r[0].text.slice(0, 1) + "Ì¸" + r[0].text.slice(1)) : r = [{ type: "textord", mode: "math", text: "Ì¸" }, { type: "kern", mode: "math", dimension: { number: -0.6, unit: "em" } }, e[0]], {
      type: "not",
      mode: t.mode,
      body: r,
      isCharacterBox: n
    };
  },
  mathmlBuilder(t, e) {
    return t.isCharacterBox ? dt(t.body, e, true)[0] : Mt(t.body, e);
  }
});
var wi = ["textord", "mathord", "atom"];
var vi = ["\\smallint"];
var xn = ["textord", "mathord", "ordgroup", "close", "leftright", "font"];
var Jn = (t) => {
  t.attributes.lspace = "0.1667em", t.attributes.rspace = "0.1667em";
};
var ne = (t, e) => {
  let n;
  if (t.symbol)
    n = new ht("mo", [ft(t.name, t.mode)]), vi.includes(t.name) ? n.setAttribute("largeop", "false") : t.limits ? n.setAttribute("stretchy", "true") : n.setAttribute("movablelimits", "false"), t.fromMathOp && Jn(n);
  else if (t.body)
    n = new ht("mo", dt(t.body, e)), t.fromMathOp && Jn(n);
  else if (n = new ht("mi", [new Tr(t.name.slice(1))]), !t.parentIsSupSub) {
    const r = new ht("mo", [ft("â¡", "text")]), s = [n, r];
    if (t.needsLeadingSpace) {
      const a = new ht("mspace");
      a.setAttribute("width", "0.1667em"), s.unshift(a);
    }
    if (!t.isFollowedByDelimiter) {
      const a = new ht("mspace");
      a.setAttribute("width", "0.1667em"), s.push(a);
    }
    n = new ht("mrow", s);
  }
  return n;
};
var ki = {
  "âˆ": "\\prod",
  "âˆ": "\\coprod",
  "âˆ‘": "\\sum",
  "â‹€": "\\bigwedge",
  "â‹": "\\bigvee",
  "â‹‚": "\\bigcap",
  "â‹ƒ": "\\bigcup",
  "â¨€": "\\bigodot",
  "â¨": "\\bigoplus",
  "â¨‚": "\\bigotimes",
  "â¨„": "\\biguplus",
  "â¨…": "\\bigsqcap",
  "â¨†": "\\bigsqcup",
  "â¨ƒ": "\\bigcupdot",
  "â¨‡": "\\bigdoublevee",
  "â¨ˆ": "\\bigdoublewedge",
  "â¨‰": "\\bigtimes"
};
E({
  type: "op",
  names: [
    "\\coprod",
    "\\bigvee",
    "\\bigwedge",
    "\\biguplus",
    "\\bigcupplus",
    "\\bigcupdot",
    "\\bigcap",
    "\\bigcup",
    "\\bigdoublevee",
    "\\bigdoublewedge",
    "\\intop",
    "\\prod",
    "\\sum",
    "\\bigotimes",
    "\\bigoplus",
    "\\bigodot",
    "\\bigsqcap",
    "\\bigsqcup",
    "\\bigtimes",
    "\\smallint",
    "âˆ",
    "âˆ",
    "âˆ‘",
    "â‹€",
    "â‹",
    "â‹‚",
    "â‹ƒ",
    "â¨€",
    "â¨",
    "â¨‚",
    "â¨„",
    "â¨†"
  ],
  props: {
    numArgs: 0
  },
  handler: ({ parser: t, funcName: e }, n) => {
    let r = e;
    return r.length === 1 && (r = ki[r]), {
      type: "op",
      mode: t.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: true,
      stack: false,
      // This is true for \stackrel{}, not here.
      name: r
    };
  },
  mathmlBuilder: ne
});
E({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: ({ parser: t }, e) => {
    const n = e[0], r = n.body ? n.body : [n], s = r.length === 1 && wi.includes(r[0].type);
    return {
      type: "op",
      mode: t.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: s,
      fromMathOp: true,
      stack: false,
      name: s ? r[0].text : null,
      body: s ? null : it(n)
    };
  },
  mathmlBuilder: ne
});
var _i = {
  "âˆ«": "\\int",
  "âˆ¬": "\\iint",
  "âˆ­": "\\iiint",
  "âˆ®": "\\oint",
  "âˆ¯": "\\oiint",
  "âˆ°": "\\oiiint",
  "âˆ±": "\\intclockwise",
  "âˆ²": "\\varointclockwise",
  "â¨Œ": "\\iiiint",
  "â¨": "\\intbar",
  "â¨": "\\intBar",
  "â¨": "\\fint",
  "â¨’": "\\rppolint",
  "â¨“": "\\scpolint",
  "â¨•": "\\pointint",
  "â¨–": "\\sqint",
  "â¨—": "\\intlarhk",
  "â¨˜": "\\intx",
  "â¨™": "\\intcap",
  "â¨š": "\\intcup"
};
E({
  type: "op",
  names: [
    "\\arcsin",
    "\\arccos",
    "\\arctan",
    "\\arctg",
    "\\arcctg",
    "\\arg",
    "\\ch",
    "\\cos",
    "\\cosec",
    "\\cosh",
    "\\cot",
    "\\cotg",
    "\\coth",
    "\\csc",
    "\\ctg",
    "\\cth",
    "\\deg",
    "\\dim",
    "\\exp",
    "\\hom",
    "\\ker",
    "\\lg",
    "\\ln",
    "\\log",
    "\\sec",
    "\\sin",
    "\\sinh",
    "\\sh",
    "\\sgn",
    "\\tan",
    "\\tanh",
    "\\tg",
    "\\th"
  ],
  props: {
    numArgs: 0
  },
  handler({ parser: t, funcName: e }) {
    const n = t.prevAtomType, r = t.gullet.future().text;
    return {
      type: "op",
      mode: t.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      stack: false,
      isFollowedByDelimiter: Ne(r),
      needsLeadingSpace: n.length > 0 && xn.includes(n),
      name: e
    };
  },
  mathmlBuilder: ne
});
E({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler({ parser: t, funcName: e }) {
    const n = t.prevAtomType, r = t.gullet.future().text;
    return {
      type: "op",
      mode: t.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: false,
      stack: false,
      isFollowedByDelimiter: Ne(r),
      needsLeadingSpace: n.length > 0 && xn.includes(n),
      name: e
    };
  },
  mathmlBuilder: ne
});
E({
  type: "op",
  names: [
    "\\int",
    "\\iint",
    "\\iiint",
    "\\iiiint",
    "\\oint",
    "\\oiint",
    "\\oiiint",
    "\\intclockwise",
    "\\varointclockwise",
    "\\intbar",
    "\\intBar",
    "\\fint",
    "\\rppolint",
    "\\scpolint",
    "\\pointint",
    "\\sqint",
    "\\intlarhk",
    "\\intx",
    "\\intcap",
    "\\intcup",
    "âˆ«",
    "âˆ¬",
    "âˆ­",
    "âˆ®",
    "âˆ¯",
    "âˆ°",
    "âˆ±",
    "âˆ²",
    "â¨Œ",
    "â¨",
    "â¨",
    "â¨",
    "â¨’",
    "â¨“",
    "â¨•",
    "â¨–",
    "â¨—",
    "â¨˜",
    "â¨™",
    "â¨š"
  ],
  props: {
    numArgs: 0
  },
  handler({ parser: t, funcName: e }) {
    let n = e;
    return n.length === 1 && (n = _i[n]), {
      type: "op",
      mode: t.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: true,
      stack: false,
      name: n
    };
  },
  mathmlBuilder: ne
});
var Ai = (t, e) => {
  let n = dt(t.body, e.withFont("mathrm")), r = true;
  for (let a = 0; a < n.length; a++) {
    let l = n[a];
    if (l instanceof y.MathNode)
      switch (l.type === "mrow" && l.children.length === 1 && l.children[0] instanceof y.MathNode && (l = l.children[0]), l.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mtext":
          break;
        case "mspace":
          if (l.attributes.width) {
            const u = l.attributes.width.replace("em", ""), c = Vr(Number(u));
            c === "" ? r = false : n[a] = new y.MathNode("mtext", [new y.TextNode(c)]);
          }
          break;
        case "mo": {
          const u = l.children[0];
          l.children.length === 1 && u instanceof y.TextNode ? u.text = u.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : r = false;
          break;
        }
        default:
          r = false;
      }
    else
      r = false;
  }
  if (r) {
    const a = n.map((l) => l.toText()).join("");
    n = [new y.TextNode(a)];
  } else if (n.length === 1 && ["mover", "munder"].includes(n[0].type) && (n[0].children[0].type === "mi" || n[0].children[0].type === "mtext")) {
    if (n[0].children[0].type = "mi", t.parentIsSupSub)
      return new y.MathNode("mrow", n);
    {
      const a = new y.MathNode("mo", [ft("â¡", "text")]);
      return y.newDocumentFragment([n[0], a]);
    }
  }
  let s;
  if (r ? (s = new y.MathNode("mi", n), n[0].text.length === 1 && s.setAttribute("mathvariant", "normal")) : s = new y.MathNode("mrow", n), !t.parentIsSupSub) {
    const a = new y.MathNode("mo", [ft("â¡", "text")]), l = [s, a];
    if (t.needsLeadingSpace) {
      const u = new y.MathNode("mspace");
      u.setAttribute("width", "0.1667em"), l.unshift(u);
    }
    if (!t.isFollowedByDelimiter) {
      const u = new y.MathNode("mspace");
      u.setAttribute("width", "0.1667em"), l.push(u);
    }
    return y.newDocumentFragment(l);
  }
  return s;
};
E({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1,
    allowedInArgument: true
  },
  handler: ({ parser: t, funcName: e }, n) => {
    const r = n[0], s = t.prevAtomType, a = t.gullet.future().text;
    return {
      type: "operatorname",
      mode: t.mode,
      body: it(r),
      alwaysHandleSupSub: e === "\\operatornamewithlimits",
      limits: false,
      parentIsSupSub: false,
      isFollowedByDelimiter: Ne(a),
      needsLeadingSpace: s.length > 0 && xn.includes(s)
    };
  },
  mathmlBuilder: Ai
});
h(
  "\\operatorname",
  "\\@ifstar\\operatornamewithlimits\\operatorname@"
);
zt({
  type: "ordgroup",
  mathmlBuilder(t, e) {
    return Mt(t.body, e, t.semisimple);
  }
});
E({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser: t }, e) => {
    const n = e[0];
    return {
      type: "phantom",
      mode: t.mode,
      body: it(n)
    };
  },
  mathmlBuilder: (t, e) => {
    const n = dt(t.body, e);
    return new y.MathNode("mphantom", n);
  }
});
E({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser: t }, e) => {
    const n = e[0];
    return {
      type: "hphantom",
      mode: t.mode,
      body: n
    };
  },
  mathmlBuilder: (t, e) => {
    const n = dt(it(t.body), e), r = new y.MathNode("mphantom", n), s = new y.MathNode("mpadded", [r]);
    return s.setAttribute("height", "0px"), s.setAttribute("depth", "0px"), s;
  }
});
E({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser: t }, e) => {
    const n = e[0];
    return {
      type: "vphantom",
      mode: t.mode,
      body: n
    };
  },
  mathmlBuilder: (t, e) => {
    const n = dt(it(t.body), e), r = new y.MathNode("mphantom", n), s = new y.MathNode("mpadded", [r]);
    return s.setAttribute("width", "0px"), s;
  }
});
E({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler({ parser: t }, e) {
    return {
      type: "pmb",
      mode: t.mode,
      body: it(e[0])
    };
  },
  mathmlBuilder(t, e) {
    const n = dt(t.body, e), r = cn(n);
    return r.setAttribute("style", "font-weight:bold"), r;
  }
});
var Xr = (t, e) => {
  const n = e.withLevel(ot.TEXT), r = new y.MathNode("mpadded", [et(t.body, n)]), s = _t(t.dy, e);
  return r.setAttribute("voffset", s.number + s.unit), s.number > 0 ? r.style.padding = s.number + s.unit + " 0 0 0" : r.style.padding = "0 0 " + Math.abs(s.number) + s.unit + " 0", r;
};
E({
  type: "raise",
  names: ["\\raise", "\\lower"],
  props: {
    numArgs: 2,
    argTypes: ["size", "primitive"],
    primitive: true
  },
  handler({ parser: t, funcName: e }, n) {
    const r = z(n[0], "size").value;
    e === "\\lower" && (r.number *= -1);
    const s = n[1];
    return {
      type: "raise",
      mode: t.mode,
      dy: r,
      body: s
    };
  },
  mathmlBuilder: Xr
});
E({
  type: "raise",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: true
  },
  handler({ parser: t, funcName: e }, n) {
    const r = z(n[0], "size").value, s = n[1];
    return {
      type: "raise",
      mode: t.mode,
      dy: r,
      body: s
    };
  },
  mathmlBuilder: Xr
});
E({
  type: "ref",
  names: ["\\ref", "\\eqref"],
  props: {
    numArgs: 1,
    argTypes: ["raw"]
  },
  handler({ parser: t, funcName: e }, n) {
    return {
      type: "ref",
      mode: t.mode,
      funcName: e,
      string: n[0].string.replace(Hr, "")
    };
  },
  mathmlBuilder(t, e) {
    const n = t.funcName === "\\ref" ? ["tml-ref"] : ["tml-ref", "tml-eqref"], r = new y.MathNode("mtext", [new y.TextNode("")], n);
    return r.setAttribute("href", "#" + t.string), r;
  }
});
E({
  type: "reflect",
  names: ["\\reflectbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: true
  },
  handler({ parser: t }, e) {
    return {
      type: "reflect",
      mode: t.mode,
      body: e[0]
    };
  },
  mathmlBuilder(t, e) {
    const n = et(t.body, e);
    return n.style.transform = "scaleX(-1)", n;
  }
});
E({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler({ parser: t }) {
    return {
      type: "internal",
      mode: t.mode
    };
  }
});
E({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    argTypes: ["size", "size", "size"]
  },
  handler({ parser: t }, e, n) {
    const r = n[0], s = z(e[0], "size"), a = z(e[1], "size");
    return {
      type: "rule",
      mode: t.mode,
      shift: r && z(r, "size").value,
      width: s.value,
      height: a.value
    };
  },
  mathmlBuilder(t, e) {
    const n = _t(t.width, e), r = _t(t.height, e), s = t.shift ? _t(t.shift, e) : { number: 0, unit: "em" }, a = e.color && e.getColor() || "black", l = new y.MathNode("mspace");
    if (n.number > 0 && r.number > 0 && l.setAttribute("mathbackground", a), l.setAttribute("width", n.number + n.unit), l.setAttribute("height", r.number + r.unit), s.number === 0)
      return l;
    const u = new y.MathNode("mpadded", [l]);
    return s.number >= 0 ? u.setAttribute("height", "+" + s.number + s.unit) : (u.setAttribute("height", s.number + s.unit), u.setAttribute("depth", "+" + -s.number + s.unit)), u.setAttribute("voffset", s.number + s.unit), u;
  }
});
var tr = {
  "\\tiny": 0.5,
  "\\sixptsize": 0.6,
  "\\Tiny": 0.6,
  "\\scriptsize": 0.7,
  "\\footnotesize": 0.8,
  "\\small": 0.9,
  "\\normalsize": 1,
  "\\large": 1.2,
  "\\Large": 1.44,
  "\\LARGE": 1.728,
  "\\huge": 2.074,
  "\\Huge": 2.488
};
E({
  type: "sizing",
  names: [
    "\\tiny",
    "\\sixptsize",
    "\\Tiny",
    "\\scriptsize",
    "\\footnotesize",
    "\\small",
    "\\normalsize",
    "\\large",
    "\\Large",
    "\\LARGE",
    "\\huge",
    "\\Huge"
  ],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: ({ breakOnTokenText: t, funcName: e, parser: n }, r) => {
    n.settings.strict && n.mode === "math" && console.log(`Temml strict-mode warning: Command ${e} is invalid in math mode.`);
    const s = n.parseExpression(false, t, true);
    return {
      type: "sizing",
      mode: n.mode,
      funcName: e,
      body: s
    };
  },
  mathmlBuilder: (t, e) => {
    const n = e.withFontSize(tr[t.funcName]), r = dt(t.body, n), s = cn(r), a = (tr[t.funcName] / e.fontSize).toFixed(4);
    return s.setAttribute("mathsize", a + "em"), s;
  }
});
E({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true
  },
  handler: ({ parser: t }, e, n) => {
    let r = false, s = false;
    const a = n[0] && z(n[0], "ordgroup");
    if (a) {
      let u = "";
      for (let c = 0; c < a.body.length; ++c)
        if (u = a.body[c].text, u === "t")
          r = true;
        else if (u === "b")
          s = true;
        else {
          r = false, s = false;
          break;
        }
    } else
      r = true, s = true;
    const l = e[0];
    return {
      type: "smash",
      mode: t.mode,
      body: l,
      smashHeight: r,
      smashDepth: s
    };
  },
  mathmlBuilder: (t, e) => {
    const n = new y.MathNode("mpadded", [et(t.body, e)]);
    return t.smashHeight && n.setAttribute("height", "0px"), t.smashDepth && n.setAttribute("depth", "0px"), n;
  }
});
E({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler({ parser: t }, e, n) {
    const r = n[0], s = e[0];
    return {
      type: "sqrt",
      mode: t.mode,
      body: s,
      index: r
    };
  },
  mathmlBuilder(t, e) {
    const { body: n, index: r } = t;
    return r ? new y.MathNode("mroot", [
      et(n, e),
      et(r, e.incrementLevel())
    ]) : new y.MathNode("msqrt", [et(n, e)]);
  }
});
var Si = {
  display: 0,
  text: 1,
  script: 2,
  scriptscript: 3
};
var Ni = {
  display: ["0", "true"],
  text: ["0", "false"],
  script: ["1", "false"],
  scriptscript: ["2", "false"]
};
E({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ breakOnTokenText: t, funcName: e, parser: n }, r) {
    const s = n.parseExpression(true, t, true), a = e.slice(1, e.length - 5);
    return {
      type: "styling",
      mode: n.mode,
      // Figure out what scriptLevel to use by pulling out the scriptLevel from
      // the function name
      scriptLevel: a,
      body: s
    };
  },
  mathmlBuilder(t, e) {
    const n = e.withLevel(Si[t.scriptLevel]), r = dt(t.body, n), s = cn(r), a = Ni[t.scriptLevel];
    return s.setAttribute("scriptlevel", a[0]), s.setAttribute("displaystyle", a[1]), s;
  }
});
var Ci = /^m(over|under|underover)$/;
zt({
  type: "supsub",
  mathmlBuilder(t, e) {
    let n = false, r, s, a = false, l = false, u = false;
    t.base && t.base.type === "horizBrace" && (s = !!t.sup, s === t.base.isOver && (n = true, r = t.base.isOver)), t.base && !t.base.stack && (t.base.type === "op" || t.base.type === "operatorname") && (t.base.parentIsSupSub = true, a = !t.base.symbol, l = a && !t.isFollowedByDelimiter, u = t.base.needsLeadingSpace);
    const c = t.base && t.base.stack ? [et(t.base.body[0], e)] : [et(t.base, e)], m = e.inSubOrSup();
    if (t.sub && c.push(et(t.sub, m)), t.sup) {
      const x = et(t.sup, m), T = x.type === "mrow" ? x.children[0] : x;
      T && T.type === "mo" && T.classes.includes("tml-prime") && t.base && t.base.text && t.base.text === "f" && T.classes.push("prime-pad"), c.push(x);
    }
    let b;
    if (n)
      b = r ? "mover" : "munder";
    else if (t.sub)
      if (t.sup) {
        const x = t.base;
        x && (x.type === "op" && x.limits || x.type === "multiscript") && (e.level === ot.DISPLAY || x.alwaysHandleSupSub) || x && x.type === "operatorname" && x.alwaysHandleSupSub && (e.level === ot.DISPLAY || x.limits) ? b = "munderover" : b = "msubsup";
      } else {
        const x = t.base;
        x && x.type === "op" && x.limits && (e.level === ot.DISPLAY || x.alwaysHandleSupSub) || x && x.type === "operatorname" && x.alwaysHandleSupSub && (x.limits || e.level === ot.DISPLAY) ? b = "munder" : b = "msub";
      }
    else {
      const x = t.base;
      x && x.type === "op" && x.limits && (e.level === ot.DISPLAY || x.alwaysHandleSupSub) || x && x.type === "operatorname" && x.alwaysHandleSupSub && (x.limits || e.level === ot.DISPLAY) ? b = "mover" : b = "msup";
    }
    let A = new y.MathNode(b, c);
    if (a) {
      const x = new y.MathNode("mo", [ft("â¡", "text")]);
      if (u) {
        const T = new y.MathNode("mspace");
        T.setAttribute("width", "0.1667em"), A = y.newDocumentFragment([T, A, x]);
      } else
        A = y.newDocumentFragment([A, x]);
      if (l) {
        const T = new y.MathNode("mspace");
        T.setAttribute("width", "0.1667em"), A.children.push(T);
      }
    } else Ci.test(b) && (A = new y.MathNode("mrow", [A]));
    return A;
  }
});
var Ti = [
  "\\shortmid",
  "\\nshortmid",
  "\\shortparallel",
  "\\nshortparallel",
  "\\smallsetminus"
];
var qi = ["\\Rsh", "\\Lsh", "\\restriction"];
var Mi = (t) => {
  if (t.length === 1) {
    const e = t.codePointAt(0);
    return 8591 < e && e < 8704;
  }
  return t.indexOf("arrow") > -1 || t.indexOf("harpoon") > -1 || qi.includes(t);
};
zt({
  type: "atom",
  mathmlBuilder(t, e) {
    const n = new y.MathNode("mo", [ft(t.text, t.mode)]);
    return t.family === "punct" ? n.setAttribute("separator", "true") : t.family === "open" || t.family === "close" ? t.family === "open" ? (n.setAttribute("form", "prefix"), n.setAttribute("stretchy", "false")) : t.family === "close" && (n.setAttribute("form", "postfix"), n.setAttribute("stretchy", "false")) : t.text === "\\mid" ? (n.setAttribute("lspace", "0.22em"), n.setAttribute("rspace", "0.22em"), n.setAttribute("stretchy", "false")) : t.family === "rel" && Mi(t.text) ? n.setAttribute("stretchy", "false") : Ti.includes(t.text) ? n.setAttribute("mathsize", "70%") : t.text === ":" && (n.attributes.lspace = "0.2222em", n.attributes.rspace = "0.2222em"), n;
  }
});
var er = {
  // styles
  mathbf: "bold",
  mathrm: "normal",
  textit: "italic",
  mathit: "italic",
  mathnormal: "italic",
  // families
  mathbb: "double-struck",
  mathcal: "script",
  mathfrak: "fraktur",
  mathscr: "script",
  mathsf: "sans-serif",
  mathtt: "monospace"
};
var Yr = function(t, e) {
  if (e.fontFamily === "texttt")
    return "monospace";
  if (e.fontFamily === "textsc")
    return "normal";
  if (e.fontFamily === "textsf")
    return e.fontShape === "textit" && e.fontWeight === "textbf" ? "sans-serif-bold-italic" : e.fontShape === "textit" ? "sans-serif-italic" : e.fontWeight === "textbf" ? "sans-serif-bold" : "sans-serif";
  if (e.fontShape === "textit" && e.fontWeight === "textbf")
    return "bold-italic";
  if (e.fontShape === "textit")
    return "italic";
  if (e.fontWeight === "textbf")
    return "bold";
  const n = e.font;
  if (!n || n === "mathnormal")
    return null;
  const r = t.mode;
  switch (n) {
    case "mathit":
      return "italic";
    case "mathrm": {
      const a = t.text.codePointAt(0);
      return 939 < a && a < 975 ? "italic" : "normal";
    }
    case "greekItalic":
      return "italic";
    case "up@greek":
      return "normal";
    case "boldsymbol":
    case "mathboldsymbol":
      return "bold-italic";
    case "mathbf":
      return "bold";
    case "mathbb":
      return "double-struck";
    case "mathfrak":
      return "fraktur";
    case "mathscr":
    case "mathcal":
      return "script";
    case "mathsf":
      return "sans-serif";
    case "mathtt":
      return "monospace";
  }
  let s = t.text;
  return lt[r][s] && lt[r][s].replace && (s = lt[r][s].replace), Object.prototype.hasOwnProperty.call(er, n) ? er[n] : null;
};
var nr = Object.freeze({
  B: 8426,
  // Offset from ASCII B to Unicode script B
  E: 8427,
  F: 8427,
  H: 8387,
  I: 8391,
  L: 8390,
  M: 8422,
  R: 8393,
  e: 8394,
  g: 8355,
  o: 8389
});
var Oi = Object.freeze({
  C: 8426,
  H: 8388,
  I: 8392,
  R: 8394,
  Z: 8398
});
var Ei = Object.freeze({
  C: 8383,
  // blackboard bold
  H: 8389,
  N: 8391,
  P: 8393,
  Q: 8393,
  R: 8395,
  Z: 8394
});
var Kr = Object.freeze({
  "Ïµ": 119527,
  // lunate epsilon
  Ï‘: 119564,
  // vartheta
  Ï°: 119534,
  // varkappa
  Ï†: 119577,
  // varphi
  Ï±: 119535,
  // varrho
  Ï–: 119563
  // varpi
});
var $i = Object.freeze({
  "Ïµ": 119643,
  // lunate epsilon
  Ï‘: 119680,
  // vartheta
  Ï°: 119650,
  // varkappa
  Ï†: 119693,
  // varphi
  Ï±: 119651,
  // varrho
  Ï–: 119679
  // varpi
});
var rr = Object.freeze({
  "Ïµ": 119701,
  // lunate epsilon
  Ï‘: 119738,
  // vartheta
  Ï°: 119708,
  // varkappa
  Ï†: 119751,
  // varphi
  Ï±: 119709,
  // varrho
  Ï–: 119737
  // varpi
});
var Ii = Object.freeze({
  "Ïµ": 119759,
  // lunate epsilon
  Ï‘: 119796,
  // vartheta
  Ï°: 119766,
  // varkappa
  Ï†: 119809,
  // varphi
  Ï±: 119767,
  // varrho
  Ï–: 119795
  // varpi
});
var Di = Object.freeze({
  upperCaseLatin: {
    // A-Z
    normal: (t) => 0,
    bold: (t) => 119743,
    italic: (t) => 119795,
    "bold-italic": (t) => 119847,
    script: (t) => nr[t] || 119899,
    "script-bold": (t) => 119951,
    fraktur: (t) => Oi[t] || 120003,
    "fraktur-bold": (t) => 120107,
    "double-struck": (t) => Ei[t] || 120055,
    "sans-serif": (t) => 120159,
    "sans-serif-bold": (t) => 120211,
    "sans-serif-italic": (t) => 120263,
    "sans-serif-bold-italic": (t) => 120380,
    monospace: (t) => 120367
  },
  lowerCaseLatin: {
    // a-z
    normal: (t) => 0,
    bold: (t) => 119737,
    italic: (t) => t === "h" ? 8358 : 119789,
    "bold-italic": (t) => 119841,
    script: (t) => nr[t] || 119893,
    "script-bold": (t) => 119945,
    fraktur: (t) => 119997,
    "fraktur-bold": (t) => 120101,
    "double-struck": (t) => 120049,
    "sans-serif": (t) => 120153,
    "sans-serif-bold": (t) => 120205,
    "sans-serif-italic": (t) => 120257,
    "sans-serif-bold-italic": (t) => 120309,
    monospace: (t) => 120361
  },
  upperCaseGreek: {
    // A-Î©
    normal: (t) => 0,
    bold: (t) => 119575,
    italic: (t) => 119633,
    // \boldsymbol actually returns upright bold for upperCaseGreek
    "bold-italic": (t) => 119575,
    script: (t) => 0,
    "script-bold": (t) => 0,
    fraktur: (t) => 0,
    "fraktur-bold": (t) => 0,
    "double-struck": (t) => 0,
    // Unicode has no code points for regular-weight san-serif Greek. Use bold.
    "sans-serif": (t) => 119749,
    "sans-serif-bold": (t) => 119749,
    "sans-serif-italic": (t) => 0,
    "sans-serif-bold-italic": (t) => 119807,
    monospace: (t) => 0
  },
  lowerCaseGreek: {
    // Î±-Ï‰
    normal: (t) => 0,
    bold: (t) => 119569,
    italic: (t) => 119627,
    "bold-italic": (t) => t === "Ï•" ? 119678 : 119685,
    script: (t) => 0,
    "script-bold": (t) => 0,
    fraktur: (t) => 0,
    "fraktur-bold": (t) => 0,
    "double-struck": (t) => 0,
    // Unicode has no code points for regular-weight san-serif Greek. Use bold.
    "sans-serif": (t) => 119743,
    "sans-serif-bold": (t) => 119743,
    "sans-serif-italic": (t) => 0,
    "sans-serif-bold-italic": (t) => 119801,
    monospace: (t) => 0
  },
  varGreek: {
    // \varGamma, etc
    normal: (t) => 0,
    bold: (t) => Kr[t] || -51,
    italic: (t) => 0,
    "bold-italic": (t) => $i[t] || 58,
    script: (t) => 0,
    "script-bold": (t) => 0,
    fraktur: (t) => 0,
    "fraktur-bold": (t) => 0,
    "double-struck": (t) => 0,
    "sans-serif": (t) => rr[t] || 116,
    "sans-serif-bold": (t) => rr[t] || 116,
    "sans-serif-italic": (t) => 0,
    "sans-serif-bold-italic": (t) => Ii[t] || 174,
    monospace: (t) => 0
  },
  numeral: {
    // 0-9
    normal: (t) => 0,
    bold: (t) => 120734,
    italic: (t) => 0,
    "bold-italic": (t) => 0,
    script: (t) => 0,
    "script-bold": (t) => 0,
    fraktur: (t) => 0,
    "fraktur-bold": (t) => 0,
    "double-struck": (t) => 120744,
    "sans-serif": (t) => 120754,
    "sans-serif-bold": (t) => 120764,
    "sans-serif-italic": (t) => 0,
    "sans-serif-bold-italic": (t) => 0,
    monospace: (t) => 120774
  }
});
var Xt = (t, e) => {
  const n = t.codePointAt(0), r = 64 < n && n < 91 ? "upperCaseLatin" : 96 < n && n < 123 ? "lowerCaseLatin" : 912 < n && n < 938 ? "upperCaseGreek" : 944 < n && n < 970 || t === "Ï•" ? "lowerCaseGreek" : 120545 < n && n < 120572 || Kr[t] ? "varGreek" : 47 < n && n < 58 ? "numeral" : "other";
  return r === "other" ? t : String.fromCodePoint(n + Di[r][e](t));
};
var Pi = Object.freeze({
  a: "á´€",
  b: "Ê™",
  c: "á´„",
  d: "á´…",
  e: "á´‡",
  f: "êœ°",
  g: "É¢",
  h: "Êœ",
  i: "Éª",
  j: "á´Š",
  k: "á´‹",
  l: "ÊŸ",
  m: "á´",
  n: "É´",
  o: "á´",
  p: "á´˜",
  q: "Ç«",
  r: "Ê€",
  s: "s",
  t: "á´›",
  u: "á´œ",
  v: "á´ ",
  w: "á´¡",
  x: "x",
  y: "Ê",
  z: "á´¢"
});
var Bi = /^\d(?:[\d,.]*\d)?$/;
var Li = /[A-Ba-z]/;
var Fi = /* @__PURE__ */ new Set([
  "\\prime",
  "\\dprime",
  "\\trprime",
  "\\qprime",
  "\\backprime",
  "\\backdprime",
  "\\backtrprime"
]);
var zi = (t, e, n) => {
  const r = new y.MathNode(n, [t]), s = new y.MathNode("mstyle", [r]);
  return s.style["font-style"] = "italic", s.style["font-family"] = "Cambria, 'Times New Roman', serif", e === "bold-italic" && (s.style["font-weight"] = "bold"), s;
};
zt({
  type: "mathord",
  mathmlBuilder(t, e) {
    const n = ft(t.text, t.mode, e), r = n.text.codePointAt(0), s = 912 < r && r < 938 ? "normal" : "italic", a = Yr(t, e) || s;
    if (a === "script")
      return n.text = Xt(n.text, a), new y.MathNode("mi", [n], [e.font]);
    a !== "italic" && (n.text = Xt(n.text, a));
    let l = new y.MathNode("mi", [n]);
    return a === "normal" && (l.setAttribute("mathvariant", "normal"), n.text.length === 1 && (l = new y.MathNode("mrow", [l]))), l;
  }
});
zt({
  type: "textord",
  mathmlBuilder(t, e) {
    let n = t.text;
    const r = n.codePointAt(0);
    e.fontFamily === "textsc" && 96 < r && r < 123 && (n = Pi[n]);
    const s = ft(n, t.mode, e), a = Yr(t, e) || "normal";
    let l;
    if (Bi.test(t.text)) {
      const u = t.mode === "text" ? "mtext" : "mn";
      if (a === "italic" || a === "bold-italic")
        return zi(s, a, u);
      a !== "normal" && (s.text = s.text.split("").map((c) => Xt(c, a)).join("")), l = new y.MathNode(u, [s]);
    } else if (t.mode === "text")
      a !== "normal" && (s.text = Xt(s.text, a)), l = new y.MathNode("mtext", [s]);
    else if (Fi.has(t.text))
      l = new y.MathNode("mo", [s]), l.classes.push("tml-prime");
    else {
      const u = s.text;
      a !== "italic" && (s.text = Xt(s.text, a)), l = new y.MathNode("mi", [s]), s.text === u && Li.test(u) && l.setAttribute("mathvariant", "italic");
    }
    return l;
  }
});
var ji = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
};
var Gi = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
zt({
  type: "spacing",
  mathmlBuilder(t, e) {
    let n;
    if (Object.prototype.hasOwnProperty.call(Gi, t.text))
      n = new y.MathNode("mtext", [new y.TextNode("Â ")]);
    else if (Object.prototype.hasOwnProperty.call(ji, t.text))
      n = new y.MathNode("mo"), t.text === "\\nobreak" && n.setAttribute("linebreak", "nobreak");
    else
      throw new q(`Unknown type of space "${t.text}"`);
    return n;
  }
});
zt({
  type: "tag"
});
var sr = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm",
  "\\textsc": "textsc"
  // small caps
};
var ir = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
};
var Ri = {
  "\\textit": "textit",
  "\\textup": "textup"
};
var Ui = (t, e) => {
  const n = t.font;
  if (n) {
    if (sr[n])
      return e.withTextFontFamily(sr[n]);
    if (ir[n])
      return e.withTextFontWeight(ir[n]);
    if (n === "\\emph")
      return e.fontShape === "textit" ? e.withTextFontShape("textup") : e.withTextFontShape("textit");
  } else return e;
  return e.withTextFontShape(Ri[n]);
};
E({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    "\\textsc",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: true,
    allowedInText: true
  },
  handler({ parser: t, funcName: e }, n) {
    const r = n[0];
    return {
      type: "text",
      mode: t.mode,
      body: it(r),
      font: e
    };
  },
  mathmlBuilder(t, e) {
    const n = Ui(t, e), r = Mt(t.body, n);
    return hn(r);
  }
});
E({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(t, e, n) {
    throw new q("\\verb ended by end of line instead of matching delimiter");
  },
  mathmlBuilder(t, e) {
    const n = new y.TextNode(Wi(t)), r = new y.MathNode("mtext", [n]);
    return r.setAttribute("mathvariant", "monospace"), r;
  }
});
var Wi = (t) => t.body.replace(/ /g, t.star ? "â£" : "Â ");
var Lt = Nr;
var mt = class _mt {
  constructor(e, n, r) {
    this.lexer = e, this.start = n, this.end = r;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(e, n) {
    return n ? !e || !e.loc || !n.loc || e.loc.lexer !== n.loc.lexer ? null : new _mt(e.loc.lexer, e.loc.start, n.loc.end) : e && e.loc;
  }
};
var At = class _At {
  constructor(e, n) {
    this.text = e, this.loc = n;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(e, n) {
    return new _At(n, mt.range(this, e));
  }
};
var Qr = `[ \r
	]`;
var Vi = "\\\\[a-zA-Z@]+";
var Hi = "\\\\[^\uD800-\uDFFF]";
var Zi = `(${Vi})${Qr}*`;
var Xi = `\\\\(
|[ \r	]+
?)[ \r	]*`;
var nn = "[Ì€-Í¯]";
var ar = new RegExp(`${nn}+$`);
var Yi = `(${Qr}+)|${Xi}|([!-\\[\\]-â€§â€ª-íŸ¿ï¤€-ï¿¿]${nn}*|[\uD800-\uDBFF][\uDC00-\uDFFF]${nn}*|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5|${Zi}|${Hi})`;
var or = class {
  constructor(e, n) {
    this.input = e, this.settings = n, this.tokenRegex = new RegExp(Yi, "g"), this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(e, n) {
    this.catcodes[e] = n;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    const e = this.input, n = this.tokenRegex.lastIndex;
    if (n === e.length)
      return new At("EOF", new mt(this, n, n));
    const r = this.tokenRegex.exec(e);
    if (r === null || r.index !== n)
      throw new q(
        `Unexpected character: '${e[n]}'`,
        new At(e[n], new mt(this, n, n + 1))
      );
    const s = r[6] || r[3] || (r[2] ? "\\ " : " ");
    if (this.catcodes[s] === 14) {
      const a = e.indexOf(`
`, this.tokenRegex.lastIndex);
      if (a === -1) {
        if (this.tokenRegex.lastIndex = e.length, this.settings.strict)
          throw new q("% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode");
      } else
        this.tokenRegex.lastIndex = a + 1;
      return this.lex();
    }
    return new At(s, new mt(this, n, this.tokenRegex.lastIndex));
  }
};
var Ki = class {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(e = {}, n = {}) {
    this.current = n, this.builtins = e, this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0)
      throw new q(
        "Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug"
      );
    const e = this.undefStack.pop();
    for (const n in e)
      Object.prototype.hasOwnProperty.call(e, n) && (e[n] === void 0 ? delete this.current[n] : this.current[n] = e[n]);
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(e) {
    return Object.prototype.hasOwnProperty.call(this.current, e) || Object.prototype.hasOwnProperty.call(this.builtins, e);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(e) {
    return Object.prototype.hasOwnProperty.call(this.current, e) ? this.current[e] : this.builtins[e];
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   */
  set(e, n, r = false) {
    if (r) {
      for (let s = 0; s < this.undefStack.length; s++)
        delete this.undefStack[s][e];
      this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][e] = n);
    } else {
      const s = this.undefStack[this.undefStack.length - 1];
      s && !Object.prototype.hasOwnProperty.call(s, e) && (s[e] = this.current[e]);
    }
    this.current[e] = n;
  }
};
var Jr = {
  "^": true,
  // Parser.js
  _: true,
  // Parser.js
  "\\limits": true,
  // Parser.js
  "\\nolimits": true
  // Parser.js
};
var Qi = class {
  constructor(e, n, r) {
    this.settings = n, this.expansionCount = 0, this.feed(e), this.macros = new Ki(ui, n.macros), this.mode = r, this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(e) {
    this.lexer = new or(e, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    return this.stack.length === 0 && this.pushToken(this.lexer.lex()), this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    return this.future(), this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(e) {
    this.stack.push(e);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(e) {
    this.stack.push(...e);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(e) {
    let n, r, s;
    if (e) {
      if (this.consumeSpaces(), this.future().text !== "[")
        return null;
      n = this.popToken(), { tokens: s, end: r } = this.consumeArg(["]"]);
    } else
      ({ tokens: s, start: n, end: r } = this.consumeArg());
    return this.pushToken(new At("EOF", r.loc)), this.pushTokens(s), n.range(r, "");
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; this.future().text === " "; )
      this.stack.pop();
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(e) {
    const n = [], r = e && e.length > 0;
    r || this.consumeSpaces();
    const s = this.future();
    let a, l = 0, u = 0;
    do {
      if (a = this.popToken(), n.push(a), a.text === "{")
        ++l;
      else if (a.text === "}") {
        if (--l, l === -1)
          throw new q("Extra }", a);
      } else if (a.text === "EOF")
        throw new q(
          "Unexpected end of input in a macro argument, expected '" + (e && r ? e[u] : "}") + "'",
          a
        );
      if (e && r)
        if ((l === 0 || l === 1 && e[u] === "{") && a.text === e[u]) {
          if (++u, u === e.length) {
            n.splice(-u, u);
            break;
          }
        } else
          u = 0;
    } while (l !== 0 || r);
    return s.text === "{" && n[n.length - 1].text === "}" && (n.pop(), n.shift()), n.reverse(), { tokens: n, start: s, end: a };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(e, n) {
    if (n) {
      if (n.length !== e + 1)
        throw new q("The length of delimiters doesn't match the number of args!");
      const s = n[0];
      for (let a = 0; a < s.length; a++) {
        const l = this.popToken();
        if (s[a] !== l.text)
          throw new q("Use of the macro doesn't match its definition", l);
      }
    }
    const r = [];
    for (let s = 0; s < e; s++)
      r.push(this.consumeArg(n && n[s + 1]).tokens);
    return r;
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(e) {
    const n = this.popToken(), r = n.text, s = n.noexpand ? null : this._getExpansion(r);
    if (s == null || e && s.unexpandable) {
      if (e && s == null && r[0] === "\\" && !this.isDefined(r))
        throw new q("Undefined control sequence: " + r);
      return this.pushToken(n), false;
    }
    if (this.expansionCount++, this.expansionCount > this.settings.maxExpand)
      throw new q(
        "Too many expansions: infinite loop or need to increase maxExpand setting"
      );
    let a = s.tokens;
    const l = this.consumeArgs(s.numArgs, s.delimiters);
    if (s.numArgs) {
      a = a.slice();
      for (let u = a.length - 1; u >= 0; --u) {
        let c = a[u];
        if (c.text === "#") {
          if (u === 0)
            throw new q("Incomplete placeholder at end of macro body", c);
          if (c = a[--u], c.text === "#")
            a.splice(u + 1, 1);
          else if (/^[1-9]$/.test(c.text))
            a.splice(u, 2, ...l[+c.text - 1]);
          else
            throw new q("Not a valid argument number", c);
        }
      }
    }
    return this.pushTokens(a), a.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    return this.expandOnce(), this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; )
      if (this.expandOnce() === false) {
        const e = this.stack.pop();
        return e.treatAsRelax && (e.text = "\\relax"), e;
      }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(e) {
    return this.macros.has(e) ? this.expandTokens([new At(e)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(e) {
    const n = [], r = this.stack.length;
    for (this.pushTokens(e); this.stack.length > r; )
      if (this.expandOnce(true) === false) {
        const s = this.stack.pop();
        s.treatAsRelax && (s.noexpand = false, s.treatAsRelax = false), n.push(s);
      }
    return n;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(e) {
    const n = this.expandMacro(e);
    return n && n.map((r) => r.text).join("");
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(e) {
    const n = this.macros.get(e);
    if (n == null)
      return n;
    if (e.length === 1) {
      const s = this.lexer.catcodes[e];
      if (s != null && s !== 13)
        return;
    }
    const r = typeof n == "function" ? n(this) : n;
    if (typeof r == "string") {
      let s = 0;
      if (r.indexOf("#") !== -1) {
        const m = r.replace(/##/g, "");
        for (; m.indexOf("#" + (s + 1)) !== -1; )
          ++s;
      }
      const a = new or(r, this.settings), l = [];
      let u = a.lex();
      for (; u.text !== "EOF"; )
        l.push(u), u = a.lex();
      return l.reverse(), { tokens: l, numArgs: s };
    }
    return r;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(e) {
    return this.macros.has(e) || Object.prototype.hasOwnProperty.call(Lt, e) || Object.prototype.hasOwnProperty.call(lt.math, e) || Object.prototype.hasOwnProperty.call(lt.text, e) || Object.prototype.hasOwnProperty.call(Jr, e);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(e) {
    const n = this.macros.get(e);
    return n != null ? typeof n == "string" || typeof n == "function" || !n.unexpandable : Object.prototype.hasOwnProperty.call(Lt, e) && !Lt[e].primitive;
  }
};
var lr = /^[â‚Šâ‚‹â‚Œâ‚â‚â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰â‚â‚‘â‚•áµ¢â±¼â‚–â‚—â‚˜â‚™â‚’â‚šáµ£â‚›â‚œáµ¤áµ¥â‚“áµ¦áµ§áµ¨áµ©áµª]/;
var pe = Object.freeze({
  "â‚Š": "+",
  "â‚‹": "-",
  "â‚Œ": "=",
  "â‚": "(",
  "â‚": ")",
  "â‚€": "0",
  "â‚": "1",
  "â‚‚": "2",
  "â‚ƒ": "3",
  "â‚„": "4",
  "â‚…": "5",
  "â‚†": "6",
  "â‚‡": "7",
  "â‚ˆ": "8",
  "â‚‰": "9",
  "â‚": "a",
  "â‚‘": "e",
  "â‚•": "h",
  "áµ¢": "i",
  "â±¼": "j",
  "â‚–": "k",
  "â‚—": "l",
  "â‚˜": "m",
  "â‚™": "n",
  "â‚’": "o",
  "â‚š": "p",
  "áµ£": "r",
  "â‚›": "s",
  "â‚œ": "t",
  "áµ¤": "u",
  "áµ¥": "v",
  "â‚“": "x",
  "áµ¦": "Î²",
  "áµ§": "Î³",
  "áµ¨": "Ï",
  "áµ©": "Ï•",
  "áµª": "Ï‡",
  "âº": "+",
  "â»": "-",
  "â¼": "=",
  "â½": "(",
  "â¾": ")",
  "â°": "0",
  "Â¹": "1",
  "Â²": "2",
  "Â³": "3",
  "â´": "4",
  "âµ": "5",
  "â¶": "6",
  "â·": "7",
  "â¸": "8",
  "â¹": "9",
  "á´¬": "A",
  "á´®": "B",
  "á´°": "D",
  "á´±": "E",
  "á´³": "G",
  "á´´": "H",
  "á´µ": "I",
  "á´¶": "J",
  "á´·": "K",
  "á´¸": "L",
  "á´¹": "M",
  "á´º": "N",
  "á´¼": "O",
  "á´¾": "P",
  "á´¿": "R",
  "áµ€": "T",
  "áµ": "U",
  "â±½": "V",
  "áµ‚": "W",
  "áµƒ": "a",
  "áµ‡": "b",
  "á¶œ": "c",
  "áµˆ": "d",
  "áµ‰": "e",
  "á¶ ": "f",
  "áµ": "g",
  Ê°: "h",
  "â±": "i",
  Ê²: "j",
  "áµ": "k",
  Ë¡: "l",
  "áµ": "m",
  â¿: "n",
  "áµ’": "o",
  "áµ–": "p",
  Ê³: "r",
  Ë¢: "s",
  "áµ—": "t",
  "áµ˜": "u",
  "áµ›": "v",
  Ê·: "w",
  Ë£: "x",
  Ê¸: "y",
  "á¶»": "z",
  "áµ": "Î²",
  "áµ": "Î³",
  "áµŸ": "Î´",
  "áµ ": "Ï•",
  "áµ¡": "Ï‡",
  "á¶¿": "Î¸"
});
var ur = Object.freeze({
  "ğ’œ": "A",
  â„¬: "B",
  "ğ’": "C",
  "ğ’Ÿ": "D",
  â„°: "E",
  â„±: "F",
  "ğ’¢": "G",
  â„‹: "H",
  â„: "I",
  "ğ’¥": "J",
  "ğ’¦": "K",
  â„’: "L",
  â„³: "M",
  "ğ’©": "N",
  "ğ’ª": "O",
  "ğ’«": "P",
  "ğ’¬": "Q",
  â„›: "R",
  "ğ’®": "S",
  "ğ’¯": "T",
  "ğ’°": "U",
  "ğ’±": "V",
  "ğ’²": "W",
  "ğ’³": "X",
  "ğ’´": "Y",
  "ğ’µ": "Z"
});
var Fe = {
  "Ì": { text: "\\'", math: "\\acute" },
  "Ì€": { text: "\\`", math: "\\grave" },
  "Ìˆ": { text: '\\"', math: "\\ddot" },
  "Ìƒ": { text: "\\~", math: "\\tilde" },
  "Ì„": { text: "\\=", math: "\\bar" },
  "Ì†": { text: "\\u", math: "\\breve" },
  "ÌŒ": { text: "\\v", math: "\\check" },
  "Ì‚": { text: "\\^", math: "\\hat" },
  "Ì‡": { text: "\\.", math: "\\dot" },
  "ÌŠ": { text: "\\r", math: "\\mathring" },
  "Ì‹": { text: "\\H" },
  "Ì§": { text: "\\c" }
};
var cr = {
  Ã¡: "aÌ",
  Ã : "aÌ€",
  Ã¤: "aÌˆ",
  ÇŸ: "aÌˆÌ„",
  Ã£: "aÌƒ",
  Ä: "aÌ„",
  Äƒ: "aÌ†",
  áº¯: "aÌ†Ì",
  áº±: "aÌ†Ì€",
  áºµ: "aÌ†Ìƒ",
  Ç: "aÌŒ",
  Ã¢: "aÌ‚",
  áº¥: "aÌ‚Ì",
  áº§: "aÌ‚Ì€",
  áº«: "aÌ‚Ìƒ",
  È§: "aÌ‡",
  Ç¡: "aÌ‡Ì„",
  Ã¥: "aÌŠ",
  Ç»: "aÌŠÌ",
  á¸ƒ: "bÌ‡",
  Ä‡: "cÌ",
  Ä: "cÌŒ",
  Ä‰: "cÌ‚",
  Ä‹: "cÌ‡",
  Ä: "dÌŒ",
  á¸‹: "dÌ‡",
  Ã©: "eÌ",
  Ã¨: "eÌ€",
  Ã«: "eÌˆ",
  áº½: "eÌƒ",
  Ä“: "eÌ„",
  á¸—: "eÌ„Ì",
  á¸•: "eÌ„Ì€",
  Ä•: "eÌ†",
  Ä›: "eÌŒ",
  Ãª: "eÌ‚",
  áº¿: "eÌ‚Ì",
  á»: "eÌ‚Ì€",
  á»…: "eÌ‚Ìƒ",
  Ä—: "eÌ‡",
  á¸Ÿ: "fÌ‡",
  Çµ: "gÌ",
  á¸¡: "gÌ„",
  ÄŸ: "gÌ†",
  Ç§: "gÌŒ",
  Ä: "gÌ‚",
  Ä¡: "gÌ‡",
  á¸§: "hÌˆ",
  ÈŸ: "hÌŒ",
  Ä¥: "hÌ‚",
  á¸£: "hÌ‡",
  Ã­: "iÌ",
  Ã¬: "iÌ€",
  Ã¯: "iÌˆ",
  á¸¯: "iÌˆÌ",
  Ä©: "iÌƒ",
  Ä«: "iÌ„",
  Ä­: "iÌ†",
  Ç: "iÌŒ",
  Ã®: "iÌ‚",
  Ç°: "jÌŒ",
  Äµ: "jÌ‚",
  á¸±: "kÌ",
  Ç©: "kÌŒ",
  Äº: "lÌ",
  Ä¾: "lÌŒ",
  á¸¿: "mÌ",
  á¹: "mÌ‡",
  Å„: "nÌ",
  Ç¹: "nÌ€",
  Ã±: "nÌƒ",
  Åˆ: "nÌŒ",
  á¹…: "nÌ‡",
  Ã³: "oÌ",
  Ã²: "oÌ€",
  Ã¶: "oÌˆ",
  È«: "oÌˆÌ„",
  Ãµ: "oÌƒ",
  á¹: "oÌƒÌ",
  á¹: "oÌƒÌˆ",
  È­: "oÌƒÌ„",
  Å: "oÌ„",
  á¹“: "oÌ„Ì",
  á¹‘: "oÌ„Ì€",
  Å: "oÌ†",
  Ç’: "oÌŒ",
  Ã´: "oÌ‚",
  á»‘: "oÌ‚Ì",
  á»“: "oÌ‚Ì€",
  á»—: "oÌ‚Ìƒ",
  È¯: "oÌ‡",
  È±: "oÌ‡Ì„",
  Å‘: "oÌ‹",
  á¹•: "pÌ",
  á¹—: "pÌ‡",
  Å•: "rÌ",
  Å™: "rÌŒ",
  á¹™: "rÌ‡",
  Å›: "sÌ",
  á¹¥: "sÌÌ‡",
  Å¡: "sÌŒ",
  á¹§: "sÌŒÌ‡",
  Å: "sÌ‚",
  á¹¡: "sÌ‡",
  áº—: "tÌˆ",
  Å¥: "tÌŒ",
  á¹«: "tÌ‡",
  Ãº: "uÌ",
  Ã¹: "uÌ€",
  Ã¼: "uÌˆ",
  Ç˜: "uÌˆÌ",
  Çœ: "uÌˆÌ€",
  Ç–: "uÌˆÌ„",
  Çš: "uÌˆÌŒ",
  Å©: "uÌƒ",
  á¹¹: "uÌƒÌ",
  Å«: "uÌ„",
  á¹»: "uÌ„Ìˆ",
  Å­: "uÌ†",
  Ç”: "uÌŒ",
  Ã»: "uÌ‚",
  Å¯: "uÌŠ",
  Å±: "uÌ‹",
  á¹½: "vÌƒ",
  áºƒ: "wÌ",
  áº: "wÌ€",
  áº…: "wÌˆ",
  Åµ: "wÌ‚",
  áº‡: "wÌ‡",
  áº˜: "wÌŠ",
  áº: "xÌˆ",
  áº‹: "xÌ‡",
  Ã½: "yÌ",
  á»³: "yÌ€",
  Ã¿: "yÌˆ",
  á»¹: "yÌƒ",
  È³: "yÌ„",
  Å·: "yÌ‚",
  áº: "yÌ‡",
  áº™: "yÌŠ",
  Åº: "zÌ",
  Å¾: "zÌŒ",
  áº‘: "zÌ‚",
  Å¼: "zÌ‡",
  Ã: "AÌ",
  Ã€: "AÌ€",
  Ã„: "AÌˆ",
  Ç: "AÌˆÌ„",
  Ãƒ: "AÌƒ",
  Ä€: "AÌ„",
  Ä‚: "AÌ†",
  áº®: "AÌ†Ì",
  áº°: "AÌ†Ì€",
  áº´: "AÌ†Ìƒ",
  Ç: "AÌŒ",
  Ã‚: "AÌ‚",
  áº¤: "AÌ‚Ì",
  áº¦: "AÌ‚Ì€",
  áºª: "AÌ‚Ìƒ",
  È¦: "AÌ‡",
  Ç : "AÌ‡Ì„",
  Ã…: "AÌŠ",
  Çº: "AÌŠÌ",
  á¸‚: "BÌ‡",
  Ä†: "CÌ",
  ÄŒ: "CÌŒ",
  Äˆ: "CÌ‚",
  ÄŠ: "CÌ‡",
  Ä: "DÌŒ",
  á¸Š: "DÌ‡",
  Ã‰: "EÌ",
  Ãˆ: "EÌ€",
  Ã‹: "EÌˆ",
  áº¼: "EÌƒ",
  Ä’: "EÌ„",
  á¸–: "EÌ„Ì",
  á¸”: "EÌ„Ì€",
  Ä”: "EÌ†",
  Äš: "EÌŒ",
  ÃŠ: "EÌ‚",
  áº¾: "EÌ‚Ì",
  á»€: "EÌ‚Ì€",
  á»„: "EÌ‚Ìƒ",
  Ä–: "EÌ‡",
  á¸: "FÌ‡",
  Ç´: "GÌ",
  á¸ : "GÌ„",
  Ä: "GÌ†",
  Ç¦: "GÌŒ",
  Äœ: "GÌ‚",
  Ä : "GÌ‡",
  á¸¦: "HÌˆ",
  È: "HÌŒ",
  Ä¤: "HÌ‚",
  á¸¢: "HÌ‡",
  Ã: "IÌ",
  ÃŒ: "IÌ€",
  Ã: "IÌˆ",
  á¸®: "IÌˆÌ",
  Ä¨: "IÌƒ",
  Äª: "IÌ„",
  Ä¬: "IÌ†",
  Ç: "IÌŒ",
  Ã: "IÌ‚",
  Ä°: "IÌ‡",
  Ä´: "JÌ‚",
  á¸°: "KÌ",
  Ç¨: "KÌŒ",
  Ä¹: "LÌ",
  Ä½: "LÌŒ",
  á¸¾: "MÌ",
  á¹€: "MÌ‡",
  Åƒ: "NÌ",
  Ç¸: "NÌ€",
  Ã‘: "NÌƒ",
  Å‡: "NÌŒ",
  á¹„: "NÌ‡",
  Ã“: "OÌ",
  Ã’: "OÌ€",
  Ã–: "OÌˆ",
  Èª: "OÌˆÌ„",
  Ã•: "OÌƒ",
  á¹Œ: "OÌƒÌ",
  á¹: "OÌƒÌˆ",
  È¬: "OÌƒÌ„",
  ÅŒ: "OÌ„",
  á¹’: "OÌ„Ì",
  á¹: "OÌ„Ì€",
  Å: "OÌ†",
  Ç‘: "OÌŒ",
  Ã”: "OÌ‚",
  á»: "OÌ‚Ì",
  á»’: "OÌ‚Ì€",
  á»–: "OÌ‚Ìƒ",
  È®: "OÌ‡",
  È°: "OÌ‡Ì„",
  Å: "OÌ‹",
  á¹”: "PÌ",
  á¹–: "PÌ‡",
  Å”: "RÌ",
  Å˜: "RÌŒ",
  á¹˜: "RÌ‡",
  Åš: "SÌ",
  á¹¤: "SÌÌ‡",
  Å : "SÌŒ",
  á¹¦: "SÌŒÌ‡",
  Åœ: "SÌ‚",
  á¹ : "SÌ‡",
  Å¤: "TÌŒ",
  á¹ª: "TÌ‡",
  Ãš: "UÌ",
  Ã™: "UÌ€",
  Ãœ: "UÌˆ",
  Ç—: "UÌˆÌ",
  Ç›: "UÌˆÌ€",
  Ç•: "UÌˆÌ„",
  Ç™: "UÌˆÌŒ",
  Å¨: "UÌƒ",
  á¹¸: "UÌƒÌ",
  Åª: "UÌ„",
  á¹º: "UÌ„Ìˆ",
  Å¬: "UÌ†",
  Ç“: "UÌŒ",
  Ã›: "UÌ‚",
  Å®: "UÌŠ",
  Å°: "UÌ‹",
  á¹¼: "VÌƒ",
  áº‚: "WÌ",
  áº€: "WÌ€",
  áº„: "WÌˆ",
  Å´: "WÌ‚",
  áº†: "WÌ‡",
  áºŒ: "XÌˆ",
  áºŠ: "XÌ‡",
  Ã: "YÌ",
  á»²: "YÌ€",
  Å¸: "YÌˆ",
  á»¸: "YÌƒ",
  È²: "YÌ„",
  Å¶: "YÌ‚",
  áº: "YÌ‡",
  Å¹: "ZÌ",
  Å½: "ZÌŒ",
  áº: "ZÌ‚",
  Å»: "ZÌ‡",
  Î¬: "Î±Ì",
  á½°: "Î±Ì€",
  á¾±: "Î±Ì„",
  á¾°: "Î±Ì†",
  Î­: "ÎµÌ",
  á½²: "ÎµÌ€",
  Î®: "Î·Ì",
  á½´: "Î·Ì€",
  Î¯: "Î¹Ì",
  á½¶: "Î¹Ì€",
  ÏŠ: "Î¹Ìˆ",
  Î: "Î¹ÌˆÌ",
  á¿’: "Î¹ÌˆÌ€",
  á¿‘: "Î¹Ì„",
  á¿: "Î¹Ì†",
  ÏŒ: "Î¿Ì",
  á½¸: "Î¿Ì€",
  Ï: "Ï…Ì",
  á½º: "Ï…Ì€",
  Ï‹: "Ï…Ìˆ",
  Î°: "Ï…ÌˆÌ",
  á¿¢: "Ï…ÌˆÌ€",
  á¿¡: "Ï…Ì„",
  á¿ : "Ï…Ì†",
  Ï: "Ï‰Ì",
  á½¼: "Ï‰Ì€",
  Î: "Î¥Ì",
  á¿ª: "Î¥Ì€",
  Î«: "Î¥Ìˆ",
  á¿©: "Î¥Ì„",
  á¿¨: "Î¥Ì†",
  Î: "Î©Ì",
  á¿º: "Î©Ì€"
};
var Ji = ["bin", "op", "open", "punct", "rel"];
var ta = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/;
var Ce = class _Ce {
  constructor(e, n, r = false) {
    this.mode = "math", this.gullet = new Qi(e, n, this.mode), this.settings = n, this.isPreamble = r, this.leftrightDepth = 0, this.prevAtomType = "";
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(e, n = true) {
    if (this.fetch().text !== e)
      throw new q(`Expected '${e}', got '${this.fetch().text}'`, this.fetch());
    n && this.consume();
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    return this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e, this.gullet.switchMode(e);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    this.gullet.beginGroup(), this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
    const e = this.parseExpression(false);
    if (this.expect("EOF"), this.isPreamble) {
      const r = /* @__PURE__ */ Object.create(null);
      return Object.entries(this.gullet.macros.current).forEach(([s, a]) => {
        r[s] = a;
      }), this.gullet.endGroup(), r;
    }
    const n = this.gullet.macros.get("\\df@tag");
    return this.gullet.endGroup(), n && (this.gullet.macros.current["\\df@tag"] = n), e;
  }
  static get endOfExpression() {
    return ["}", "\\endgroup", "\\end", "\\right", "\\endtoggle", "&"];
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(e) {
    const n = this.nextToken;
    this.consume(), this.gullet.pushToken(new At("}")), this.gullet.pushTokens(e);
    const r = this.parseExpression(false);
    return this.expect("}"), this.nextToken = n, r;
  }
  /**
     * Parses an "expression", which is a list of atoms.
     *
     * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
     *                 happens when functions have higher precedence han infix
     *                 nodes in implicit parses.
     *
     * `breakOnTokenText`: The text of the token that the expression should end
     *                     with, or `null` if something else should end the
     *                     expression.
     *
     * `breakOnMiddle`: \color, \over, and old styling functions work on an implicit group.
     *                  These groups end just before the usual tokens, but they also
     *                  end just before `\middle`.
     */
  parseExpression(e, n, r) {
    const s = [];
    for (; ; ) {
      this.mode === "math" && this.consumeSpaces();
      const a = this.fetch();
      if (_Ce.endOfExpression.indexOf(a.text) !== -1 || n && a.text === n || r && a.text === "\\middle" || e && Lt[a.text] && Lt[a.text].infix)
        break;
      const l = this.parseAtom(n);
      if (l) {
        if (l.type === "internal")
          continue;
      } else break;
      s.push(l), this.prevAtomType = l.type === "atom" ? l.family : l.type;
    }
    return this.mode === "text" && this.formLigatures(s), this.handleInfixNodes(s);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(e) {
    let n = -1, r;
    for (let s = 0; s < e.length; s++)
      if (e[s].type === "infix") {
        if (n !== -1)
          throw new q("only one infix operator per group", e[s].token);
        n = s, r = e[s].replaceWith;
      }
    if (n !== -1 && r) {
      let s, a;
      const l = e.slice(0, n), u = e.slice(n + 1);
      l.length === 1 && l[0].type === "ordgroup" ? s = l[0] : s = { type: "ordgroup", mode: this.mode, body: l }, u.length === 1 && u[0].type === "ordgroup" ? a = u[0] : a = { type: "ordgroup", mode: this.mode, body: u };
      let c;
      return r === "\\\\abovefrac" ? c = this.callFunction(r, [s, e[n], a], []) : c = this.callFunction(r, [s, a], []), [c];
    } else
      return e;
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(e) {
    const n = this.fetch(), r = n.text;
    this.consume(), this.consumeSpaces();
    const s = this.parseGroup(e);
    if (!s)
      throw new q("Expected group after '" + r + "'", n);
    return s;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(e) {
    const n = [];
    for (let a = 0; a < e.length; a++)
      n.push({ type: "textord", mode: "text", text: e[a] });
    const r = {
      type: "text",
      mode: this.mode,
      body: n
    };
    return {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [r]
    };
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(e) {
    const n = this.parseGroup("atom", e);
    if (this.mode === "text")
      return n;
    let r, s;
    for (; ; ) {
      this.consumeSpaces();
      const a = this.fetch();
      if (a.text === "\\limits" || a.text === "\\nolimits") {
        if (n && n.type === "op") {
          const l = a.text === "\\limits";
          n.limits = l, n.alwaysHandleSupSub = true;
        } else if (n && n.type === "operatorname")
          n.alwaysHandleSupSub && (n.limits = a.text === "\\limits");
        else
          throw new q("Limit controls must follow a math operator", a);
        this.consume();
      } else if (a.text === "^") {
        if (r)
          throw new q("Double superscript", a);
        r = this.handleSupSubscript("superscript");
      } else if (a.text === "_") {
        if (s)
          throw new q("Double subscript", a);
        s = this.handleSupSubscript("subscript");
      } else if (a.text === "'") {
        if (r)
          throw new q("Double superscript", a);
        const l = { type: "textord", mode: this.mode, text: "\\prime" }, u = [l];
        for (this.consume(); this.fetch().text === "'"; )
          u.push(l), this.consume();
        this.fetch().text === "^" && u.push(this.handleSupSubscript("superscript")), r = { type: "ordgroup", mode: this.mode, body: u };
      } else if (pe[a.text]) {
        const l = lr.test(a.text), u = [];
        for (u.push(new At(pe[a.text])), this.consume(); ; ) {
          const m = this.fetch().text;
          if (!pe[m] || lr.test(m) !== l)
            break;
          u.unshift(new At(pe[m])), this.consume();
        }
        const c = this.subparse(u);
        l ? s = { type: "ordgroup", mode: "math", body: c } : r = { type: "ordgroup", mode: "math", body: c };
      } else
        break;
    }
    if (r || s) {
      if (n && n.type === "multiscript" && !n.postscripts)
        return n.postscripts = { sup: r, sub: s }, n;
      {
        const a = !n || n.type !== "op" && n.type !== "operatorname" ? void 0 : Ne(this.nextToken.text);
        return {
          type: "supsub",
          mode: this.mode,
          base: n,
          sup: r,
          sub: s,
          isFollowedByDelimiter: a
        };
      }
    } else
      return n;
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(e, n) {
    const r = this.fetch(), s = r.text, a = Lt[s];
    if (!a)
      return null;
    if (this.consume(), n && n !== "atom" && !a.allowedInArgument)
      throw new q(
        "Got function '" + s + "' with no arguments" + (n ? " as " + n : ""),
        r
      );
    if (this.mode === "text" && !a.allowedInText)
      throw new q("Can't use function '" + s + "' in text mode", r);
    if (this.mode === "math" && a.allowedInMath === false)
      throw new q("Can't use function '" + s + "' in math mode", r);
    const l = this.prevAtomType, { args: u, optArgs: c } = this.parseArguments(s, a);
    return this.prevAtomType = l, this.callFunction(s, u, c, r, e);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(e, n, r, s, a) {
    const l = {
      funcName: e,
      parser: this,
      token: s,
      breakOnTokenText: a
    }, u = Lt[e];
    if (u && u.handler)
      return u.handler(l, n, r);
    throw new q(`No function handler for ${e}`);
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(e, n) {
    const r = n.numArgs + n.numOptionalArgs;
    if (r === 0)
      return { args: [], optArgs: [] };
    const s = [], a = [];
    for (let l = 0; l < r; l++) {
      let u = n.argTypes && n.argTypes[l];
      const c = l < n.numOptionalArgs;
      (n.primitive && u == null || // \sqrt expands into primitive if optional argument doesn't exist
      n.type === "sqrt" && l === 1 && a[0] == null) && (u = "primitive");
      const m = this.parseGroupOfType(`argument to '${e}'`, u, c);
      if (c)
        a.push(m);
      else if (m != null)
        s.push(m);
      else
        throw new q("Null argument, please report this as a bug");
    }
    return { args: s, optArgs: a };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(e, n, r) {
    switch (n) {
      case "size":
        return this.parseSizeGroup(r);
      case "url":
        return this.parseUrlGroup(r);
      case "math":
      case "text":
        return this.parseArgumentGroup(r, n);
      case "hbox": {
        const s = this.parseArgumentGroup(r, "text");
        return s != null ? {
          type: "styling",
          mode: s.mode,
          body: [s],
          scriptLevel: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        const s = this.parseStringGroup("raw", r);
        return s != null ? {
          type: "raw",
          mode: "text",
          string: s.text
        } : null;
      }
      case "primitive": {
        if (r)
          throw new q("A primitive argument cannot be optional");
        const s = this.parseGroup(e);
        if (s == null)
          throw new q("Expected group as " + e, this.fetch());
        return s;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(r);
      default:
        throw new q("Unknown group type as " + e, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    for (; ; ) {
      const e = this.fetch().text;
      if (e === " " || e === "Â " || e === "ï¸")
        this.consume();
      else
        break;
    }
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(e, n) {
    const r = this.gullet.scanArgument(n);
    if (r == null)
      return null;
    let s = "", a;
    for (; (a = this.fetch()).text !== "EOF"; )
      s += a.text, this.consume();
    return this.consume(), r.text = s, r;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(e, n) {
    const r = this.fetch();
    let s = r, a = "", l;
    for (; (l = this.fetch()).text !== "EOF" && e.test(a + l.text); )
      s = l, a += s.text, this.consume();
    if (a === "")
      throw new q("Invalid " + n + ": '" + r.text + "'", r);
    return r.range(s, a);
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(e) {
    let n, r = false;
    if (this.gullet.consumeSpaces(), !e && this.gullet.future().text !== "{" ? n = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : n = this.parseStringGroup("size", e), !n)
      return null;
    !e && n.text.length === 0 && (n.text = "0pt", r = true);
    const s = ta.exec(n.text);
    if (!s)
      throw new q("Invalid size: '" + n.text + "'", n);
    const a = {
      number: +(s[1] + s[2]),
      // sign + magnitude, cast to number
      unit: s[3]
    };
    if (!Er(a))
      throw new q("Invalid unit: '" + a.unit + "'", n);
    return {
      type: "size",
      mode: this.mode,
      value: a,
      isBlank: r
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(e) {
    this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
    const n = this.parseStringGroup("url", e);
    if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), n == null)
      return null;
    let r = n.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return r = n.text.replace(/{\u2044}/g, "/"), {
      type: "url",
      mode: this.mode,
      url: r
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(e, n) {
    const r = this.gullet.scanArgument(e);
    if (r == null)
      return null;
    const s = this.mode;
    n && this.switchMode(n), this.gullet.beginGroup();
    const a = this.parseExpression(false, "EOF");
    this.expect("EOF"), this.gullet.endGroup();
    const l = {
      type: "ordgroup",
      mode: this.mode,
      loc: r.loc,
      body: a
    };
    return n && this.switchMode(s), l;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(e, n) {
    const r = this.fetch(), s = r.text;
    let a;
    if (s === "{" || s === "\\begingroup" || s === "\\toggle") {
      this.consume();
      const l = s === "{" ? "}" : s === "\\begingroup" ? "\\endgroup" : "\\endtoggle";
      this.gullet.beginGroup();
      const u = this.parseExpression(false, l), c = this.fetch();
      this.expect(l), this.gullet.endGroup(), a = {
        type: c.text === "\\endtoggle" ? "toggle" : "ordgroup",
        mode: this.mode,
        loc: mt.range(r, c),
        body: u,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/
        semisimple: s === "\\begingroup" || void 0
      };
    } else
      a = this.parseFunction(n, e) || this.parseSymbol(), a == null && s[0] === "\\" && !Object.prototype.hasOwnProperty.call(Jr, s) && (a = this.formatUnsupportedCmd(s), this.consume());
    return a;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(e) {
    let n = e.length - 1;
    for (let r = 0; r < n; ++r) {
      const s = e[r], a = s.text;
      a === "-" && e[r + 1].text === "-" && (r + 1 < n && e[r + 2].text === "-" ? (e.splice(r, 3, {
        type: "textord",
        mode: "text",
        loc: mt.range(s, e[r + 2]),
        text: "---"
      }), n -= 2) : (e.splice(r, 2, {
        type: "textord",
        mode: "text",
        loc: mt.range(s, e[r + 1]),
        text: "--"
      }), n -= 1)), (a === "'" || a === "`") && e[r + 1].text === a && (e.splice(r, 2, {
        type: "textord",
        mode: "text",
        loc: mt.range(s, e[r + 1]),
        text: a + a
      }), n -= 1);
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    const e = this.fetch();
    let n = e.text;
    if (/^\\verb[^a-zA-Z]/.test(n)) {
      this.consume();
      let a = n.slice(5);
      const l = a.charAt(0) === "*";
      if (l && (a = a.slice(1)), a.length < 2 || a.charAt(0) !== a.slice(-1))
        throw new q(`\\verb assertion failed --
                    please report what input caused this bug`);
      return a = a.slice(1, -1), {
        type: "verb",
        mode: "text",
        body: a,
        star: l
      };
    }
    if (Object.prototype.hasOwnProperty.call(cr, n[0]) && this.mode === "math" && !lt[this.mode][n[0]]) {
      if (this.settings.strict && this.mode === "math")
        throw new q(
          `Accented Unicode text character "${n[0]}" used in math mode`,
          e
        );
      n = cr[n[0]] + n.slice(1);
    }
    const r = this.mode === "math" ? ar.exec(n) : null;
    r && (n = n.substring(0, r.index), n === "i" ? n = "Ä±" : n === "j" && (n = "È·"));
    let s;
    if (lt[this.mode][n]) {
      let a = lt[this.mode][n].group;
      a === "bin" && Ji.includes(this.prevAtomType) && (a = "open");
      const l = mt.range(e);
      let u;
      if (Object.prototype.hasOwnProperty.call(Ds, a)) {
        const c = a;
        u = {
          type: "atom",
          mode: this.mode,
          family: c,
          loc: l,
          text: n
        };
      } else {
        if (ur[n]) {
          this.consume();
          const c = this.fetch().text.charCodeAt(0), m = c === 65025 ? "mathscr" : "mathcal";
          return (c === 65024 || c === 65025) && this.consume(), {
            type: "font",
            mode: "math",
            font: m,
            body: { type: "mathord", mode: "math", loc: l, text: ur[n] }
          };
        }
        u = {
          type: a,
          mode: this.mode,
          loc: l,
          text: n
        };
      }
      s = u;
    } else if (n.charCodeAt(0) >= 128 || ar.exec(n)) {
      if (this.settings.strict && this.mode === "math")
        throw new q(`Unicode text character "${n[0]}" used in math mode`, e);
      s = {
        type: "textord",
        mode: "text",
        loc: mt.range(e),
        text: n
      };
    } else
      return null;
    if (this.consume(), r)
      for (let a = 0; a < r[0].length; a++) {
        const l = r[0][a];
        if (!Fe[l])
          throw new q(`Unknown accent ' ${l}'`, e);
        const u = Fe[l][this.mode] || Fe[l].text;
        if (!u)
          throw new q(`Accent ${l} unsupported in ${this.mode} mode`, e);
        s = {
          type: "accent",
          mode: this.mode,
          loc: mt.range(e),
          label: u,
          isStretchy: false,
          base: s
        };
      }
    return s;
  }
};
var ts = function(t, e) {
  if (!(typeof t == "string" || t instanceof String))
    throw new TypeError("Temml can only parse string typed expression");
  const n = new Ce(t, e);
  delete n.gullet.macros.current["\\df@tag"];
  let r = n.parse();
  if (!(r.length > 0 && r[0].type && r[0].type === "array" && r[0].addEqnNum) && n.gullet.macros.get("\\df@tag")) {
    if (!e.displayMode)
      throw new q("\\tag works only in display mode");
    n.gullet.feed("\\df@tag"), r = [
      {
        type: "tag",
        mode: "text",
        body: r,
        tag: n.parse()
      }
    ];
  }
  return r;
};
var ea = [2, 2, 3, 3];
var yn = class _yn {
  constructor(e) {
    this.level = e.level, this.color = e.color, this.font = e.font || "", this.fontFamily = e.fontFamily || "", this.fontSize = e.fontSize || 1, this.fontWeight = e.fontWeight || "", this.fontShape = e.fontShape || "", this.maxSize = e.maxSize;
  }
  /**
   * Returns a new style object with the same properties as "this".  Properties
   * from "extension" will be copied to the new style object.
   */
  extend(e) {
    const n = {
      level: this.level,
      color: this.color,
      font: this.font,
      fontFamily: this.fontFamily,
      fontSize: this.fontSize,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize
    };
    for (const r in e)
      Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    return new _yn(n);
  }
  withLevel(e) {
    return this.extend({
      level: e
    });
  }
  incrementLevel() {
    return this.extend({
      level: Math.min(this.level + 1, 3)
    });
  }
  inSubOrSup() {
    return this.extend({
      level: ea[this.level]
    });
  }
  /**
   * Create a new style object with the given color.
   */
  withColor(e) {
    return this.extend({
      color: e
    });
  }
  /**
   * Creates a new style object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(e) {
    return this.extend({
      font: e
    });
  }
  /**
   * Create a new style objects with the given fontFamily.
   */
  withTextFontFamily(e) {
    return this.extend({
      fontFamily: e,
      font: ""
    });
  }
  /**
   * Creates a new style object with the given font size
   */
  withFontSize(e) {
    return this.extend({
      fontSize: e
    });
  }
  /**
   * Creates a new style object with the given font weight
   */
  withTextFontWeight(e) {
    return this.extend({
      fontWeight: e,
      font: ""
    });
  }
  /**
   * Creates a new style object with the given font weight
   */
  withTextFontShape(e) {
    return this.extend({
      fontShape: e,
      font: ""
    });
  }
  /**
   * Gets the CSS color of the current style object
   */
  getColor() {
    return this.color;
  }
};
var na = "0.10.29";
function ra(t) {
  const e = {};
  let n = 0;
  const r = t.getElementsByClassName("tml-tageqn");
  for (const a of r) {
    const l = a.getElementsByClassName("tml-eqn");
    l.length > 0 && (n += 1, l[0].id = "tml-eqn-" + n);
    const u = a.getElementsByClassName("tml-label");
    if (u.length !== 0)
      if (l.length > 0)
        e[u[0].id] = String(n);
      else {
        const c = a.getElementsByClassName("tml-tag");
        c.length > 0 && (e[u[0].id] = c[0].textContent);
      }
  }
  [...t.getElementsByClassName("tml-ref")].forEach((a) => {
    let l = e[a.getAttribute("href").slice(1)];
    a.className.indexOf("tml-eqref") === -1 && (l = l.replace(/^\(/, ""), l = l.replace(/\($/, "")), l.charAt(0) !== "(" && (l = "(" + l), l.slice(-1) !== ")" && (l = l + ")"), a.textContent = l;
  });
}
var es = function(t, e, n = {}) {
  e.textContent = "";
  const r = e.tagName.toLowerCase() === "math";
  r && (n.wrap = "none");
  const s = wn(t, n);
  r ? (e.textContent = "", s.children.forEach((a) => {
    e.appendChild(a.toNode());
  })) : s.children.length > 1 ? (e.textContent = "", s.children.forEach((a) => {
    e.appendChild(a.toNode());
  })) : e.appendChild(s.toNode());
};
typeof document < "u" && document.compatMode !== "CSS1Compat" && (typeof console < "u" && console.warn(
  "Warning: Temml doesn't work in quirks mode. Make sure your website has a suitable doctype."
), es = function() {
  throw new q("Temml doesn't work in quirks mode.");
});
var sa = function(t, e) {
  return wn(t, e).toMarkup();
};
var ia = function(t, e) {
  const n = new ln(e);
  return ts(t, n);
};
var aa = function(t, e) {
  const n = new ln(e);
  if (n.macros = {}, !(typeof t == "string" || t instanceof String))
    throw new TypeError("Temml can only parse string typed expression");
  const r = new Ce(t, n, true);
  return delete r.gullet.macros.current["\\df@tag"], r.parse();
};
var oa = function(t, e, n) {
  if (n.throwOnError || !(t instanceof q))
    throw t;
  const r = new Cr(["temml-error"], [new qs(e + `
` + t.toString())]);
  return r.style.color = n.errorColor, r.style.whiteSpace = "pre-line", r;
};
var wn = function(t, e) {
  const n = new ln(e);
  try {
    const r = ts(t, n), s = new yn({
      level: n.displayMode ? ot.DISPLAY : ot.TEXT,
      maxSize: n.maxSize
    });
    return Us(r, t, s, n);
  } catch (r) {
    return oa(r, t, n);
  }
};
var ve = {
  /**
   * Current Temml version
   */
  version: na,
  /**
   * Renders the given LaTeX into MathML, and adds
   * it as a child to the specified DOM node.
   */
  render: es,
  /**
   * Renders the given LaTeX into MathML string,
   * for sending to the client.
   */
  renderToString: sa,
  /**
   * Post-process an entire HTML block.
   * Writes AMS auto-numbers and implements \ref{}.
   * Typcally called once, after a loop has rendered many individual spans.
   */
  postProcess: ra,
  /**
   * Temml error, usually during parsing.
   */
  ParseError: q,
  /**
   * Creates a set of macros with document-wide scope.
   */
  definePreamble: aa,
  /**
   * Parses the given LaTeX into Temml's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: ia,
  /**
   * Renders the given LaTeX into a MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToMathMLTree: wn,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: i,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: h
};
function la(t) {
  return {
    inline_math: (e) => ve.renderToString(e.text, { ...t }),
    display_math: (e) => ve.renderToString(e.text, { displayMode: true, ...t })
  };
}
var rn = {};
var Te = {};
var re = {};
var It = {};
Object.defineProperty(It, "__esModule", { value: true });
It.Warning = void 0;
var ua = class {
  constructor(e, n) {
    this.message = e, typeof n == "number" ? this.offset = n : n && "line" in n && (this.sourceLoc = n, this.offset = n.offset);
  }
  render() {
    let e = this.message;
    return this.sourceLoc ? e += ` at line ${this.sourceLoc.line}, col ${this.sourceLoc.col}` : this.offset && (e += ` at offset ${this.offset}`), e;
  }
};
It.Warning = ua;
var se = {};
Object.defineProperty(se, "__esModule", { value: true });
se.AttributeParser = void 0;
var P;
(function(t) {
  t[t.SCANNING = 0] = "SCANNING", t[t.SCANNING_ID = 1] = "SCANNING_ID", t[t.SCANNING_CLASS = 2] = "SCANNING_CLASS", t[t.SCANNING_KEY = 3] = "SCANNING_KEY", t[t.SCANNING_VALUE = 4] = "SCANNING_VALUE", t[t.SCANNING_BARE_VALUE = 5] = "SCANNING_BARE_VALUE", t[t.SCANNING_QUOTED_VALUE = 6] = "SCANNING_QUOTED_VALUE", t[t.SCANNING_QUOTED_VALUE_CONTINUATION = 7] = "SCANNING_QUOTED_VALUE_CONTINUATION", t[t.SCANNING_ESCAPED = 8] = "SCANNING_ESCAPED", t[t.SCANNING_ESCAPED_IN_CONTINUATION = 9] = "SCANNING_ESCAPED_IN_CONTINUATION", t[t.SCANNING_COMMENT = 10] = "SCANNING_COMMENT", t[t.FAIL = 11] = "FAIL", t[t.DONE = 12] = "DONE", t[t.START = 13] = "START";
})(P || (P = {}));
var ca = /^[a-zA-Z0-9_:-]/;
var ha = function(t) {
  return ca.exec(t) !== null;
};
var pt = [];
pt[P.START] = function(t, e) {
  return t.subject.charAt(e) === "{" ? P.SCANNING : P.FAIL;
};
pt[P.FAIL] = function(t, e) {
  return P.FAIL;
};
pt[P.DONE] = function(t, e) {
  return P.DONE;
};
pt[P.SCANNING] = function(t, e) {
  const n = t.subject.charAt(e);
  return n === `
` || n === "\r" ? P.SCANNING : n === " " || n === "	" ? (t.addEvent(e, e, "attr_space"), P.SCANNING) : n === "}" ? P.DONE : n === "#" ? (t.begin = e, t.addEvent(e, e, "attr_id_marker"), P.SCANNING_ID) : n === "%" ? (t.begin = e, P.SCANNING_COMMENT) : n === "." ? (t.begin = e, t.addEvent(e, e, "attr_class_marker"), P.SCANNING_CLASS) : ha(n) ? (t.begin = e, P.SCANNING_KEY) : P.FAIL;
};
pt[P.SCANNING_COMMENT] = function(t, e) {
  const n = t.subject.charAt(e);
  return n === "%" ? (t.begin && e > t.begin && t.addEvent(t.begin, e, "comment"), P.SCANNING) : n == "}" ? P.DONE : P.SCANNING_COMMENT;
};
pt[P.SCANNING_ID] = function(t, e) {
  const n = t.subject.charAt(e);
  return /^[^\]\[~!@#$%^&*(){}`,.<>\\|=+/?\s]/.exec(n) !== null ? P.SCANNING_ID : n === "}" ? (t.begin && t.lastpos && t.lastpos > t.begin && t.addEvent(t.begin + 1, t.lastpos, "id"), t.begin = null, P.DONE) : /^\s/.exec(n) !== null ? (t.begin && t.lastpos && t.lastpos > t.begin && t.addEvent(t.begin + 1, t.lastpos, "id"), n === "\r" || n === `
` || t.addEvent(e, e, "attr_space"), t.begin = null, P.SCANNING) : P.FAIL;
};
pt[P.SCANNING_CLASS] = function(t, e) {
  const n = t.subject.charAt(e);
  return /^\w/.exec(n) !== null || n === "_" || n === "-" || n === ":" ? P.SCANNING_CLASS : n === "}" ? (t.begin && t.lastpos && t.lastpos > t.begin && t.addEvent(t.begin + 1, t.lastpos, "class"), t.begin = null, P.DONE) : /^\s/.exec(n) !== null ? (t.begin && t.lastpos && t.lastpos > t.begin && t.addEvent(t.begin + 1, t.lastpos, "class"), n === "\r" || n === `
` || t.addEvent(e, e, "attr_space"), t.begin = null, P.SCANNING) : P.FAIL;
};
pt[P.SCANNING_KEY] = function(t, e) {
  const n = t.subject.charAt(e);
  return n === "=" && t.begin && t.lastpos ? (t.addEvent(t.begin, t.lastpos, "key"), t.addEvent(e, e, "attr_equal_marker"), t.begin = null, P.SCANNING_VALUE) : /^[a-zA-Z0-9_:-]/.exec(n) !== null ? P.SCANNING_KEY : P.FAIL;
};
pt[P.SCANNING_VALUE] = function(t, e) {
  const n = t.subject.charAt(e);
  return n === '"' ? (t.begin = e, t.addEvent(e, e, "attr_quote_marker"), P.SCANNING_QUOTED_VALUE) : /^[a-zA-Z0-9_:-]/.exec(n) !== null ? (t.begin = e, P.SCANNING_BARE_VALUE) : P.FAIL;
};
pt[P.SCANNING_BARE_VALUE] = function(t, e) {
  const n = t.subject.charAt(e);
  return /^[a-zA-Z0-9_:-]/.exec(n) !== null ? P.SCANNING_BARE_VALUE : n === "}" && t.begin && t.lastpos ? (t.addEvent(t.begin, t.lastpos, "value"), t.begin = null, P.DONE) : /^\s/.exec(n) && t.begin && t.lastpos ? (t.addEvent(t.begin, t.lastpos, "value"), n === "\r" || n === `
` || t.addEvent(e, e, "attr_space"), t.begin = null, P.SCANNING) : P.FAIL;
};
pt[P.SCANNING_ESCAPED] = function(t, e) {
  return P.SCANNING_QUOTED_VALUE;
};
pt[P.SCANNING_ESCAPED_IN_CONTINUATION] = function(t, e) {
  return P.SCANNING_QUOTED_VALUE_CONTINUATION;
};
pt[P.SCANNING_QUOTED_VALUE] = function(t, e) {
  const n = t.subject.charAt(e);
  return n === '"' && t.begin && t.lastpos ? (t.addEvent(t.begin + 1, t.lastpos, "value"), t.addEvent(e, e, "attr_quote_marker"), t.begin = null, P.SCANNING) : n === `
` && t.begin && t.lastpos ? (t.addEvent(t.begin + 1, e, "value"), t.begin = null, P.SCANNING_QUOTED_VALUE_CONTINUATION) : n === "\\" ? P.SCANNING_ESCAPED : P.SCANNING_QUOTED_VALUE;
};
pt[P.SCANNING_QUOTED_VALUE_CONTINUATION] = function(t, e) {
  const n = t.subject.charAt(e);
  return t.begin === null && (t.begin = e), n === '"' && t.begin && t.lastpos ? (t.addEvent(e, e, "attr_quote_marker"), t.addEvent(t.begin, t.lastpos, "value"), t.begin = null, P.SCANNING) : n === `
` && t.begin && t.lastpos ? (t.addEvent(t.begin, e, "value"), t.begin = null, P.SCANNING_QUOTED_VALUE_CONTINUATION) : n === "\\" ? P.SCANNING_ESCAPED_IN_CONTINUATION : P.SCANNING_QUOTED_VALUE_CONTINUATION;
};
var da = class {
  constructor(e) {
    this.subject = e, this.state = P.START, this.begin = null, this.lastpos = null, this.matches = [];
  }
  addEvent(e, n, r) {
    this.matches.push({ startpos: e, endpos: n, annot: r });
  }
  /* Feed parser a slice of text from the subject, between
   * startpos and endpos inclusive.  Return object with
   * status and position,
   * where status is either "done" (position should point to
   * final '}'), "fail" (position should point to first character
   * that could not be parsed), or "continue" (position should
   * point to last character parsed). */
  feed(e, n) {
    let r = e;
    for (; r <= n; ) {
      if (this.state = pt[this.state](this, r), this.state === P.DONE)
        return { status: "done", position: r };
      if (this.state === P.FAIL)
        return this.lastpos = r, { status: "fail", position: r };
      this.lastpos = r, r = r + 1;
    }
    return { status: "continue", position: n };
  }
};
se.AttributeParser = da;
var Ft = {};
Object.defineProperty(Ft, "__esModule", { value: true });
Ft.find = Ft.pattern = void 0;
var pa = function(t) {
  return new RegExp(t, "yd");
};
Ft.pattern = pa;
var ma = function(t, e, n, r) {
  e.lastIndex = n;
  let s;
  r !== void 0 ? s = t.substring(0, r + 1) : s = t;
  const a = e.exec(s);
  if (a !== null) {
    const l = [];
    if (a.indices.length > 1)
      for (let u = 1; u < a.indices.length; u++) {
        const [c, m] = a.indices[u];
        l.push(s.substring(c, m));
      }
    return {
      startpos: a.indices[0][0],
      endpos: a.indices[0][1] - 1,
      captures: l
    };
  } else
    return null;
};
Ft.find = ma;
var qe = {};
Object.defineProperty(qe, "__esModule", { value: true });
qe.InlineParser = void 0;
var fa = se;
var ga = It;
var J = Ft;
var hr = 9;
var sn = 10;
var an = 13;
var ze = 32;
var dr = 33;
var pr = 34;
var mr = 39;
var je = 40;
var ba = 41;
var xa = 42;
var ya = 43;
var Ge = 45;
var wa = 46;
var va = 58;
var ka = 60;
var _a = 61;
var Re = 91;
var Ue = 92;
var Aa = 93;
var Sa = 94;
var Na = 95;
var Ca = 96;
var fe = 123;
var ke = 125;
var Ta = 126;
var fr = /[\r\n"'()*+.:<=[\\\]^_`${}~-]/g;
var gr = function(t, e, n) {
  fr.lastIndex = e;
  const r = fr.exec(t);
  return r && r.index <= n ? r.index : null;
};
var br = (0, J.pattern)(`[^ 	\r
]`);
var qa = (0, J.pattern)("[ \\t]*\\r?\\n");
var Ma = (0, J.pattern)("['!\"#$%&\\\\'()\\*+,\\-\\.\\/:;<=>?@\\[\\]\\^_`{|}~']");
var Oa = (0, J.pattern)("\\<([^<>\\s]+)\\>");
var Ea = (0, J.pattern)(`[_*~^+='"-]`);
var $a = (0, J.pattern)(":[\\w_+-]+:");
var Ia = (0, J.pattern)("\\.\\.");
var Da = (0, J.pattern)("`*");
var Pa = (0, J.pattern)("`+");
var Ba = (0, J.pattern)("\\$\\$");
var La = (0, J.pattern)("\\$");
var Fa = (0, J.pattern)("\\\\");
var za = (0, J.pattern)("\\{=[^\\s{}`]+\\}");
var ja = (0, J.pattern)("\\^([^\\]]+)\\]");
var We = function(t, e) {
  return e > 0 && t.subject.codePointAt(e - 1) === fe || t.subject.codePointAt(e + 1) === ke;
};
var Vt = function() {
  return true;
};
var Ct = function(t, e, n, r) {
  return function(s, a, l) {
    const u = s.subject;
    let c = (0, J.find)(u, br, a + 1) !== null && r(s, a), m = (0, J.find)(u, br, a - 1) !== null;
    const b = s.matches[s.matches.length - 1], A = b && b.annot === "open_marker", x = a + 1 <= l && u.codePointAt(a + 1) === ke;
    let T = a, D = a;
    A && (c = true, m = false, D = a - 1), !A && x && (m = true, c = false, T = a + 1), A && n.match(/^right/) ? n = n.replace(/^right/, "left") : x && n.match(/^left/) && (n = n.replace(/^left/, "right"));
    let j = t;
    x && (j = "{" + j);
    const nt = s.openers[j];
    if (m && nt && nt.length > 0) {
      const N = nt[nt.length - 1];
      if (N.endpos !== a - 1)
        return s.clearOpeners(N.startpos, a), s.addMatch(N.startpos, N.endpos, "+" + e, N.matchIndex), s.addMatch(a, T, "-" + e), T + 1;
    }
    if (c) {
      let N = t;
      return A && (N = "{" + N), s.addOpener(N, D, a, n), a + 1;
    } else
      return s.addMatch(a, T, n), T + 1;
  };
};
var Ga = {
  [Ca]: function(t, e, n) {
    const r = t.subject, s = (0, J.find)(r, Da, e, n);
    if (s === null)
      return null;
    const a = s.endpos;
    return (0, J.find)(r, Ba, e - 2) && !(0, J.find)(r, Fa, e - 3) ? (t.matches.pop(), t.matches.pop(), t.addMatch(e - 2, a, "+display_math"), t.verbatimType = "display_math") : (0, J.find)(r, La, e - 1) ? (t.matches.pop(), t.addMatch(e - 1, a, "+inline_math"), t.verbatimType = "inline_math") : (t.addMatch(e, a, "+verbatim"), t.verbatimType = "verbatim"), t.verbatim = a - e + 1, a + 1;
  },
  [Ue]: function(t, e, n) {
    const r = t.subject, s = (0, J.find)(r, qa, e + 1, n);
    if (s !== null) {
      if (t.matches.length > 0) {
        const a = t.matches[t.matches.length - 1];
        if (a.annot === "str") {
          let l = a.endpos;
          const u = a.startpos;
          for (; l >= u && (r.codePointAt(l) === ze || r.codePointAt(l) === hr); )
            l = l - 1;
          l < u ? t.matches.pop() : a.endpos = l;
        }
      }
      return t.addMatch(e, e, "escape"), t.addMatch(e + 1, s.endpos, "hard_break"), s.endpos + 1;
    } else {
      const a = (0, J.find)(r, Ma, e + 1, n);
      return a !== null ? (t.addMatch(e, e, "escape"), t.addMatch(a.startpos, a.endpos, "str"), a.endpos + 1) : e + 1 <= n && r.codePointAt(e + 1) === ze ? (t.addMatch(e, e, "escape"), t.addMatch(e + 1, e + 1, "non_breaking_space"), e + 2) : (t.addMatch(e, e, "str"), e + 1);
    }
  },
  [ka]: function(t, e, n) {
    const r = t.subject, s = (0, J.find)(r, Oa, e, n);
    if (s === null)
      return null;
    const a = s.endpos, l = s.startpos, u = s.captures[0];
    return u.match(/[^:]@/) ? (t.addMatch(l, l, "+email"), t.addMatch(l + 1, a - 1, "str"), t.addMatch(a, a, "-email"), a + 1) : u.match(/[a-zA-Z]:/) ? (t.addMatch(l, l, "+url"), t.addMatch(l + 1, a - 1, "str"), t.addMatch(a, a, "-url"), a + 1) : null;
  },
  [Ta]: Ct("~", "subscript", "str", Vt),
  [Sa]: Ct("^", "superscript", "str", Vt),
  [Na]: Ct("_", "emph", "str", Vt),
  [xa]: Ct("*", "strong", "str", Vt),
  [ya]: Ct("+", "insert", "str", We),
  [_a]: Ct("=", "mark", "str", We),
  [mr]: Ct("'", "single_quoted", "right_single_quote", function(t, e) {
    if (e === 0)
      return true;
    {
      const n = t.subject.codePointAt(e - 1);
      return n === ze || n === hr || n === an || n === sn || n === pr || n === mr || n === Ge || n === je || n === Re;
    }
  }),
  [pr]: Ct('"', "double_quoted", "left_double_quote", Vt),
  [fe]: function(t, e, n) {
    return (0, J.find)(t.subject, Ea, e + 1, n) ? (t.addMatch(e, e, "open_marker"), e + 1) : t.allowAttributes ? (t.attributeParser = new fa.AttributeParser(t.subject), t.attributeStart = e, t.attributeSlices = [], e) : (t.addMatch(e, e, "str"), e + 1);
  },
  [va]: function(t, e, n) {
    const r = (0, J.find)(t.subject, $a, e, n);
    return r ? (t.addMatch(r.startpos, r.endpos, "symb"), r.endpos + 1) : (t.addMatch(e, e, "str"), e + 1);
  },
  [wa]: function(t, e, n) {
    return (0, J.find)(t.subject, Ia, e + 1, n) ? (t.addMatch(e, e + 2, "ellipses"), e + 3) : null;
  },
  [Re]: function(t, e, n) {
    const r = (0, J.find)(t.subject, ja, e + 1, n);
    return r ? (t.addMatch(e, r.endpos, "footnote_reference"), r.endpos + 1) : (t.addOpener("[", e, e, "str"), e + 1);
  },
  [Aa]: function(t, e, n) {
    const r = t.openers["["], s = t.subject;
    if (r && r.length > 0) {
      const a = r[r.length - 1];
      if (a.annot === "reference_link")
        return t.strMatches((a.subendpos || a.endpos) + 1, e - 1), s.codePointAt(a.startpos - 1) === dr && s.codePointAt(a.startpos - 2) !== Ue ? (t.addMatch(a.startpos - 1, a.startpos - 1, "image_marker", a.matchIndex - 1), t.addMatch(a.startpos, a.endpos, "+imagetext", a.matchIndex), t.addMatch(a.substartpos || a.startpos, a.substartpos || a.startpos, "-imagetext", a.subMatchIndex)) : (t.addMatch(a.startpos, a.endpos, "+linktext", a.matchIndex), t.addMatch(a.substartpos || a.startpos, a.substartpos || a.startpos, "-linktext", a.subMatchIndex)), t.addMatch(a.subendpos || a.endpos, a.subendpos || a.endpos, "+reference", a.subMatchIndex + 1), t.addMatch(e, e, "-reference"), t.clearOpeners(a.startpos, e), e + 1;
      if (e + 1 <= n && s.codePointAt(e + 1) === Re)
        return a.annot = "reference_link", t.addMatch(e, e, "str"), a.subMatchIndex = t.matches.length - 1, t.addMatch(e + 1, e + 1, "str"), a.substartpos = e, a.subendpos = e + 1, t.clearOpeners(a.startpos + 1, e - 1), e + 2;
      if (e + 1 <= n && s.codePointAt(e + 1) === je)
        return t.openers["("] = [], a.annot = "explicit_link", t.addMatch(e, e, "str"), a.subMatchIndex = t.matches.length - 1, t.addMatch(e + 1, e + 1, "str"), a.substartpos = e, a.subendpos = e + 1, t.destination = true, t.clearOpeners(a.startpos + 1, e - 1), e + 2;
      if (e + 1 <= n && s.codePointAt(e + 1) === fe)
        return t.addMatch(a.startpos, a.endpos, "+span", a.matchIndex), t.addMatch(e, e, "-span"), t.clearOpeners(a.startpos, e), e + 1;
    }
    return null;
  },
  [je]: function(t, e, n) {
    return t.destination ? (t.addOpener("(", e, e, "str"), e + 1) : null;
  },
  [ba]: function(t, e, n) {
    if (!t.destination)
      return null;
    const r = t.openers["("];
    if (r && r.length > 0)
      return r.pop(), t.addMatch(e, e, "str"), e + 1;
    {
      const s = t.subject, a = t.openers["["], l = a[a.length - 1];
      if (a && a.length > 0 && l.annot === "explicit_link")
        return t.strMatches((l.subendpos || l.endpos) + 1, e - 1), s.codePointAt(l.startpos - 1) === dr && s.codePointAt(l.startpos - 2) !== Ue ? (t.addMatch(l.startpos - 1, l.startpos - 1, "image_marker", l.matchIndex - 1), t.addMatch(l.startpos, l.endpos, "+imagetext", l.matchIndex), t.addMatch(l.substartpos || l.startpos, l.substartpos || l.startpos, "-imagetext", l.subMatchIndex)) : (t.addMatch(l.startpos, l.endpos, "+linktext", l.matchIndex), t.addMatch(l.substartpos || l.startpos, l.substartpos || l.startpos, "-linktext", l.subMatchIndex)), t.addMatch(l.subendpos || l.endpos, l.subendpos || l.endpos, "+destination", l.subMatchIndex + 1), t.addMatch(e, e, "-destination"), t.destination = false, t.clearOpeners(l.startpos, e), e + 1;
    }
    return null;
  },
  [Ge]: function(t, e, n) {
    const r = t.subject;
    if (r.codePointAt(e - 1) === fe || r.codePointAt(e + 1) === ke) {
      const c = Ct("-", "delete", "str", We)(t, e, n);
      if (c)
        return c;
    }
    let s = e, a = 0;
    for (; s <= n && r.codePointAt(s) === Ge; )
      s++, a++;
    if (r.codePointAt(s) === ke && a--, a === 0)
      return t.addMatch(e, e + 1, "str"), e + 2;
    const l = a % 3 === 0, u = a % 2 === 0;
    for (; a > 0; )
      l ? (t.addMatch(e, e + 2, "em_dash"), e = e + 3, a = a - 3) : u ? (t.addMatch(e, e + 1, "en_dash"), e = e + 2, a = a - 2) : a >= 3 && (a % 2 !== 0 || a > 4) ? (t.addMatch(e, e + 2, "em_dash"), e = e + 3, a = a - 3) : a >= 2 ? (t.addMatch(e, e + 1, "en_dash"), e = e + 2, a = a - 2) : (t.addMatch(e, e, "str"), e = e + 1, a = a - 1);
    return e;
  }
};
var Ra = class {
  constructor(e, n = {}) {
    this.options = n, this.warn = n.warn || (() => {
    }), this.subject = e, this.matches = [], this.openers = {}, this.verbatim = 0, this.verbatimType = "", this.destination = false, this.firstpos = -1, this.lastpos = 0, this.allowAttributes = true, this.attributeParser = null, this.attributeStart = null, this.attributeSlices = null, this.matchers = Ga;
  }
  addMatch(e, n, r, s) {
    const a = { startpos: e, endpos: n, annot: r };
    s !== void 0 ? this.matches.splice(s, 1, a) : this.matches.push(a);
  }
  inVerbatim() {
    return this.verbatim > 0;
  }
  singleChar(e) {
    return this.addMatch(e, e, "str"), e + 1;
  }
  reparseAttributes() {
    const e = this.attributeSlices;
    if (e !== null) {
      if (this.allowAttributes = false, this.attributeParser = null, this.attributeStart = null, e !== null)
        for (const n of e)
          this.feed(n.startpos, n.endpos);
      this.allowAttributes = true, this.attributeSlices = null;
    }
  }
  getMatches() {
    const e = this.subject;
    this.attributeParser && this.reparseAttributes();
    let n = this.matches.length - 1;
    if (this.matches[n] && this.matches[n].annot === "soft_break") {
      this.matches.pop();
      const r = this.matches[this.matches.length - 1];
      if (r && r.annot === "str" && e.codePointAt(r.endpos) === 32) {
        for (; r.endpos >= r.startpos && e.codePointAt(r.endpos) === 32; )
          r.endpos = r.endpos - 1;
        r.endpos < r.startpos && this.matches.pop();
      }
    }
    if (this.matches.length > 0 && this.verbatim > 0) {
      const r = this.matches[this.matches.length - 1];
      this.warn(new ga.Warning("Unclosed verbatim", r.endpos)), this.matches.push({
        startpos: r.endpos,
        endpos: r.endpos,
        annot: "-" + this.verbatimType
      });
    }
    return this.matches;
  }
  addOpener(e, n, r, s) {
    this.openers[e] || (this.openers[e] = []), this.openers[e].push({
      matchIndex: this.matches.length,
      startpos: n,
      endpos: r,
      annot: null,
      subMatchIndex: this.matches.length,
      substartpos: null,
      subendpos: null
    }), this.addMatch(n, r, s);
  }
  clearOpeners(e, n) {
    for (const r in this.openers) {
      const s = this.openers[r];
      let a = s.length - 1;
      for (; s[a]; ) {
        const l = s[a];
        if (l.startpos >= e && l.endpos <= n)
          s.splice(a, 1);
        else if (l.substartpos && l.substartpos >= e && l.subendpos && l.subendpos <= n)
          s[a].substartpos = null, s[a].subendpos = null, s[a].annot = null;
        else
          break;
        a--;
      }
    }
  }
  strMatches(e, n) {
    let r = this.matches.length - 1;
    for (; r > 0 && this.matches[r].startpos >= e; )
      r--;
    for (this.matches[r].startpos < e && r++; this.matches[r] && this.matches[r].endpos <= n; ) {
      const s = this.matches[r];
      s.annot !== "escape" && s.annot !== "str" && (s.annot = "str"), r++;
    }
  }
  feed(e, n) {
    const r = this.subject;
    (this.firstpos === -1 || e < this.firstpos) && (this.firstpos = e), (this.lastpos === 0 || n > this.lastpos) && (this.lastpos = n);
    let s = e;
    for (; s <= n; )
      if (this.attributeParser !== null) {
        const a = s, l = gr(r, s, n);
        let u;
        l === null ? u = n : u = l;
        const c = this.attributeParser.feed(a, u), m = c.position;
        if (c.status === "done") {
          const b = this.attributeStart;
          b !== null && this.addMatch(b, b, "+attributes");
          const A = this.attributeParser.matches;
          for (const x of A)
            this.addMatch(x.startpos, x.endpos, x.annot);
          this.addMatch(m, m, "-attributes"), this.attributeParser = null, this.attributeStart = null, this.attributeSlices = null, s = m + 1;
        } else c.status === "fail" ? (this.reparseAttributes(), s = a) : c.status === "continue" && (this.attributeSlices === null && (this.attributeSlices = []), this.attributeSlices.push({ startpos: a, endpos: m }), s = m + 1);
      } else {
        const a = gr(r, s, n);
        let l;
        if (a === null ? l = n + 1 : l = a, l > s && (this.addMatch(s, l - 1, "str"), s = l, s > n))
          break;
        const u = r.codePointAt(s);
        if (u === void 0)
          throw new Error("Code point at " + s + " is undefined.");
        if (u === an || u === sn)
          u === an && r.codePointAt(s + 1) === sn && s + 1 <= n ? (this.addMatch(s, s + 1, "soft_break"), s = s + 2) : (this.addMatch(s, s, "soft_break"), s = s + 1);
        else if (this.verbatim > 0)
          if (u === 96) {
            const c = (0, J.find)(r, Pa, s, n);
            if (c) {
              const m = c.endpos;
              if (c.endpos - s + 1 === this.verbatim) {
                const b = (0, J.find)(r, za, m + 1, n);
                b && this.verbatimType === "verbatim" ? (this.addMatch(s, m, "-" + this.verbatimType), this.addMatch(b.startpos, b.endpos, "raw_format"), s = b.endpos + 1) : (this.addMatch(s, m, "-" + this.verbatimType), s = m + 1), this.verbatim = 0, this.verbatimType = "verbatim";
              } else
                this.addMatch(s, m, "str"), s = m + 1;
            } else
              this.addMatch(s, n, "str"), s = n + 1;
          } else
            this.addMatch(s, s, "str"), s = s + 1;
        else {
          const c = this.matchers[u];
          if (c) {
            const m = c(this, s, n);
            m === null ? s = this.singleChar(s) : s = m;
          } else
            s = this.singleChar(s);
        }
      }
  }
};
qe.InlineParser = Ra;
Object.defineProperty(re, "__esModule", { value: true });
re.parseEvents = void 0;
var xr = It;
var Ua = se;
var tt = Ft;
var Ve = qe;
var He = function(t) {
  return t === "+" || t === "-" || t === "*" || t === ":" ? [t] : /^[+*-] \[[Xx ]\]/.exec(t) ? ["X"] : /^[(]?[0-9]+[).]/.exec(t) ? [t.replace(/[0-9]+/, "1")] : /^[(]?[ivxlcdm][).]/.exec(t) ? [t.replace(/[a-z]+/, "i"), t.replace(/[a-z]+/, "a")] : /^[(]?[IVXLCDM][).]/.exec(t) ? [t.replace(/[A-Z]+/, "I"), t.replace(/[A-Z]+/, "A")] : /^[(]?[ivxlcdm]+[).]/.exec(t) ? [t.replace(/[a-z]+/, "i")] : /^[(]?[IVXLCDM]+[).]/.exec(t) ? [t.replace(/[A-Z]+/, "I")] : /^[(]?[a-z][).]/.exec(t) ? [t.replace(/[a-z]/, "a")] : /^[(]?[A-Z][).]/.exec(t) ? [t.replace(/[A-Z]/, "A")] : [];
};
var Wa = function(t) {
  return t === 32 || t === 9;
};
var Va = function(t) {
  return t === 10 || t === 13;
};
var yr = (0, tt.pattern)("[ \\t]*\\r?\\n");
var Ha = (0, tt.pattern)("^\\w+\\s");
var me = (0, tt.pattern)("[ \\t\\r\\n]");
var Za = (0, tt.pattern)("[^ \\t\\r\\n]+");
var wr = (0, tt.pattern)("[>][ \\t\\r\\n]");
var vr = (0, tt.pattern)("#+");
var Xa = (0, tt.pattern)("(~~~~*|````*)([ \\t]*)([^ \\t\\r\\n`]*)[ \\t]*\\r?\\n");
var Ya = (0, tt.pattern)("(:?)--*(:?)([ \\t]*\\|[ \\t]*)");
var Ka = (0, tt.pattern)("[^`|\\r\\n]*(?:[|]|`+)");
var Qa = (0, tt.pattern)("\\^[ \\t]+");
var Ja = (0, tt.pattern)("\\[\\^([^\\]]+)\\]:[ \\t\\r\\n]");
var to = (0, tt.pattern)("[-*][ 	]*[-*][ \\t]*[-*][-* \\t]*\\r?\\n");
var eo = (0, tt.pattern)("(::::*)[ \\t]*\\r?\\n");
var no = (0, tt.pattern)("(::::*)[ \\t]*");
var ro = (0, tt.pattern)("([\\w_-]*)[ \\t]*\\r?\\n");
var so = (0, tt.pattern)("\\[([^\\]\\r\\n]*)\\]:[ \\t]*([^ \\t\\r\\n]*)[\\r\\n]");
var kr = (0, tt.pattern)("(\\|[^\\r\\n]*\\|)[ \\t]*\\r?\\n");
var Ze = (0, tt.pattern)("(:?[-*+:]|\\([0-9]+\\)|[0-9]+[.)]|[ivxlcdmIVXLCDM]+[.)]|\\([ivxlcdmIVXLCDM]+\\)|[a-zA-Z][.)]|\\([a-zA-Z]\\))[ \\t\\r\\n]");
var Xe = (0, tt.pattern)("[*+-] \\[[Xx ]\\][ \\t\\r\\n]");
var W;
(function(t) {
  t[t.None = 0] = "None", t[t.Inline = 1] = "Inline", t[t.Block = 2] = "Block", t[t.Text = 3] = "Text", t[t.Cells = 4] = "Cells", t[t.Attributes = 5] = "Attributes", t[t.ListItem = 6] = "ListItem";
})(W || (W = {}));
var ct = class {
  constructor(e, n) {
    this.name = e.name, this.type = e.type, this.content = e.content, this.continue = e.continue, this.close = e.close, this.indent = 0, this.inlineParser = null, this.attributeParser = null, this.extra = n;
  }
};
var io = class {
  constructor(e, n = {}) {
    e.charAt(e.length - 1) !== `
` && (e = e + `
`), this.subject = e, this.maxoffset = e.length - 1, this.options = n, this.warn = n.warn || (() => {
    }), this.indent = 0, this.startline = 0, this.starteol = 0, this.endeol = 0, this.matches = [], this.containers = [], this.pos = 0, this.lastMatchedContainer = 0, this.finishedLine = false, this.returned = 0, this.paraSpec = {
      name: "para",
      type: W.Block,
      content: W.Inline,
      continue: (r) => this.find(me) === null,
      open: (r) => (this.addContainer(new ct(r, {})), this.addMatch(this.pos, this.pos, "+para"), true),
      close: () => {
        this.getInlineMatches(), this.containers.pop();
        const r = this.matches[this.matches.length - 1], s = r && r.endpos + 1 || this.pos;
        this.addMatch(s, s, "-para");
      }
    }, this.specs = [
      {
        name: "block_quote",
        type: W.Block,
        content: W.Block,
        continue: (r) => this.find(wr) !== null ? (this.pos = this.pos + 1, true) : false,
        open: (r) => this.find(wr) !== null ? (this.addContainer(new ct(r, {})), this.addMatch(this.pos, this.pos, "+block_quote"), this.pos = this.pos + 1, true) : false,
        close: () => {
          this.containers.pop(), this.addMatch(this.pos, this.pos, "-block_quote");
        }
      },
      {
        name: "heading",
        type: W.Block,
        content: W.Inline,
        continue: (r) => {
          const s = this.find(vr);
          return s && r.extra.level === s.endpos - s.startpos + 1 && (0, tt.find)(this.subject, me, s.endpos + 1) ? (this.pos = s.endpos + 1, true) : false;
        },
        open: (r) => {
          const s = this.find(vr);
          if (s && (0, tt.find)(this.subject, me, s.endpos + 1)) {
            const a = s.endpos - s.startpos + 1;
            return this.addContainer(new ct(r, { level: a })), this.addMatch(s.startpos, s.endpos, "+heading"), this.pos = s.endpos + 1, true;
          } else
            return false;
        },
        close: () => {
          this.getInlineMatches(), this.containers.pop();
          const r = this.matches[this.matches.length - 1], s = r && r.endpos + 1 || this.pos;
          this.addMatch(s, s, "-heading");
        }
      },
      {
        name: "caption",
        type: W.Block,
        content: W.Inline,
        continue: (r) => (0, tt.find)(this.subject, me, this.pos) === null,
        open: (r) => {
          const s = this.find(Qa);
          return s ? (this.pos = s.endpos + 1, this.addContainer(new ct(r, {})), this.addMatch(this.pos, this.pos, "+caption"), true) : false;
        },
        close: () => {
          this.getInlineMatches(), this.containers.pop(), this.addMatch(this.pos - 1, this.pos - 1, "-caption");
        }
      },
      // should go before reference definitions
      {
        name: "footnote",
        type: W.Block,
        content: W.Block,
        continue: (r) => this.indent > (r.extra.indent || 0) || this.pos === this.starteol,
        open: (r) => {
          const s = this.find(Ja);
          if (s) {
            const a = s.startpos, l = s.endpos, u = s.captures[0];
            return this.addContainer(new ct(r, {
              note_label: u,
              indent: this.indent
            })), this.addMatch(a, a, "+footnote"), this.addMatch(a + 2, l - 3, "note_label"), this.pos = l, true;
          } else
            return false;
        },
        close: () => {
          this.containers.pop(), this.addMatch(this.pos, this.pos, "-footnote");
        }
      },
      {
        name: "reference_definition",
        type: W.Block,
        content: W.None,
        continue: (r) => {
          if (r.extra.indent >= this.indent)
            return false;
          const s = this.find(Za);
          return this.pos < this.starteol && s && s.endpos === this.starteol - 1 ? (this.addMatch(this.pos, this.starteol - 1, "reference_value"), this.pos = this.starteol, true) : false;
        },
        open: (r) => {
          const s = this.find(so);
          if (s) {
            const a = s.captures[0], l = s.captures[1];
            return this.addContainer(new ct(r, { key: a, indent: this.indent })), this.addMatch(s.startpos, s.startpos, "+reference_definition"), this.addMatch(s.startpos, s.startpos + a.length + 1, "reference_key"), l.length > 0 && this.addMatch(this.starteol - l.length, this.starteol - 1, "reference_value"), this.pos = this.starteol - 1, true;
          } else
            return false;
        },
        close: () => {
          this.containers.pop(), this.addMatch(this.pos, this.pos, "-reference_definition");
        }
      },
      // should go before list_item_spec
      {
        name: "thematic_break",
        type: W.Block,
        content: W.None,
        continue: (r) => false,
        open: (r) => {
          const s = this.find(to);
          return s ? (this.addContainer(new ct(r, {})), this.addMatch(s.startpos, s.endpos, "thematic_break"), this.pos = s.endpos, true) : false;
        },
        close: () => {
          this.containers.pop();
        }
      },
      {
        name: "list",
        type: W.Block,
        content: W.ListItem,
        continue: (r) => {
          if (this.indent > r.extra.indent || this.pos === this.starteol)
            return true;
          {
            const s = this.find(Ze);
            if (s === null)
              return false;
            let a = this.subject.substring(s.startpos, s.endpos);
            const l = this.find(Xe);
            l !== null && (a = this.subject.substring(l.startpos, l.startpos + 5));
            const u = He(a), c = [];
            for (const m of r.extra.styles)
              u.includes(m) && c.push(m);
            if (c.length > 0)
              return r.extra.styles = c, true;
          }
          return false;
        },
        open: (r) => {
          const s = this.find(Ze);
          if (s === null)
            return false;
          const a = s.startpos, l = s.endpos;
          let u = this.subject.substring(a, l);
          const c = this.find(Xe);
          c !== null && (u = this.subject.substring(c.startpos, c.startpos + 5));
          const m = He(u);
          if (m.length === 0)
            return false;
          const b = { styles: m, indent: this.indent };
          this.addContainer(new ct(r, b));
          let A = "+list";
          for (const x of m)
            A = A + "|" + x;
          return this.addMatch(a, l - 1, A), true;
        },
        close: () => {
          this.containers.pop(), this.addMatch(this.pos, this.pos, "-list");
        }
      },
      {
        name: "list_item",
        type: W.ListItem,
        content: W.Block,
        continue: (r) => this.indent > r.extra.indent || this.pos === this.starteol,
        open: (r) => {
          const s = this.find(Ze);
          if (s === null)
            return false;
          const a = s.startpos, l = s.endpos;
          let u = this.subject.substring(a, l), c = null;
          const m = this.find(Xe);
          m !== null && (u = this.subject.substring(m.startpos, m.startpos + 5), c = this.subject.substring(m.startpos + 3, m.startpos + 4));
          const b = He(u);
          if (b.length === 0)
            return false;
          const A = { styles: b, indent: this.indent };
          this.addContainer(new ct(r, A));
          let x = "+list_item";
          for (const T of b)
            x = x + "|" + T;
          return this.addMatch(a, l - 1, x), this.pos = l, c && (c === " " ? this.addMatch(a + 2, a + 4, "checkbox_unchecked") : this.addMatch(a + 2, a + 4, "checkbox_checked"), this.pos = a + 5), true;
        },
        close: () => {
          this.containers.pop(), this.addMatch(this.pos, this.pos, "-list_item");
        }
      },
      {
        name: "table",
        type: W.Block,
        content: W.Cells,
        continue: (r) => {
          const s = this.find(kr);
          if (s) {
            const a = s.captures[0];
            return this.parseTableRow(s.startpos, s.startpos + a.length - 1);
          } else
            return false;
        },
        open: (r) => {
          const s = this.find(kr);
          if (s) {
            this.addContainer(new ct(r, { columns: 0 }));
            const a = s.captures[0];
            return this.addMatch(s.startpos, s.startpos, "+table"), this.parseTableRow(s.startpos, s.startpos + a.length - 1) ? true : (this.matches.pop(), this.containers.pop(), false);
          } else
            return false;
        },
        close: () => {
          this.containers.pop(), this.addMatch(this.pos, this.pos, "-table");
        }
      },
      {
        name: "attributes",
        type: W.Block,
        content: W.Attributes,
        open: (r) => {
          if (this.subject.codePointAt(this.pos) === 123) {
            const s = new Ua.AttributeParser(this.subject), a = s.feed(this.pos, this.starteol);
            if (a.status === "fail")
              return false;
            if (a.status === "done" && (0, tt.find)(this.subject, yr, a.position + 1) === null)
              return false;
            {
              const l = this.addContainer(new ct(r, {
                status: a.status,
                indent: this.indent,
                startpos: this.pos,
                slices: []
              }));
              return l.attributeParser = s, l.extra.slices = [{ startpos: this.pos, endpos: this.starteol }], this.pos = this.starteol, true;
            }
          } else
            return false;
        },
        continue: (r) => {
          if (r.extra.status === "done")
            return false;
          if (r.attributeParser && this.indent > r.extra.indent) {
            r.extra.slices.push({
              startpos: this.pos,
              endpos: this.starteol
            });
            const l = r.attributeParser.feed(this.pos, this.endeol);
            if (r.extra.status = l.status, l.status !== "fail" || !(0, tt.find)(this.subject, yr, l.position + 1))
              return this.pos = this.starteol, true;
          }
          this.addMatch(r.extra.startpos, r.extra.startpos, "+para");
          const s = this.containers.pop(), a = this.addContainer(new ct(this.paraSpec, {}));
          if (!a.inlineParser || !s)
            throw new Error("Missing inlineParser or attrContainer");
          return a.inlineParser.attributeSlices = s.extra.slices, a.inlineParser.reparseAttributes(), this.pos = a.inlineParser.lastpos + 1, true;
        },
        close: () => {
          const r = this.containers.pop();
          if (r)
            if (r.extra.status === "continue") {
              this.addMatch(r.extra.startpos, r.extra.startpos, "+para");
              const s = this.addContainer(new ct(this.paraSpec, {}), true);
              if (!s || !s.inlineParser)
                throw new Error("Could not add paragraph");
              s.inlineParser.attributeSlices = r.extra.slices, s.inlineParser.reparseAttributes(), s.close();
            } else {
              if (this.addMatch(r.extra.startpos, r.extra.startpos, "+block_attributes"), r.attributeParser) {
                const s = r.attributeParser.matches;
                for (const a of s)
                  this.matches.push(a);
              }
              this.addMatch(this.pos, this.pos, "-block_attributes");
            }
        }
      },
      {
        name: "fenced_div",
        type: W.Block,
        content: W.Block,
        continue: (r) => {
          const s = this.tip();
          if (s && s.name === "code_block")
            return true;
          const a = this.find(eo);
          if (a && r.extra.colons) {
            const l = a.captures[0];
            if (l.length >= r.extra.colons)
              return r.extra.endFenceStartpos = a.startpos, r.extra.endFenceEndpos = a.startpos + l.length - 1, this.pos = a.endpos, false;
          }
          return true;
        },
        open: (r) => {
          const s = this.find(no);
          if (!s)
            return false;
          const a = s.captures[0], l = (0, tt.find)(this.subject, ro, s.endpos + 1);
          if (!l)
            return false;
          const u = l.startpos, c = l.captures[0];
          return this.addContainer(new ct(r, { colons: a.length })), this.addMatch(s.startpos, s.endpos, "+div"), c.length > 0 && this.addMatch(u, u + c.length - 1, "class"), this.pos = l.endpos + 1, this.finishedLine = true, true;
        },
        close: () => {
          const r = this.containers.pop();
          if (!r)
            return;
          const s = r.extra.endFenceStartpos || this.pos, a = r.extra.endFenceEndpos || this.pos;
          this.addMatch(s, a, "-div"), s === a && this.warn(new xr.Warning("Unclosed div", this.pos));
        }
      },
      {
        name: "code_block",
        type: W.Block,
        content: W.Text,
        continue: (r) => {
          const s = this.find(r.extra.closePattern);
          return s ? (r.extra.endFenceStartpos = s.startpos, r.extra.endFenceEndpos = s.startpos + s.captures[0].length - 1, this.pos = s.endpos, this.finishedLine = true, false) : true;
        },
        open: (r) => {
          const s = this.find(Xa);
          if (s) {
            const [a, l, u] = s.captures, c = u.charAt(0) === "=" && true || false, m = (0, tt.pattern)("(" + a + a.substring(0, 1) + "*)[ \\t]*[\\r\\n]"), b = this.addContainer(new ct(r, { closePattern: m }));
            if (b.indent = this.indent, this.addMatch(s.startpos, s.startpos + a.length - 1, "+code_block"), u.length > 0) {
              const A = s.startpos + a.length + l.length;
              c ? this.addMatch(A, A + u.length - 1, "raw_format") : this.addMatch(A, A + u.length - 1, "code_language");
            }
            return this.pos = s.endpos, this.finishedLine = true, true;
          } else
            return false;
        },
        close: () => {
          const r = this.containers.pop();
          if (!r)
            return;
          const s = r.extra.endFenceStartpos || this.pos, a = r.extra.endFenceEndpos || this.pos;
          this.addMatch(s, a, "-code_block"), s === a && this.warn(new xr.Warning("Unclosed code block", this.pos));
        }
      }
    ];
  }
  find(e) {
    return (0, tt.find)(this.subject, e, this.pos);
  }
  tip() {
    return this.containers.length >= 1 ? this.containers[this.containers.length - 1] : null;
  }
  addMatch(e, n, r) {
    this.matches.push({
      startpos: Math.min(e, this.maxoffset),
      endpos: Math.min(n, this.maxoffset),
      annot: r
    });
  }
  getInlineMatches() {
    var e;
    const n = (e = this.tip()) === null || e === void 0 ? void 0 : e.inlineParser;
    if (n) {
      let r;
      for (const s of n.getMatches())
        r && r.annot === "str" && s.annot === "str" && s.startpos === r.endpos + 1 ? this.matches[this.matches.length - 1].endpos = s.endpos : this.matches.push(s), r = s;
    }
  }
  closeUnmatchedContainers() {
    const e = this.lastMatchedContainer;
    let n = this.tip();
    for (; n && this.containers.length - 1 > e; )
      n.close(), n = this.tip();
  }
  addContainer(e, n) {
    n || this.closeUnmatchedContainers();
    let r = this.tip();
    for (; r && r.content !== e.type; )
      r.close(), r = this.tip();
    return e.content === W.Inline && (e.inlineParser = new Ve.InlineParser(this.subject, { warn: this.warn })), this.containers.push(e), e;
  }
  // move parser position to first nonspace, adjusting indent
  skipSpace() {
    const e = this.subject;
    let n = this.pos;
    for (; Wa(e.codePointAt(n)); )
      n++;
    this.indent = n - this.startline, this.pos = n;
  }
  // set this.starteol, this.endeol
  getEol() {
    const e = this.subject;
    let n = this.pos;
    for (; !Va(e.codePointAt(n)); )
      n++;
    this.starteol = n, e.codePointAt(n) === 13 && e.codePointAt(n + 1) === 10 ? this.endeol = n + 1 : this.endeol = n;
  }
  parseTableCell() {
    const e = new Ve.InlineParser(this.subject, { warn: this.warn });
    let n = false;
    const r = this.pos - 1;
    let s = r;
    for (this.skipSpace(); !n; ) {
      const a = this.find(Ka);
      if (a === null) {
        n = false;
        break;
      } else {
        const l = a.endpos;
        this.subject.charAt(l) === "`" || e.inVerbatim() ? e.feed(this.pos, l) : this.subject.charAt(l - 1) === "\\" ? e.feed(this.pos, l) : (e.feed(this.pos, l - 1), s = l, n = true), this.pos = l + 1;
      }
    }
    if (n) {
      const a = e.getMatches();
      return { startpos: r, endpos: s, matches: a };
    } else
      return null;
  }
  // Parameters are start and end position
  parseTableRow(e, n) {
    const r = this.matches.length, s = this.pos;
    this.addMatch(e, e, "+row"), this.pos++;
    const a = [];
    let l = this.pos, u = false;
    for (; !u; ) {
      const c = (0, tt.find)(this.subject, Ya, l);
      if (c !== null) {
        const [m, b, A] = c.captures;
        let x = "separator_default";
        if (m.length > 0 && b.length > 0 ? x = "separator_center" : b.length > 0 ? x = "separator_right" : m.length > 0 && (x = "separator_left"), a.push({
          startpos: c.startpos,
          endpos: c.endpos - A.length,
          annot: x
        }), l = c.endpos + 1, l === this.starteol) {
          u = true;
          break;
        }
      } else
        break;
    }
    if (u) {
      for (const c of a)
        this.addMatch(c.startpos, c.endpos, c.annot);
      return this.addMatch(this.starteol - 1, this.starteol - 1, "-row"), this.pos = this.starteol, this.finishedLine = true, true;
    }
    for (; this.pos <= n; ) {
      const c = this.parseTableCell();
      if (c !== null) {
        this.addMatch(c.startpos, c.startpos, "+cell");
        const m = c.matches;
        m.forEach((b, A) => {
          const x = b.startpos;
          let T = b.endpos;
          if (A === m.length - 1 && b.annot === "str")
            for (; this.subject.codePointAt(T) === 32 && T >= x; )
              T = T - 1;
          this.addMatch(x, T, b.annot);
        }), this.addMatch(c.endpos, c.endpos, "-cell");
      } else {
        for (this.pos = s; this.matches.length > r; )
          this.matches.pop();
        return false;
      }
    }
    return this.addMatch(this.pos, this.pos, "-row"), this.pos = this.starteol, this.finishedLine = true, true;
  }
  // Returns an iterator over events.  At each iteration, the iterator
  // returns three values: start byte position, end byte position,
  // and annotation.
  [Symbol.iterator]() {
    const e = this.specs, n = this.subject.length;
    this.returned = 0;
    const r = this;
    return {
      next() {
        for (; r.pos < n; ) {
          if (r.matches.length > 0 && r.returned < r.matches.length)
            return r.returned = r.returned + 1, {
              value: r.matches[r.returned - 1],
              done: false
            };
          r.indent = 0, r.startline = r.pos, r.finishedLine = false, r.getEol(), r.lastMatchedContainer = -1;
          let s = 0;
          for (; s < r.containers.length; ) {
            const a = r.containers[s];
            if (r.skipSpace(), a.continue(a))
              r.lastMatchedContainer = s;
            else
              break;
            s = s + 1;
          }
          if (r.finishedLine)
            for (; r.containers.length > 0 && r.lastMatchedContainer < r.containers.length - 1; ) {
              const a = r.tip();
              a && a.close();
            }
          if (!r.finishedLine) {
            r.skipSpace();
            let a = r.pos === r.starteol, l = false, u = r.containers[r.lastMatchedContainer], c = !a && (!u || u.content === W.Block || u.content === W.ListItem) && !r.find(Ha);
            for (; c; ) {
              c = false;
              for (const m of e)
                if ((!u && m.type === W.Block || u && u.content === m.type) && m.open(m)) {
                  if (r.tip())
                    r.lastMatchedContainer = r.containers.length - 1, u = r.containers[r.lastMatchedContainer], r.finishedLine ? c = false : (r.skipSpace(), l = true, c = m.content === W.Block || m.content === W.ListItem);
                  else
                    throw new Error("No tip after opening container");
                  break;
                }
            }
            if (!r.finishedLine) {
              r.skipSpace(), a = r.pos === r.starteol;
              let m = r.tip();
              if (!a && !l && r.lastMatchedContainer < r.containers.length - 1 && m && m.content === W.Inline || r.closeUnmatchedContainers(), m = r.tip(), (!m || m.content === W.Block) && (a ? l || r.addMatch(r.pos, r.endeol, "blankline") : (r.paraSpec.open(r.paraSpec), m = r.tip(), m && (m.inlineParser = new Ve.InlineParser(r.subject, r.options)))), m && m.content === W.Text) {
                let A = r.pos;
                m.indent !== null && r.indent > m.indent && (A = A - (r.indent - m.indent)), r.addMatch(A, r.endeol, "str");
              } else m && m.content === W.Inline && !a && m.inlineParser && m.inlineParser.feed(r.pos, r.endeol);
            }
          }
          r.pos = (r.endeol || r.pos) + 1;
        }
        return r.lastMatchedContainer = -1, r.closeUnmatchedContainers(), r.matches.length > 0 && r.returned < r.matches.length ? (r.returned = r.returned + 1, { value: r.matches[r.returned - 1], done: false }) : {
          value: { startpos: r.pos, endpos: r.pos, annot: "" },
          done: true
        };
      }
    };
  }
};
var ao = function(t, e = {}) {
  return new io(t, e);
};
re.parseEvents = ao;
var xt = {};
Object.defineProperty(xt, "__esModule", { value: true });
xt.isCaption = xt.isRow = xt.isBlock = xt.isInline = void 0;
var oo = {
  para: true,
  heading: true,
  block_quote: true,
  thematic_break: true,
  section: true,
  div: true,
  code_block: true,
  raw_block: true,
  bullet_list: true,
  ordered_list: true,
  task_list: true,
  definition_list: true,
  table: true,
  reference: true,
  footnote: true
};
function lo(t) {
  return oo[t.tag] || false;
}
xt.isBlock = lo;
var uo = {
  str: true,
  soft_break: true,
  hard_break: true,
  non_breaking_space: true,
  symb: true,
  verbatim: true,
  raw_inline: true,
  inline_math: true,
  display_math: true,
  url: true,
  email: true,
  footnote_reference: true,
  smart_punctuation: true,
  emph: true,
  strong: true,
  link: true,
  image: true,
  span: true,
  mark: true,
  superscript: true,
  subscript: true,
  insert: true,
  delete: true,
  double_quoted: true,
  single_quoted: true
};
function co(t) {
  return uo[t.tag] || false;
}
xt.isInline = co;
function ho(t) {
  return "head" in t;
}
xt.isRow = ho;
function po(t) {
  return !("head" in t);
}
xt.isCaption = po;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: true }), t.isInline = t.isCaption = t.isRow = t.isBlock = t.getStringContent = t.renderAST = t.parse = void 0;
  const e = re, n = It, r = xt;
  Object.defineProperty(t, "isRow", { enumerable: true, get: function() {
    return r.isRow;
  } }), Object.defineProperty(t, "isBlock", { enumerable: true, get: function() {
    return r.isBlock;
  } }), Object.defineProperty(t, "isCaption", { enumerable: true, get: function() {
    return r.isCaption;
  } }), Object.defineProperty(t, "isInline", { enumerable: true, get: function() {
    return r.isInline;
  } });
  const s = function(N) {
    const $ = [];
    return a(N, $), $.join("");
  };
  t.getStringContent = s;
  const a = function(N, $) {
    if ("text" in N)
      $.push(N.text);
    else if ("tag" in N && (N.tag === "soft_break" || N.tag === "hard_break"))
      $.push(`
`);
    else if ("children" in N)
      for (const R of N.children)
        a(R, $);
  }, l = function(N) {
    return N.replace(/^ `/, "`").replace(/` $/, "`");
  }, u = {
    i: 1,
    v: 5,
    x: 10,
    l: 50,
    c: 100,
    d: 500,
    m: 1e3,
    I: 1,
    V: 5,
    X: 10,
    L: 50,
    C: 100,
    D: 500,
    M: 1e3
  }, c = function(N) {
    let $ = 0, R = 0, K = N.length - 1;
    for (; K >= 0; ) {
      const X = N.charAt(K), Y = u[X];
      if (!Y)
        throw new Error("Encountered bad character in roman numeral " + N);
      Y < R ? $ = $ - Y : $ = $ + Y, R = Y, K = K - 1;
    }
    return $;
  }, m = function(N, $) {
    const R = $.replace(/[().]/g, ""), K = N.replace(/[().]/g, "");
    switch (R) {
      case "1":
        return parseInt(K, 10);
      case "A":
        return (K.codePointAt(0) || 65) - 65 + 1;
      case "a":
        return (K.codePointAt(0) || 97) - 97 + 1;
      case "I":
        return c(K);
      case "i":
        return c(K);
    }
  };
  var b;
  (function(N) {
    N[N.Normal = 0] = "Normal", N[N.Verbatim = 1] = "Verbatim", N[N.Literal = 2] = "Literal";
  })(b || (b = {}));
  const A = function(N) {
    return N.trim().replace(/[ \t\r\n]+/g, " ");
  }, x = function(N, $ = {}) {
    const R = [-1];
    if ($.sourcePositions)
      for (let v = 0; v < N.length; v++)
        N[v] === `
` && R.push(v);
    const K = function(v) {
      const k = R.length;
      let S = 0, g = k - 1, p = 0, M = 0;
      for (; !p; ) {
        const L = S + ~~((g - S) / 2);
        R[L] > v ? g = L : R[L] <= v && (L === g || R[L + 1] > v ? (p = L + 1, M = v - R[L]) : S === L && S < g ? S = L + 1 : S = L);
      }
      return { line: p, col: M, offset: v };
    };
    let X = b.Normal, Y = "";
    const $e = {}, Ie = {}, Sn = {}, ie = {}, St = {};
    let De = 0;
    const is = (0, e.parseEvents)(N, $), Nn = $.warn || (() => {
    }), Cn = function(v) {
      if (Object.keys(St).length > 0) {
        v.attributes = v.attributes || {};
        for (const k in St)
          v.attributes[k] = St[k], delete St[k];
      }
    }, as = function(v) {
      const k = v.replace(/[\]\[~!@#$%^&*(){}`,.<>\\|=+/?\s]+/g, " ").trim().replace(/ +/g, "-");
      let S = 0, g = k;
      for (; !g || ie[g]; )
        S = S + 1, g = (k || "s") + "-" + S;
      return g;
    }, Z = function(v) {
      const k = {
        children: [],
        data: {},
        pos: v,
        attributes: void 0
      };
      Cn(k), st.push(k);
    }, H = function(v) {
      const k = st.pop();
      if (!k)
        throw new Error("Container stack is empty (popContainer)");
      return v && k.pos && (k.pos.end = v.end), k;
    }, F = function() {
      if (st.length > 0)
        return st[st.length - 1];
      throw new Error("Container stack is empty (topContainer)");
    }, ae = function() {
      const v = F();
      return v.children.length > 0 ? v.children[v.children.length - 1] : v;
    }, B = function(v) {
      st.length > 0 && st[st.length - 1].children.push(v);
    }, os = {
      str: (v, k, S, g) => {
        const p = N.substring(k, S + 1);
        X === b.Normal ? B({ tag: "str", text: p, pos: g }) : Y += p;
      },
      soft_break: (v, k, S, g) => {
        X === b.Normal ? B({ tag: "soft_break", pos: g }) : Y += `
`;
      },
      escape: (v, k, S, g) => {
        X === b.Verbatim && (Y += "\\");
      },
      hard_break: (v, k, S, g) => {
        X === b.Normal ? B({ tag: "hard_break", pos: g }) : Y += `
`;
      },
      non_breaking_space: (v, k, S, g) => {
        X === b.Verbatim ? Y += "\\ " : B({ tag: "non_breaking_space", pos: g });
      },
      symb: (v, k, S, g) => {
        if (X === b.Normal) {
          const p = N.substring(k + 1, S);
          B({ tag: "symb", alias: p, pos: g });
        } else {
          const p = N.substring(k, S + 1);
          Y += p;
        }
      },
      footnote_reference: (v, k, S, g) => {
        const p = N.substring(k + 2, S);
        B({
          tag: "footnote_reference",
          text: A(p),
          pos: g
        });
      },
      "+reference_definition": (v, k, S, g) => {
        Z(g);
      },
      "-reference_definition": (v, k, S, g) => {
        const p = H(g), M = A(p.data.key), L = {
          tag: "reference",
          label: M,
          destination: p.data.value || "",
          attributes: p.attributes,
          pos: p.pos
        };
        p.data.key && ($e[M] = L);
      },
      reference_key: (v, k, S, g) => {
        F().data.key = N.substring(k + 1, S), F().data.value = "";
      },
      reference_value: (v, k, S, g) => {
        F().data.value = F().data.value + N.substring(k, S + 1);
      },
      "+emph": (v, k, S, g) => {
        Z(g);
      },
      "-emph": (v, k, S, g) => {
        const p = H(g);
        B({ tag: "emph", children: p.children, pos: p.pos });
      },
      "+strong": (v, k, S, g) => {
        Z(g);
      },
      "-strong": (v, k, S, g) => {
        const p = H(g);
        B({ tag: "strong", children: p.children, pos: p.pos });
      },
      "+span": (v, k, S, g) => {
        Z(g);
      },
      "-span": (v, k, S, g) => {
        const p = H(g);
        B({ tag: "span", children: p.children, pos: p.pos });
      },
      "+mark": (v, k, S, g) => {
        Z(g);
      },
      "-mark": (v, k, S, g) => {
        const p = H(g);
        B({ tag: "mark", children: p.children, pos: p.pos });
      },
      "+superscript": (v, k, S, g) => {
        Z(g);
      },
      "-superscript": (v, k, S, g) => {
        const p = H(g);
        B({ tag: "superscript", children: p.children, pos: p.pos });
      },
      "+subscript": (v, k, S, g) => {
        Z(g);
      },
      "-subscript": (v, k, S, g) => {
        const p = H(g);
        B({ tag: "subscript", children: p.children, pos: p.pos });
      },
      "+delete": (v, k, S, g) => {
        Z(g);
      },
      "-delete": (v, k, S, g) => {
        const p = H(g);
        B({ tag: "delete", children: p.children, pos: p.pos });
      },
      "+insert": (v, k, S, g) => {
        Z(g);
      },
      "-insert": (v, k, S, g) => {
        const p = H(g);
        B({ tag: "insert", children: p.children, pos: p.pos });
      },
      "+double_quoted": (v, k, S, g) => {
        Z(g);
      },
      "-double_quoted": (v, k, S, g) => {
        const p = H(g);
        B({ tag: "double_quoted", children: p.children, pos: p.pos });
      },
      "+single_quoted": (v, k, S, g) => {
        Z(g);
      },
      "-single_quoted": (v, k, S, g) => {
        const p = H(g);
        B({ tag: "single_quoted", children: p.children, pos: p.pos });
      },
      "+attributes": (v, k, S, g) => {
        Z(g);
      },
      "-attributes": (v, k, S, g) => {
        const p = H(g);
        if (p.attributes && st.length > 0) {
          p.attributes.id && (ie[p.attributes.id] = true);
          let M = ae();
          if (M === F())
            return;
          let L = false;
          if ("tag" in M && M.tag === "str") {
            const U = M.text.match(/[^\s]+$/);
            if (U && U.index && U.index > 0) {
              let gt;
              if (M.pos) {
                const bt = M.pos.end;
                M.pos.end = {
                  line: bt.line,
                  col: bt.col - U[0].length,
                  offset: bt.offset - U[0].length
                }, gt = {
                  start: {
                    line: bt.line,
                    col: bt.col - U[0].length + 1,
                    offset: bt.offset - U[0].length + 1
                  },
                  end: bt
                };
              }
              M.text = M.text.substring(0, U.index), B({ tag: "str", text: U[0], pos: gt });
            } else U || (L = true);
          }
          if (M = ae(), L) {
            Nn(new n.Warning("Ignoring unattached attribute", $.sourcePositions ? K(k) : k));
            return;
          }
          M.attributes || (M.attributes = {});
          for (const U in p.attributes)
            U === "class" && M.attributes[U] ? M.attributes[U] = M.attributes[U] + " " + p.attributes[U] : M.attributes[U] = p.attributes[U];
        }
      },
      "+block_attributes": (v, k, S, g) => {
        Z(g);
      },
      "-block_attributes": (v, k, S, g) => {
        const p = H(g);
        if (p.attributes && st.length > 0) {
          p.attributes.id && (ie[p.attributes.id] = true);
          for (const M in p.attributes)
            M === "class" && St[M] ? St[M] = St[M] + " " + p.attributes[M] : St[M] = p.attributes[M];
        }
      },
      class: (v, k, S, g) => {
        const p = F(), M = N.substring(k, S + 1);
        p.attributes || (p.attributes = {}), p.attributes.class ? p.attributes.class = p.attributes.class + " " + M : p.attributes.class = M;
      },
      id: (v, k, S, g) => {
        const p = F(), M = N.substring(k, S + 1);
        p.attributes ? p.attributes.id = M : p.attributes = { id: M };
      },
      key: (v, k, S, g) => {
        const p = F(), M = N.substring(k, S + 1);
        p.data.key = M, p.attributes || (p.attributes = {}), p.attributes[p.data.key] = "";
      },
      value: (v, k, S, g) => {
        const p = F(), M = N.substring(k, S + 1).replace(/[ \r\n]+/g, " ").replace(/\\([.,\\/#!$%^&*;:{}=\-_`~+[\]()'"?|])/g, "$1");
        if (p.attributes || (p.attributes = {}), p.data.key)
          p.attributes[p.data.key] = // append multiple values to key
          p.attributes[p.data.key] + M;
        else
          throw new Error("Encountered value without key");
      },
      "+linktext": (v, k, S, g) => {
        Z(g), F().data.isimage = false;
      },
      "-linktext": (v, k, S, g) => {
      },
      "+imagetext": (v, k, S, g) => {
        Z(g), F().data.isimage = true;
      },
      "-imagetext": (v, k, S, g) => {
      },
      "+destination": (v, k, S, g) => {
        X = b.Literal;
      },
      "-destination": (v, k, S, g) => {
        const p = H(g);
        B({
          tag: p.data.isimage ? "image" : "link",
          destination: Y.replace(/[\r\n]/g, ""),
          children: p.children,
          pos: p.pos
        }), X = b.Normal, Y = "";
      },
      "+reference": (v, k, S, g) => {
        X = b.Literal;
      },
      "-reference": (v, k, S, g) => {
        const p = H(g);
        let M = Y;
        M.length === 0 && (M = s(p)), B({
          tag: p.data.isimage ? "image" : "link",
          reference: A(M),
          children: p.children,
          pos: p.pos
        }), X = b.Normal, Y = "";
      },
      "+verbatim": (v, k, S, g) => {
        X = b.Verbatim, Z(g);
      },
      "-verbatim": (v, k, S, g) => {
        const p = H(g);
        B({
          tag: "verbatim",
          text: l(Y),
          pos: p.pos
        }), X = b.Normal, Y = "";
      },
      raw_format: (v, k, S, g) => {
        const p = N.substring(k, S + 1).replace(/^\{?=/, "").replace(/\}$/, ""), M = F();
        if (X === b.Verbatim)
          M.data.format = p;
        else {
          const L = M.children[M.children.length - 1];
          if (L && "tag" in L && L.tag === "verbatim")
            L.tag = "raw_inline", L.format = p;
          else
            throw new Error("raw_format is not after verbatim or code_block.");
        }
      },
      "+display_math": (v, k, S, g) => {
        X = b.Verbatim, Z(g);
      },
      "+inline_math": (v, k, S, g) => {
        X = b.Verbatim, Z(g);
      },
      "-display_math": (v, k, S, g) => {
        const p = H(g);
        B({
          tag: "display_math",
          text: l(Y),
          pos: p.pos
        }), X = b.Normal, Y = "";
      },
      "-inline_math": (v, k, S, g) => {
        const p = H(g);
        B({
          tag: "inline_math",
          text: l(Y),
          pos: p.pos
        }), X = b.Normal, Y = "";
      },
      "+url": (v, k, S, g) => {
        X = b.Literal, Z(g);
      },
      "-url": (v, k, S, g) => {
        const p = H(g);
        B({
          tag: "url",
          text: Y.replace(/[\r\n]/g, ""),
          pos: p.pos
        }), X = b.Normal, Y = "";
      },
      "+email": (v, k, S, g) => {
        X = b.Literal, Z(g);
      },
      "-email": (v, k, S, g) => {
        const p = H(g);
        B({
          tag: "email",
          text: Y.replace(/[\r\n]/g, ""),
          pos: p.pos
        }), X = b.Normal, Y = "";
      },
      "+para": (v, k, S, g) => {
        Z(g);
      },
      "-para": (v, k, S, g) => {
        const p = H(g);
        B({
          tag: "para",
          children: p.children,
          attributes: p.attributes,
          pos: p.pos
        });
      },
      "+heading": (v, k, S, g) => {
        Z(g), F().data.level = 1 + S - k;
      },
      "-heading": (v, k, S, g) => {
        const p = H(g);
        p.attributes || (p.attributes = {}), p.autoAttributes || (p.autoAttributes = {});
        const M = s(p).trim();
        p.attributes.id || (p.autoAttributes.id = as(M), ie[p.autoAttributes.id] = true);
        const L = A(M);
        !$e[L] && !Ie[L] && (Ie[L] = {
          tag: "reference",
          label: L,
          destination: "#" + (p.attributes.id || p.autoAttributes.id)
        });
        let U = F();
        if (U.data.headinglevel !== void 0) {
          for (; U && U.data.headinglevel !== void 0 && U.data.headinglevel >= p.data.level; )
            U = H(g), B({
              tag: "section",
              children: U.children,
              attributes: U.attributes,
              autoAttributes: U.autoAttributes,
              pos: U.pos
            }), U = F();
          Z(g), F().data.headinglevel = p.data.level, p.autoAttributes && p.autoAttributes.id && (F().autoAttributes = p.autoAttributes, delete p.autoAttributes), p.attributes && p.attributes.id && (F().attributes = p.attributes, delete p.attributes);
        }
        B({
          tag: "heading",
          level: p.data.level,
          children: p.children,
          attributes: p.attributes,
          autoAttributes: p.autoAttributes,
          pos: p.pos
        });
      },
      "+list": (v, k, S, g) => {
        Z(g), F().data.styles = v, F().data.blanklines = false, F().data.tight = true, De++;
      },
      "-list": (v, k, S, g) => {
        const p = H(g), M = p.data.styles[0];
        if (!M)
          throw new Error("No style defined for list");
        const L = m(p.data.firstMarker, M);
        B(M === ":" ? {
          tag: "definition_list",
          children: p.children,
          attributes: p.attributes,
          autoAttributes: p.autoAttributes,
          pos: p.pos
        } : M === "X" ? {
          tag: "task_list",
          tight: p.data.tight,
          children: p.children,
          attributes: p.attributes,
          autoAttributes: p.autoAttributes,
          pos: p.pos
        } : M === "+" || M === "*" || M === "-" ? {
          tag: "bullet_list",
          tight: p.data.tight,
          style: M,
          children: p.children,
          attributes: p.attributes,
          autoAttributes: p.autoAttributes,
          pos: p.pos
        } : {
          tag: "ordered_list",
          style: M,
          children: p.children,
          start: L,
          tight: p.data.tight,
          attributes: p.attributes,
          autoAttributes: p.autoAttributes,
          pos: p.pos
        }), De--;
      },
      "+list_item": (v, k, S, g) => {
        v.length < F().data.styles.length && (F().data.styles = v), F().data.firstMarker || (F().data.firstMarker = N.substring(k, S + 1)), Z(g), v.length === 1 && v[0] === ":" && (F().data.definitionList = true);
      },
      "-list_item": (v, k, S, g) => {
        const p = H(g);
        if (p.data.definitionList)
          if (p.children[0] && p.children[0].tag === "para") {
            const M = {
              tag: "term",
              children: p.children[0].children
            };
            p.children.shift();
            const L = {
              tag: "definition",
              children: p.children
            };
            B({
              tag: "definition_list_item",
              children: [M, L],
              attributes: p.attributes,
              autoAttributes: p.autoAttributes,
              pos: p.pos
            });
          } else {
            const M = { tag: "term", children: [] }, L = {
              tag: "definition",
              children: p.children
            };
            B({
              tag: "definition_list_item",
              children: [M, L],
              attributes: p.attributes,
              autoAttributes: p.autoAttributes,
              pos: p.pos
            });
          }
        else p.data.checkbox ? B({
          tag: "task_list_item",
          children: p.children,
          attributes: p.attributes,
          autoAttributes: p.autoAttributes,
          checkbox: p.data.checkbox,
          pos: p.pos
        }) : B({
          tag: "list_item",
          children: p.children,
          attributes: p.attributes,
          autoAttributes: p.autoAttributes,
          pos: p.pos
        });
      },
      checkbox_checked: (v, k, S, g) => {
        F().data.checkbox = "checked";
      },
      checkbox_unchecked: (v, k, S, g) => {
        F().data.checkbox = "unchecked";
      },
      "+block_quote": (v, k, S, g) => {
        Z(g);
      },
      "-block_quote": (v, k, S, g) => {
        const p = H(g);
        B({
          tag: "block_quote",
          children: p.children,
          attributes: p.attributes,
          autoAttributes: p.autoAttributes,
          pos: p.pos
        });
      },
      "+table": (v, k, S, g) => {
        Z(g), F().data.aligns = [];
      },
      "-table": (v, k, S, g) => {
        var p;
        const M = H(g), L = M.children;
        let U = {
          tag: "caption",
          children: []
        };
        ((p = L[0]) === null || p === void 0 ? void 0 : p.tag) === "caption" && (U = L.shift()), B({
          tag: "table",
          children: [U, ...L],
          attributes: M.attributes,
          autoAttributes: M.autoAttributes,
          pos: M.pos
        });
      },
      "+row": (v, k, S, g) => {
        Z(g), F().data.aligns = [];
      },
      "-row": (v, k, S, g) => {
        const p = H(g);
        if (p.children.length === 0) {
          F().data.aligns = p.data.aligns;
          const M = ae();
          if (M && "tag" in M && M.tag === "row") {
            M.head = true;
            for (let L = 0; L < M.children.length; L++)
              M.children[L].head = true, M.children[L].align = p.data.aligns[L] || "default";
          }
        } else {
          p.data.aligns = [];
          for (let M = 0; M < p.children.length; M++)
            p.children[M].align = F().data.aligns[M] || "default";
          B({
            tag: "row",
            children: p.children,
            head: false,
            attributes: p.attributes,
            autoAttributes: p.autoAttributes,
            pos: p.pos
          });
        }
      },
      separator_default: (v, k, S, g) => {
        F().data.aligns.push("default");
      },
      separator_left: (v, k, S, g) => {
        F().data.aligns.push("left");
      },
      separator_right: (v, k, S, g) => {
        F().data.aligns.push("right");
      },
      separator_center: (v, k, S, g) => {
        F().data.aligns.push("center");
      },
      "+cell": (v, k, S, g) => {
        Z(g);
      },
      "-cell": (v, k, S, g) => {
        const p = H(g);
        B({
          tag: "cell",
          children: p.children,
          head: false,
          align: "default",
          attributes: p.attributes,
          autoAttributes: p.autoAttributes,
          pos: p.pos
        });
      },
      "+caption": (v, k, S, g) => {
        Z(g);
      },
      "-caption": (v, k, S, g) => {
        var p;
        const M = H(g), L = ae();
        if (!L || "tag" in L && L.tag !== "table")
          return;
        const U = {
          tag: "caption",
          children: M.children,
          attributes: M.attributes,
          autoAttributes: M.autoAttributes,
          pos: M.pos
        };
        ((p = L.children[0]) === null || p === void 0 ? void 0 : p.tag) === "caption" && (L.children[0] = U);
      },
      "+footnote": (v, k, S, g) => {
        Z(g);
      },
      "-footnote": (v, k, S, g) => {
        const p = H(g);
        if (p.data.label) {
          const M = A(p.data.label);
          Sn[M] = {
            tag: "footnote",
            label: M || "",
            children: p.children,
            attributes: p.attributes,
            autoAttributes: p.autoAttributes,
            pos: p.pos
          };
        } else
          Nn(new n.Warning("Ignoring footnote without a label.", $.sourcePositions ? K(S) : S));
      },
      note_label: (v, k, S, g) => {
        F().data.label = N.substring(k, S + 1);
      },
      "+code_block": (v, k, S, g) => {
        Z(g), X = b.Verbatim;
      },
      "-code_block": (v, k, S, g) => {
        const p = H(g);
        p.data.format ? B({
          tag: "raw_block",
          format: p.data.format,
          text: Y,
          attributes: p.attributes,
          autoAttributes: p.autoAttributes,
          pos: p.pos
        }) : B({
          tag: "code_block",
          text: Y,
          lang: p.data.lang,
          attributes: p.attributes,
          autoAttributes: p.autoAttributes,
          pos: p.pos
        }), X = b.Normal, Y = "";
      },
      code_language: (v, k, S, g) => {
        const p = F();
        p.data.lang = N.substring(k, S + 1);
      },
      "+div": (v, k, S, g) => {
        Z(g);
      },
      "-div": (v, k, S, g) => {
        const p = H(g);
        B({
          tag: "div",
          children: p.children,
          attributes: p.attributes,
          autoAttributes: p.autoAttributes,
          pos: p.pos
        });
      },
      thematic_break: (v, k, S, g) => {
        const p = { tag: "thematic_break", pos: g };
        Cn(p), B(p);
      },
      left_single_quote: (v, k, S, g) => {
        B({
          tag: "smart_punctuation",
          type: "left_single_quote",
          text: "'",
          pos: g
        });
      },
      right_single_quote: (v, k, S, g) => {
        B({
          tag: "smart_punctuation",
          type: "right_single_quote",
          text: "'",
          pos: g
        });
      },
      left_double_quote: (v, k, S, g) => {
        B({
          tag: "smart_punctuation",
          type: "left_double_quote",
          text: '"',
          pos: g
        });
      },
      right_double_quote: (v, k, S, g) => {
        B({
          tag: "smart_punctuation",
          type: "right_double_quote",
          text: '"',
          pos: g
        });
      },
      ellipses: (v, k, S, g) => {
        B({
          tag: "smart_punctuation",
          type: "ellipses",
          text: "...",
          pos: g
        });
      },
      en_dash: (v, k, S, g) => {
        B({
          tag: "smart_punctuation",
          type: "en_dash",
          text: "--",
          pos: g
        });
      },
      em_dash: (v, k, S, g) => {
        B({
          tag: "smart_punctuation",
          type: "em_dash",
          text: "---",
          pos: g
        });
      },
      // We set the blanklines property of a parent list or
      // sublist to aid with tight/loose list determination.
      blankline: (v, k, S, g) => {
        let p;
        "tight" in F().data ? p = F() : st.length >= 2 && "tight" in st[st.length - 2].data && (p = st[st.length - 2]), p && (p.data.blanklines = true);
      }
    }, ls = function(v, k) {
      let S, g, p;
      $.sourcePositions && (S = K(k.startpos), g = K(k.endpos), p = { start: S, end: g });
      let M = k.annot, L = [];
      if (k.annot.includes("|")) {
        const gt = k.annot.split("|");
        M = gt[0], L = gt.slice(1);
      }
      if (De > 0 && M !== "blankline") {
        let gt;
        const bt = F();
        bt && (bt.data && "tight" in bt.data ? gt = bt : v.length >= 2 && "tight" in v[v.length - 2].data && (gt = v[v.length - 2])), gt && (!/^[+-]list/.test(M) && gt.data.blanklines && (gt.data.tight = false), /^[-+]list_item$/.test(M) || (gt.data.blanklines = false));
      }
      const U = os[M];
      U && U(L, k.startpos, k.endpos, p);
    }, st = [{
      children: [],
      data: { headinglevel: 0 },
      pos: {
        start: { line: 0, col: 0, offset: 0 },
        end: { line: 0, col: 0, offset: 0 }
      }
    }];
    let Tn = 0;
    for (const v of is)
      ls(st, v), Tn = v.endpos;
    let oe;
    $.sourcePositions && (oe = K(Tn));
    let Dt = F();
    for (; Dt && Dt.data.headinglevel > 0; )
      H(oe && { start: oe, end: oe }), B({
        tag: "section",
        children: Dt.children,
        attributes: Dt.attributes,
        autoAttributes: Dt.autoAttributes,
        pos: Dt.pos
      }), Dt = F();
    const Pe = {
      tag: "doc",
      references: $e,
      autoReferences: Ie,
      footnotes: Sn,
      children: st[0].children
    };
    return st[0].autoAttributes && (Pe.autoAttributes = st[0].autoAttributes), st[0].attributes && (Pe.attributes = st[0].attributes), Pe;
  };
  t.parse = x;
  const T = {
    children: true,
    tag: true,
    pos: true,
    attributes: true,
    autoAttributes: true,
    references: true,
    autoReferences: true,
    footnotes: true
  }, D = function(N) {
    return JSON.stringify(N).replace(/\\\n/g, "\\n");
  }, j = function(N, $, R) {
    if ($.push(" ".repeat(R)), R > 128) {
      $.push(`(((DEEPLY NESTED CONTENT OMITTED)))
`);
      return;
    }
    $.push(N.tag), N.pos && $.push(` (${N.pos.start.line}:${N.pos.start.col}:${N.pos.start.offset}-${N.pos.end.line}:${N.pos.end.col}:${N.pos.end.offset})`);
    for (const K in N)
      if (!T[K]) {
        const X = N[K];
        X != null && $.push(` ${K}=${D(X)}`);
      }
    if (N.attributes)
      for (const K in N.attributes)
        $.push(` ${K}=${D(N.attributes[K])}`);
    if ($.push(`
`), N.children)
      for (const K of N.children)
        j(K, $, R + 2);
  }, nt = function(N) {
    const $ = [];
    if (j(N, $, 0), Object.keys(N.references).length > 0) {
      $.push(`references
`);
      for (const R in N.references)
        $.push(`  [${D(R)}] =
`), j(N.references[R], $, 4);
    }
    if (Object.keys(N.footnotes).length > 0) {
      $.push(`footnotes
`);
      for (const R in N.footnotes)
        $.push(`  [${D(R)}] =
`), j(N.footnotes[R], $, 4);
    }
    return $.join("");
  };
  t.renderAST = nt;
})(Te);
var Rt = {};
Object.defineProperty(Rt, "__esModule", { value: true });
Rt.HTMLRenderer = Rt.renderHTML = void 0;
var _r = Te;
var mo = It;
var fo = /[&<>]/;
var go = /[&<>"]/;
var ns = class {
  constructor(e) {
    this.smartPunctuationMap = {
      right_single_quote: "â€™",
      left_single_quote: "â€˜",
      right_double_quote: "â€",
      left_double_quote: "â€œ",
      ellipses: "â€¦",
      em_dash: "â€”",
      en_dash: "â€“"
    }, this.warn = e.warn || (() => {
    }), this.options = e || {}, this.tight = false, this.footnoteIndex = {}, this.nextFootnoteIndex = 1, this.references = {}, this.autoReferences = {};
  }
  escape(e) {
    return fo.test(e) ? e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;") : e;
  }
  escapeAttribute(e) {
    return go.test(e) ? e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;") : e;
  }
  renderAttributes(e, n) {
    let r = "";
    if (n)
      for (const a in n)
        if (a === "class") {
          let l = n[a];
          e.attributes && e.attributes.class && (l = `${l} ${e.attributes.class}`), r += ` ${a}="${this.escapeAttribute(l)}"`;
        } else
          r += ` ${a}="${this.escapeAttribute(n[a])}"`;
    const s = Object.assign(Object.assign({}, e.autoAttributes), e.attributes);
    if (s)
      for (const a in s) {
        const l = s[a];
        a === "class" && n && n.class || (r += ` ${a}="${this.escapeAttribute(l)}"`);
      }
    if (e.pos) {
      const a = e.pos.start, l = e.pos.end;
      r += ` data-startpos="${a.line}:${a.col}:${a.offset}" data-endpos="${l.line}:${l.col}:${l.offset}"`;
    }
    return r;
  }
  renderTag(e, n, r) {
    let s = "";
    return (n.attributes || n.autoAttributes || r || n.pos) && (s = this.renderAttributes(n, r)), `<${e}${s}>`;
  }
  renderCloseTag(e) {
    return `</${e}>`;
  }
  inTags(e, n, r, s) {
    const a = r >= 2 ? `
` : "", l = r >= 1 ? `
` : "";
    return `${this.renderTag(e, n, s)}${a}${this.renderChildren(n)}</${e}>${l}`;
  }
  addBacklink(e, n) {
    const r = `<a href="#fnref${n}" role="doc-backlink">â†©ï¸</a>`;
    return /\<\/p\>[\r\n]*$/.test(e) ? e.replace(/\<\/p\>([\r\n]*)$/, r + "</p>$1") : e + `<p>${r}</p>
`;
  }
  renderChildren(e) {
    let n = "";
    const r = this.tight;
    "tight" in e && (this.tight = !!e.tight);
    for (const s of e.children)
      n += this.renderAstNode(s);
    return "tight" in e && (this.tight = r), n;
  }
  renderAstNode(e) {
    var n;
    const r = (n = this.options.overrides) === null || n === void 0 ? void 0 : n[e.tag];
    return r ? r(e, this) : this.renderAstNodeDefault(e);
  }
  renderNotes(e) {
    let n = "";
    const r = [], s = {};
    for (const a in e)
      s[a] = this.renderChildren(e[a]);
    for (const a in this.footnoteIndex) {
      const l = this.footnoteIndex[a];
      l && (r[l] = s[a]);
    }
    n += `<section role="doc-endnotes">
<hr>
<ol>
`;
    for (let a = 1; a < r.length; a++) {
      const l = r[a] || "";
      n += `<li id="fn${a}">
`, n += this.addBacklink(l, a), n += `</li>
`;
    }
    return n += `</ol>
</section>
`, n;
  }
  renderAstNodeDefault(e) {
    var n;
    switch (e.tag) {
      case "doc": {
        let r = "";
        return r += this.renderChildren(e), this.nextFootnoteIndex > 1 && (r += this.renderNotes(e.footnotes)), r;
      }
      case "para":
        return this.tight ? `${this.renderChildren(e)}
` : this.inTags("p", e, 1);
      case "block_quote":
        return this.inTags("blockquote", e, 2);
      case "div":
        return this.inTags("div", e, 2);
      case "section":
        return this.inTags("section", e, 2);
      case "list_item":
        return this.inTags("li", e, 2);
      case "task_list_item":
        return this.inTags("li", e, 2, { class: e.checkbox === "checked" ? "checked" : "unchecked" });
      case "definition_list_item":
        return this.renderChildren(e);
      case "definition":
        return this.inTags("dd", e, 2);
      case "term":
        return this.inTags("dt", e, 1);
      case "definition_list":
        return this.inTags("dl", e, 2);
      case "bullet_list":
        return this.inTags("ul", e, 2);
      case "task_list":
        return this.inTags("ul", e, 2, { class: "task-list" });
      case "ordered_list": {
        const r = {};
        return e.start && e.start !== 1 && (r.start = e.start.toString()), e.style && !/1/.test(e.style) && (r.type = e.style.replace(/[().]/g, "")), this.inTags("ol", e, 2, r);
      }
      case "heading":
        return this.inTags(`h${e.level}`, e, 1);
      case "footnote_reference": {
        let r = "";
        const s = e.text;
        let a = this.footnoteIndex[s];
        return a || (a = this.nextFootnoteIndex, this.footnoteIndex[s] = a, this.nextFootnoteIndex++), r += this.renderTag("a", e, {
          id: "fnref" + a,
          href: "#fn" + a,
          role: "doc-noteref"
        }), r += "<sup>", r += this.escape(a.toString()), r += "</sup></a>", r;
      }
      case "table":
        return this.inTags("table", e, 2);
      case "caption": {
        let r = "";
        return e.children.length > 0 && (r += this.inTags("caption", e, 1)), r;
      }
      case "row":
        return this.inTags("tr", e, 2);
      case "cell": {
        const r = {};
        return e.align && e.align !== "default" && (r.style = `text-align: ${e.align};`), this.inTags(e.head ? "th" : "td", e, 1, r);
      }
      case "thematic_break": {
        let r = "";
        return r += this.renderTag("hr", e), r += `
`, r;
      }
      case "code_block": {
        let r = "";
        return r += this.renderTag("pre", e), r += "<code", e.lang && (r += ` class="language-${this.escapeAttribute(e.lang)}"`), r += ">", r += this.escape(e.text), r += this.renderCloseTag("code"), r += this.renderCloseTag("pre"), r += `
`, r;
      }
      case "raw_block": {
        let r = "";
        return e.format === "html" && (r += e.text), r;
      }
      case "str":
        return e.attributes || e.autoAttributes ? `${this.renderTag("span", e)}${this.escape(e.text)}</span>` : this.escape(e.text);
      case "smart_punctuation":
        return this.smartPunctuationMap[e.type] || e.text;
      case "double_quoted": {
        let r = "";
        return r += this.smartPunctuationMap.left_double_quote || '"', r += this.renderChildren(e), r += this.smartPunctuationMap.right_double_quote || '"', r;
      }
      case "single_quoted": {
        let r = "";
        return r += this.smartPunctuationMap.left_single_quote || "'", r += this.renderChildren(e), r += this.smartPunctuationMap.right_single_quote || "'", r;
      }
      case "symb":
        return this.escape(`:${e.alias}:`);
      case "inline_math": {
        let r = "";
        return r += this.renderTag("span", e, { class: "math inline" }), r += `\\(${this.escape(e.text)}\\)`, r += this.renderCloseTag("span"), r;
      }
      case "display_math": {
        let r = "";
        return r += this.renderTag("span", e, { class: "math display" }), r += `\\[${this.escape(e.text)}\\]`, r += this.renderCloseTag("span"), r;
      }
      case "verbatim": {
        let r = "";
        return r += this.renderTag("code", e), r += this.escape(e.text), r += this.renderCloseTag("code"), r;
      }
      case "raw_inline": {
        let r = "";
        return e.format === "html" && (r += e.text), r;
      }
      case "soft_break":
        return `
`;
      case "hard_break":
        return `<br>
`;
      case "non_breaking_space":
        return "&nbsp;";
      case "link":
      case "image": {
        const r = {};
        let s = e.destination;
        if (e.reference) {
          const a = this.references[e.reference] || this.autoReferences[e.reference];
          if (a) {
            if (s = a.destination, e.tag === "image" ? (r.alt = (0, _r.getStringContent)(e), r.src = s) : r.href = s, a.attributes)
              for (const l in a.attributes)
                (!e.attributes || !e.attributes[l]) && (r[l] = a.attributes[l]);
            if (a.autoAttributes)
              for (const l in a.autoAttributes)
                (!e.autoAttributes || !e.autoAttributes[l]) && (r[l] = a.autoAttributes[l]);
          } else
            this.warn(new mo.Warning(`Reference ${JSON.stringify(e.reference)} not found`, (n = e == null ? void 0 : e.pos) === null || n === void 0 ? void 0 : n.end));
        } else
          e.tag === "image" ? (r.alt = (0, _r.getStringContent)(e), s !== void 0 && (r.src = s)) : s !== void 0 && (r.href = s);
        return e.tag === "image" ? this.renderTag("img", e, r) : this.inTags("a", e, 0, r);
      }
      case "url":
      case "email": {
        let r = "";
        const s = {};
        return e.tag === "email" ? s.href = "mailto:" + e.text : s.href = e.text, r += this.renderTag("a", e, s), r += this.escape(e.text), r += this.renderCloseTag("a"), r;
      }
      case "strong":
        return this.inTags("strong", e, 0);
      case "emph":
        return this.inTags("em", e, 0);
      case "span":
        return this.inTags("span", e, 0);
      case "mark":
        return this.inTags("mark", e, 0);
      case "insert":
        return this.inTags("ins", e, 0);
      case "delete":
        return this.inTags("del", e, 0);
      case "superscript":
        return this.inTags("sup", e, 0);
      case "subscript":
        return this.inTags("sub", e, 0);
      default:
        return "";
    }
  }
  render(e) {
    return this.references = e.references, this.autoReferences = e.autoReferences, this.renderAstNode(e);
  }
};
Rt.HTMLRenderer = ns;
var bo = function(t, e = {}) {
  return new ns(e).render(t);
};
Rt.renderHTML = bo;
var Me = {};
Object.defineProperty(Me, "__esModule", { value: true });
Me.applyFilter = void 0;
var xo = class {
  constructor(e) {
    this.finished = false, this.stack = [], this.enter = true, this.top = e, this.current = e;
  }
  walk(e) {
    for (; !this.finished; ) {
      e(this);
      const n = this.stack && this.stack[this.stack.length - 1];
      if (this.enter)
        "children" in this.current && this.current.children.length > 0 ? (this.stack.push({ node: this.current, childIndex: 0 }), this.current = this.current.children[0], this.enter = true) : this.enter = false;
      else if (n) {
        n.childIndex++;
        const r = n.node.children[n.childIndex];
        r ? (this.current = r, this.enter = true) : (this.stack.pop(), this.current = n.node, this.enter = false);
      } else
        this.finished = true;
    }
  }
};
var yo = function(t, e, n) {
  if (!t || !t.tag)
    throw new Error("Filter called on a non-node.");
  const r = n[t.tag];
  if (!r)
    return false;
  let s;
  if (e ? "enter" in r && r.enter && (s = r.enter) : "exit" in r && r.exit ? s = r.exit : s = r, typeof s == "function")
    return s(t);
};
var Ye = function(t, e) {
  return new xo(t).walk((n) => {
    let r = yo(n.current, n.enter, e);
    const s = n.stack[n.stack.length - 1];
    if (typeof r == "object" && "stop" in r && r.stop && (r = r.stop, n.enter = false), r) {
      if (Array.isArray(r))
        if (s)
          s.node.children.splice(s.childIndex, 1, ...r), n.current = s.node.children[s.childIndex], r.length > 1 && (s.childIndex += r.length - 1);
        else
          throw Error("Cannot replace top node with multiple nodes");
      else if (typeof r == "object" && "tag" in r && r.tag)
        if (s)
          s.node.children[s.childIndex] = r;
        else
          return r;
    }
  }), t;
};
var wo = function(t, e) {
  const n = e();
  let r;
  Array.isArray(n) ? r = n : r = [n];
  for (const s of r) {
    Ye(t, s);
    for (const a in t.footnotes)
      Ye(t.footnotes[a], s);
    for (const a in t.references)
      Ye(t.references[a], s);
  }
};
Me.applyFilter = wo;
var Ut = {};
Object.defineProperty(Ut, "__esModule", { value: true });
Ut.fromPandoc = Ut.toPandoc = void 0;
var _e = It;
var ge = {
  Decimal: {
    Period: "1.",
    OneParen: "1)",
    TwoParens: "(1)"
  },
  LowerAlpha: {
    Period: "a.",
    OneParen: "a)",
    TwoParens: "(a)"
  },
  UpperAlpha: {
    Period: "A.",
    OneParen: "A)",
    TwoParens: "(A)"
  },
  LowerRoman: {
    Period: "i.",
    OneParen: "i)",
    TwoParens: "(i)"
  },
  UpperRoman: {
    Period: "I.",
    OneParen: "I)",
    TwoParens: "(I)"
  }
};
var rs = {};
for (const t in ge)
  for (const e in ge[t])
    rs[ge[t][e]] = [t, e];
var vo = function(t) {
  return t.t === "Para" && (t.t = "Plain"), t;
};
var vt = function(t) {
  const e = Object.assign(Object.assign({}, t.autoAttributes), t.attributes);
  if (e) {
    const n = e.id || "", r = e.class && e.class.split(" ") || [], s = [];
    for (const a in e)
      a !== n && a !== "class" && s.push([a, e[a]]);
    return [n, r, s];
  } else
    return ["", [], []];
};
var ko = class {
  constructor(e = {}) {
    this.references = {}, this.footnotes = {}, this.options = e, this.smartPunctuationMap = this.options.smartPunctuationMap || {
      right_single_quote: "â€™",
      left_single_quote: "â€˜",
      right_double_quote: "â€",
      left_double_quote: "â€œ",
      ellipses: "â€¦",
      em_dash: "â€”",
      en_dash: "â€“"
    }, this.warn || (this.warn = () => {
    });
  }
  toPandocChildren(e) {
    if ("children" in e) {
      const n = [];
      return e.children.forEach((r) => {
        this.addToPandocElts(n, r);
      }), n;
    } else
      return [];
  }
  toPandocDefinitionListItem(e) {
    const n = this;
    return function(r) {
      if (!("children" in r))
        return [];
      const [s, a] = r.children;
      return [
        n.toPandocChildren(s),
        [n.toPandocChildren(a)]
      ];
    };
  }
  toPandocListItem(e) {
    const n = this;
    return function(r) {
      let s = n.toPandocChildren(r);
      return "checkbox" in r && r.checkbox && s[0].t === "Para" && (r.checkbox === "checked" ? s[0].c.unshift({ t: "Str", c: "â˜’" }, { t: "Space" }) : s[0].c.unshift({ t: "Str", c: "â˜" }, { t: "Space" })), "tight" in e && e.tight && (s = s.map(vo)), s;
    };
  }
  addToPandocElts(e, n) {
    switch (n.tag) {
      case "section":
      case "div": {
        const r = vt(n);
        n.tag === "section" && r[1].unshift("section"), e.push({ t: "Div", c: [r, this.toPandocChildren(n)] });
        break;
      }
      case "block_quote":
        e.push({ t: "BlockQuote", c: this.toPandocChildren(n) });
        break;
      case "definition_list": {
        const r = n.children.map(this.toPandocDefinitionListItem(n));
        e.push({ t: "DefinitionList", c: r });
        break;
      }
      case "task_list":
      case "bullet_list": {
        let r;
        r = n.children.map(this.toPandocListItem(n)), e.push({ t: "BulletList", c: r });
        break;
      }
      case "ordered_list": {
        const r = n.children.map(this.toPandocListItem(n)), [s, a] = rs[n.style], l = n.start || 1;
        e.push({ t: "OrderedList", c: [
          [l, { t: s }, { t: a }],
          r
        ] });
        break;
      }
      case "task_list_item":
      case "list_item":
        break;
      case "para":
        e.push({ t: "Para", c: this.toPandocChildren(n) });
        break;
      case "heading":
        e.push({ t: "Header", c: [
          n.level,
          vt(n),
          this.toPandocChildren(n)
        ] });
        break;
      case "code_block": {
        const r = vt(n);
        n.lang && r[1].unshift(n.lang), e.push({ t: "CodeBlock", c: [r, n.text] });
        break;
      }
      case "raw_block":
        e.push({ t: "RawBlock", c: [n.format, n.text] });
        break;
      case "thematic_break":
        e.push({ t: "HorizontalRule" });
        break;
      case "table": {
        const r = vt(n), s = ["", [], []];
        let a = [], l = [], u = [];
        const c = [], m = [s, []];
        let b = [], A = [];
        const x = {
          left: "AlignLeft",
          right: "AlignRight",
          center: "AlignCenter",
          default: "AlignDefault"
        }, T = function(N) {
          return [
            { t: x[N.align] || "AlignDefault" },
            { t: "ColWidthDefault" }
          ];
        }, D = this, j = function(N) {
          if ("children" in N)
            return [
              vt(N),
              { t: "align" in N && x[N.align] || "AlignDefault" },
              1,
              1,
              [{ t: "Plain", c: D.toPandocChildren(N) }]
            ];
        }, nt = function(N) {
          if ("children" in N)
            return [vt(N), N.children.map(j)];
        };
        for (let N = 0; N < n.children.length; N++) {
          const $ = n.children[N];
          if (!("children" in $))
            break;
          l.length === 0 && (l = $.children.map(T)), $.tag === "caption" ? $.children.length && (a = this.toPandocChildren($)) : $.head ? A.length === 0 ? b.push(nt($)) : (c.push([s, 0, b, A]), A = [], b = [nt($)]) : (c.length === 0 && A.length === 0 && (u = b, b = []), A.push(nt($)));
        }
        (b.length > 0 || A.length > 0) && c.push([s, 0, b, A]), e.push({ t: "Table", c: [
          r,
          [null, [{
            t: "Plain",
            c: a
          }]],
          l,
          [s, u],
          c,
          m
        ] });
        break;
      }
      case "raw_inline":
        e.push({ t: "RawInline", c: [n.format, n.text] });
        break;
      case "soft_break":
        e.push({ t: "SoftBreak" });
        break;
      case "hard_break":
        e.push({ t: "LineBreak" });
        break;
      case "str":
        n.text.split(/ +/).forEach((r, s) => {
          s > 0 && e.push({ t: "Space" }), r.length > 0 && e.push({ t: "Str", c: r });
        });
        break;
      case "verbatim":
        e.push({ t: "Code", c: [vt(n), n.text] });
        break;
      case "inline_math":
        e.push({
          t: "Math",
          c: [{ t: "InlineMath" }, n.text]
        });
        break;
      case "display_math":
        e.push({
          t: "Math",
          c: [{ t: "DisplayMath" }, n.text]
        });
        break;
      case "non_breaking_space":
        e.push({ t: "Str", c: "Â " });
        break;
      case "smart_punctuation":
        e.push({ t: "Str", c: this.smartPunctuationMap[n.type] || n.text });
        break;
      case "symb":
        e.push({ t: "Span", c: [
          ["", ["symbol"], [["alias", n.alias]]],
          [{ t: "Str", c: ":" + n.alias + ":" }]
        ] });
        break;
      case "single_quoted":
      case "double_quoted": {
        const r = { t: n.tag === "single_quoted" ? "SingleQuote" : "DoubleQuote" };
        e.push({ t: "Quoted", c: [r, this.toPandocChildren(n)] });
        break;
      }
      case "email":
      case "url": {
        let r = n.text;
        n.tag === "email" && (r = "mailto:" + r);
        const s = vt(n);
        s[1].unshift(n.tag === "email" ? "email" : "uri"), e.push({
          t: "Link",
          c: [
            s,
            [{ t: "Str", c: n.text }],
            [r, ""]
          ]
        });
        break;
      }
      case "image":
      case "link": {
        let r = n.destination || "";
        const s = {};
        if (n.reference) {
          const m = this.references[n.reference];
          if (m) {
            r = m.destination || "";
            const b = Object.assign(Object.assign({}, m.autoAttributes), m.attributes);
            if (b)
              for (const A in b)
                s[A] = b[A];
          } else
            this.warn(new _e.Warning("Reference " + n.reference + " not found."));
        }
        const a = Object.assign(Object.assign({}, n.autoAttributes), n.attributes);
        if (a)
          for (const m in a)
            s[m] && m === "class" ? s[m] += " " + a[m] : s[m] || (s[m] = a[m]);
        const l = vt({
          tag: "link",
          attributes: s,
          children: []
        }), u = r || "", c = n.attributes && n.attributes.title || n.autoAttributes && n.autoAttributes.title || "";
        c && (l[2] = l[2].filter(([m, b]) => m !== "title")), e.push({
          t: n.tag === "link" ? "Link" : "Image",
          c: [l, this.toPandocChildren(n), [u, c]]
        });
        break;
      }
      case "emph":
        e.push({ t: "Emph", c: this.toPandocChildren(n) });
        break;
      case "strong":
        e.push({ t: "Strong", c: this.toPandocChildren(n) });
        break;
      case "superscript":
        e.push({ t: "Superscript", c: this.toPandocChildren(n) });
        break;
      case "subscript":
        e.push({ t: "Subscript", c: this.toPandocChildren(n) });
        break;
      case "span":
        e.push({ t: "Span", c: [
          vt(n),
          this.toPandocChildren(n)
        ] });
        break;
      case "mark":
        e.push({ t: "Span", c: [["", ["mark"], []], this.toPandocChildren(n)] });
        break;
      case "insert":
        e.push({ t: "Underline", c: this.toPandocChildren(n) });
        break;
      case "delete":
        e.push({ t: "Strikeout", c: this.toPandocChildren(n) });
        break;
      case "footnote_reference": {
        const r = this.footnotes[n.text];
        r ? e.push({ t: "Note", c: this.toPandocChildren(r) }) : e.push({ t: "Superscript", c: [{ t: "Str", c: n.text }] });
        break;
      }
      default:
        this.warn(new _e.Warning("Skipping unhandled node " + n.tag));
    }
  }
  toPandoc(e) {
    return this.references = e.references, this.footnotes = e.footnotes, {
      "pandoc-api-version": [1, 23],
      meta: {},
      blocks: this.toPandocChildren(e)
    };
  }
};
var kt = function(t) {
  const e = {};
  t[0] && (e.id = t[0]), t[1].length > 0 && (e.class = t[1].join(" "));
  for (let n = 0; n < t[2].length; n++)
    e[t[2][n][0].toString()] = t[2][n][1];
  return Object.keys(e).length === 0 ? null : e;
};
var on = function(t) {
  return t.t === "Plain" || t.t === "Para";
};
var _o = function(t) {
  if (!t[0])
    return null;
  const e = t[0];
  return on(e) && e.c.length >= 2 && e.c[0].t === "Str" && e.c[1].t === "Space" ? e.c[0].c === "â˜’" ? (e.c.shift(), e.c.shift(), "checked") : e.c[0].c === "â˜" ? (e.c.shift(), e.c.shift(), "unchecked") : null : null;
};
var Ao = class {
  constructor(e = {}) {
    this.footnotes = {}, this.footnoteIndex = 0, this.options = e, this.warn = e.warn || (() => {
    });
  }
  fromPandocInlines(e) {
    let n = [];
    const r = [];
    for (let s = 0; s < e.length; s++) {
      const a = e[s];
      if (a.t === "Str")
        n.push(a.c);
      else if (a.t === "Space")
        n.push(" ");
      else
        switch (n.length > 0 && (r.push({ tag: "str", text: n.join("") }), n = []), a.t) {
          case "SoftBreak":
            r.push({ tag: "soft_break" });
            break;
          case "LineBreak":
            r.push({ tag: "hard_break" });
            break;
          case "Emph":
            r.push({ tag: "emph", children: this.fromPandocInlines(a.c) });
            break;
          case "Strong":
            r.push({ tag: "strong", children: this.fromPandocInlines(a.c) });
            break;
          case "Superscript":
            r.push({ tag: "superscript", children: this.fromPandocInlines(a.c) });
            break;
          case "Subscript":
            r.push({ tag: "subscript", children: this.fromPandocInlines(a.c) });
            break;
          case "Strikeout":
            r.push({ tag: "delete", children: this.fromPandocInlines(a.c) });
            break;
          case "Span": {
            const l = {
              tag: "span",
              children: this.fromPandocInlines(a.c[1])
            }, u = kt(a.c[0]);
            u && (l.attributes = u), r.push(l);
            break;
          }
          case "Underline":
            r.push({
              tag: "span",
              attributes: { class: "underline" },
              children: this.fromPandocInlines(a.c)
            });
            break;
          case "SmallCaps":
            r.push({
              tag: "span",
              attributes: { class: "smallcaps" },
              children: this.fromPandocInlines(a.c)
            });
            break;
          case "Math":
            r.push({
              tag: a.c[0].t === "DisplayMath" ? "display_math" : "inline_math",
              text: a.c[1]
            });
            break;
          case "Quoted":
            a.c[0].t === "SingleQuote" ? r.push({
              tag: "single_quoted",
              children: this.fromPandocInlines(a.c[1])
            }) : r.push({
              tag: "double_quoted",
              children: this.fromPandocInlines(a.c[1])
            });
            break;
          case "RawInline":
            r.push({ tag: "raw_inline", format: a.c[0], text: a.c[1] });
            break;
          case "Code": {
            const l = kt(a.c[0]), u = {
              tag: "verbatim",
              text: a.c[1]
            };
            l && (u.attributes = l), r.push(u);
            break;
          }
          case "Image":
          case "Link": {
            let l = kt(a.c[0]);
            a.c[2][1] && (l = l || {}, l.title = a.c[2][1]);
            const u = a.c[2][0], c = this.fromPandocInlines(a.c[1]);
            if (a.t === "Image") {
              const m = {
                tag: "image",
                destination: u,
                children: c
              };
              l && (m.attributes = l), r.push(m);
            } else {
              const m = {
                tag: "link",
                destination: u,
                children: c
              };
              l && (m.attributes = l), r.push(m);
            }
            break;
          }
          case "Cite":
            r.push({
              tag: "span",
              attributes: { class: "cite" },
              children: this.fromPandocInlines(a.c[1])
            });
            break;
          case "Note": {
            this.footnoteIndex++;
            const l = this.footnoteIndex.toString(), u = a.c.map((c) => this.fromPandocBlock(c));
            this.footnotes[this.footnoteIndex.toString()] = { tag: "footnote", label: l, children: u }, r.push({
              tag: "footnote_reference",
              text: l
            });
            break;
          }
        }
    }
    return n.length > 0 && r.push({ tag: "str", text: n.join("") }), r;
  }
  fromPandocBlock(e) {
    switch (e.t) {
      case "Plain":
      case "Para":
        return { tag: "para", children: this.fromPandocInlines(e.c) };
      case "BlockQuote":
        return {
          tag: "block_quote",
          children: e.c.map((n) => this.fromPandocBlock(n))
        };
      case "Div": {
        let n = kt(e.c[0]);
        const r = /\bsection\b/.test(n && n.class || "") ? "section" : "div", s = e.c[1].map((a) => this.fromPandocBlock(a));
        if (r === "section")
          return n = n || {}, n.class = n.class.replace(/section */, ""), n.class || delete n.class, { tag: "section", attributes: n, children: s };
        {
          const a = { tag: "div", children: s };
          return n && (a.attributes = n), a;
        }
      }
      case "Header": {
        const n = kt(e.c[1]), r = {
          tag: "heading",
          level: e.c[0],
          children: this.fromPandocInlines(e.c[2])
        };
        return n && (r.attributes = n), r;
      }
      case "HorizontalRule":
        return { tag: "thematic_break" };
      case "RawBlock":
        return { tag: "raw_block", format: e.c[0], text: e.c[1] };
      case "CodeBlock": {
        const n = kt(e.c[0]);
        let r;
        if (n && n.class) {
          const a = n.class.split(/  */);
          r = a[0], a.shift(), a.length > 0 ? n.class = a.join(" ") : delete n.class;
        }
        const s = {
          tag: "code_block",
          lang: r,
          text: e.c[1]
        };
        return n && (s.attributes = n), r || delete s.lang, s;
      }
      case "DefinitionList": {
        const n = [];
        for (let r = 0; r < e.c.length; r++) {
          const s = e.c[r][0], a = e.c[r][1], l = this.fromPandocInlines(s), u = [];
          for (let c = 0; c < a.length; c++)
            a[c].map((m) => {
              u.push(this.fromPandocBlock(m));
            });
          n.push({
            tag: "definition_list_item",
            children: [
              { tag: "term", children: l },
              { tag: "definition", children: u }
            ]
          });
        }
        return { tag: "definition_list", children: n };
      }
      case "OrderedList":
      case "BulletList": {
        const n = [], r = [];
        let s = false, a;
        e.t === "BulletList" ? a = e.c : a = e.c[1];
        for (let l = 0; l < a.length; l++) {
          const u = _o(a[l]), c = a[l].map((m) => (m.t === "Plain" ? s = true : m.t === "Para" && (s = false), this.fromPandocBlock(m)));
          u !== null ? r.push({
            tag: "task_list_item",
            checkbox: u,
            children: c
          }) : n.push({
            tag: "list_item",
            children: c
          });
        }
        if (e.t === "BulletList")
          return r.length > 0 ? {
            tag: "task_list",
            tight: s,
            children: r
          } : {
            tag: "bullet_list",
            style: "-",
            tight: s,
            children: n
          };
        if (e.t === "OrderedList") {
          const l = e.c[0][0];
          let u = e.c[0][1].t;
          u === "DefaultStyle" && (u = "Decimal");
          let c = e.c[0][2].t;
          return c === "DefaultDelim" && (c = "Period"), {
            tag: "ordered_list",
            style: ge[u][c],
            start: l,
            tight: s,
            children: n
          };
        }
      }
      case "Table": {
        const n = kt(e.c[0]), r = e.c[1][1], s = { tag: "caption", children: [] };
        r.length > 1 || r.length === 1 && !on(r[0]) ? this.warn(new _e.Warning("Skipping block-level content in table caption.")) : r[0] && "c" in r[0] && (s.children = this.fromPandocInlines(r[0].c));
        const a = e.c[2], l = [];
        for (const x in a)
          l.push(a[x][0].t.slice(5).toLowerCase());
        const u = [], c = e.c[3][1];
        for (const x in c)
          u.push(this.fromPandocRow(c[x], true, 0, l));
        const m = e.c[4];
        for (const x in m) {
          const T = m[x][1], D = m[x][2];
          for (const nt in D)
            u.push(this.fromPandocRow(D[nt], true, T, l));
          const j = m[x][3];
          for (const nt in j)
            u.push(this.fromPandocRow(j[nt], false, T, l));
        }
        const b = e.c[5][1];
        for (const x in b)
          u.push(this.fromPandocRow(b[x], false, 0, l));
        const A = { tag: "table", children: [s, ...u] };
        return n && (A.attributes = n), A;
      }
      case "Figure": {
        const n = kt(e.c[0]);
        /\bsection\b/.test(n && n.class || "");
        const r = e.c[2].map((l) => this.fromPandocBlock(l)), s = e.c[1][1];
        if (s.length > 0) {
          const l = s.map((u) => this.fromPandocBlock(u));
          r.push(...l);
        }
        const a = { tag: "div", children: r };
        return n && (a.attributes = n), a;
      }
      case "LineBlock": {
        const n = [];
        for (let r = 0; r < e.c.length; r++)
          r > 0 && n.push({ tag: "hard_break" }), n.push(...this.fromPandocInlines(e.c[r]));
        return { tag: "para", children: n };
      }
      case "Null":
        return { tag: "raw_block", format: "none", text: "" };
    }
    return {
      tag: "raw_block",
      format: "error",
      text: "Could not convert " + e.t
    };
  }
  fromPandocRow(e, n, r, s) {
    const a = kt(e[0]), l = e[1], u = [];
    for (let m = 0; m < l.length; m++)
      u.push(this.fromPandocCell(l[m], n || m < r, s[m]));
    const c = { tag: "row", head: n, children: u };
    return a && (c.attributes = a), c;
  }
  fromPandocCell(e, n, r) {
    let s = [];
    const a = kt(e[0]);
    let l = e[1].t.slice(5).toLowerCase();
    l === "default" && (l = r);
    const u = e[4];
    u.length > 1 || u.length === 1 && !on(u[0]) ? (this.warn(new _e.Warning("Skipping table cell with block-level content.")), s = [{ tag: "str", text: "((content omitted))" }]) : u[0] && (s = this.fromPandocInlines(u[0].c));
    const c = { tag: "cell", head: n, align: l, children: s };
    return a && (c.attributes = a), c;
  }
  fromPandoc(e) {
    if (typeof e != "object")
      throw Error("Pandoc document must be an object");
    if (e["pandoc-api-version"])
      if (e.blocks) {
        if (!e.meta)
          throw Error("Pandoc document lacks meta");
      } else throw Error("Pandoc document lacks blocks");
    else throw Error("Pandoc document lacks pandoc-api-version");
    return {
      tag: "doc",
      children: e.blocks.map((s) => this.fromPandocBlock(s)),
      footnotes: this.footnotes,
      references: {},
      autoReferences: {}
    };
  }
};
var So = function(t, e) {
  return new ko(e).toPandoc(t);
};
Ut.toPandoc = So;
var No = function(t, e) {
  return new Ao(e).fromPandoc(t);
};
Ut.fromPandoc = No;
var Oe = {};
Object.defineProperty(Oe, "__esModule", { value: true });
Oe.renderDjot = void 0;
var Bt = xt;
var Ar = Te;
var ss = function(t) {
  const e = t.tag;
  return e === "space" || e === "soft_break" || e === "hard_break";
};
var Co = function(t) {
  return t.children[0] && ss(t.children[0]);
};
var To = function(t) {
  return t.children[0] && ss(t.children[t.children.length - 1]);
};
var Ke = function(t, e) {
  const n = t.text.match(/(`+)/g), r = {};
  if (n)
    for (const a in n)
      r[n[a].length] = true;
  let s = e;
  for (; r[s]; )
    s++;
  return "`".repeat(s);
};
var Sr = function(t) {
  if (t < 0 || t >= 4e3)
    return "?";
  let e = "";
  for (; t > 0; )
    if (t >= 1e3)
      e += "M", t -= 1e3;
    else if (t >= 900)
      e += "CM", t -= 900;
    else if (t >= 500)
      e += "D", t -= 500;
    else if (t >= 400)
      e += "CD", t -= 400;
    else if (t >= 100)
      e += "C", t -= 100;
    else if (t >= 90)
      e += "XC", t -= 90;
    else if (t >= 50)
      e += "L", t -= 50;
    else if (t >= 40)
      e += "XL", t -= 40;
    else if (t >= 10)
      e += "X", t -= 10;
    else if (t == 9)
      e += "IX", t -= 9;
    else if (t >= 5)
      e += "V", t -= 5;
    else if (t == 4)
      e += "IV", t -= 4;
    else if (t >= 1)
      e += "I", t -= 1;
    else
      throw new Error("toRoman encountered x = " + t);
  return e;
};
var qo = function(t, e) {
  const n = e.replace(/[a-zA-Z0-9]+/g, "$"), r = e.replace(/[.()]/g, "");
  let s;
  switch (r) {
    case "1":
      s = t.toString();
      break;
    case "a":
      s = String.fromCodePoint(96 + t % 26);
      break;
    case "A":
      s = String.fromCodePoint(64 + t % 26);
      break;
    case "i":
      s = Sr(t).toLowerCase();
      break;
    case "I":
      s = Sr(t);
      break;
    default:
      throw new Error("formatNumber encountered unknown style " + e);
  }
  return n.replace("$", s);
};
var Mo = class {
  constructor(e, n = {}) {
    this.prefixes = [], this.buffer = [], this.startOfLine = true, this.endOfPrefix = 0, this.column = 0, this.needsBlankLine = false, this.handlers = {
      doc: (r) => {
        this.renderChildren(r.children), this.prefixes = [], this.cr(), Object.keys(r.references).length > 0 && (this.cr(), this.newline());
        for (const a in r.references)
          this.renderNode(r.references[a]);
        Object.keys(r.footnotes).length > 0;
        for (const a in r.footnotes)
          this.renderNode(r.footnotes[a]);
        this.prefixes = [], this.cr();
      },
      footnote: (r) => {
        this.lit("[^" + r.label + "]:"), this.space(), this.needsBlankLine = false, this.prefixes.push("  "), this.renderChildren(r.children), this.prefixes.pop(), this.blankline();
      },
      reference: (r) => {
        this.lit("["), this.lit(r.label), this.lit("]:"), this.prefixes.push("  "), this.space(), this.lit(r.destination), this.wrap(), this.prefixes.pop(), this.blankline();
      },
      para: (r) => {
        this.renderChildren(r.children), this.blankline();
      },
      thematic_break: () => {
        this.lit("* * * * *"), this.blankline();
      },
      div: (r) => {
        this.lit(":::"), this.cr(), this.renderChildren(r.children), this.cr(), this.lit(":::"), this.blankline();
      },
      heading: (r) => {
        const s = "#".repeat(r.level);
        this.lit(s + " "), this.prefixes.push(s + " "), this.renderChildren(r.children), this.prefixes.pop(), this.blankline();
      },
      block_quote: (r) => {
        this.prefixes.push("> "), this.lit("> "), this.renderChildren(r.children), this.prefixes.pop(), this.blankline();
      },
      section: (r) => {
        this.renderChildren(r.children);
      },
      code_block: (r) => {
        const s = Ke(r, 3);
        this.lit(s), r.lang && this.lit(" " + r.lang), this.cr(), this.litlines(r.text), this.cr(), this.lit(s), this.blankline();
      },
      raw_block: (r) => {
        const s = Ke(r, 3);
        this.lit(s), this.lit(" =" + r.format), this.cr(), this.litlines(r.text), this.cr(), this.lit(s), this.blankline();
      },
      definition_list: (r) => {
        const s = r.children;
        for (let a = 0; a < s.length; a++) {
          const l = s[a];
          a > 0 && this.newline(), this.lit(":"), this.needsBlankLine = false, this.space(), this.prefixes.push(" ".repeat(2)), this.renderChildren(l.children), this.prefixes.pop();
        }
      },
      ordered_list: (r) => {
        const s = r.style, a = r.start || 1, l = r.children, u = r.tight;
        for (let c = 0; c < l.length; c++) {
          const m = l[c];
          c > 0 && (this.cr(), u || this.newline());
          const b = qo(a + c, s);
          this.lit(b), this.needsBlankLine = false, this.space(), this.prefixes.push(" ".repeat(b.length + 1)), this.renderChildren(m.children), this.prefixes.pop();
        }
        u && this.blankline();
      },
      bullet_list: (r) => {
        const s = r.children, a = r.tight;
        for (let l = 0; l < s.length; l++) {
          const u = s[l];
          l > 0 && (this.cr(), a || this.newline());
          const c = r.style;
          this.lit(c), this.needsBlankLine = false, this.space(), this.prefixes.push(" ".repeat(c.length + 1)), this.renderChildren(u.children), this.prefixes.pop();
        }
        a && this.blankline();
      },
      task_list: (r) => {
        const s = r.children, a = r.tight;
        for (let l = 0; l < s.length; l++) {
          const u = s[l];
          l > 0 && (this.cr(), a || this.newline()), this.needsBlankLine = false, this.lit(`- [${u.checkbox === "checked" ? "X" : " "}]`), this.space(), this.prefixes.push(" ".repeat(6)), this.renderChildren(u.children), this.prefixes.pop();
        }
        a && this.blankline();
      },
      term: (r) => {
        this.renderChildren(r.children), this.blankline();
      },
      definition: (r) => {
        this.renderChildren(r.children);
      },
      table: (r) => {
        const s = r.children.filter(Bt.isCaption), a = r.children.filter(Bt.isRow);
        for (let l = 0; l < a.length; l++) {
          const u = a[l];
          if ("head" in u && !u.head && l > 0 && a[l - 1].head) {
            const c = a[l - 1];
            for (let m = 0; m < c.children.length; m++) {
              switch (m === 0 && this.lit("|"), c && c.children[m].align) {
                case "left":
                  this.lit(":--");
                  break;
                case "right":
                  this.lit("--:");
                  break;
                case "center":
                  this.lit(":-:");
                  break;
                default:
                  this.lit("---");
              }
              this.lit("|");
            }
            this.cr();
          }
          for (let c = 0; c < u.children.length; c++) {
            const m = u.children[c];
            c === 0 && this.lit("|"), this.noWrap(() => {
              m.tag === "cell" && this.renderChildren(m.children);
            }), this.lit("|");
          }
          this.cr();
        }
        s.length > 0 && s[0].children.length > 0 && (this.newline(), this.lit("^ "), this.needsBlankLine = false, this.prefixes.push("  "), this.renderChildren(s[0].children), this.prefixes.pop(), this.blankline()), this.blankline();
      },
      str: (r) => {
        r.text.split(/  */).forEach((s, a) => {
          a > 0 && this.space(), this.out(s);
        });
      },
      space: () => {
        this.space();
      },
      soft_break: () => {
        this.soft_break();
      },
      smart_punctuation: (r) => {
        this.lit(r.text);
      },
      non_breaking_space: () => {
        this.lit("\\ ");
      },
      single_quoted: this.inlineContainer("'"),
      double_quoted: this.inlineContainer('"'),
      emph: this.inlineContainer("_"),
      strong: this.inlineContainer("*"),
      superscript: this.inlineContainer("^"),
      subscript: this.inlineContainer("~"),
      mark: this.inlineContainer("=", true),
      delete: this.inlineContainer("-", true),
      insert: this.inlineContainer("+", true),
      footnote_reference: (r) => {
        this.lit("[^" + r.text + "]");
      },
      symb: (r) => {
        this.lit(":" + r.alias + ":");
      },
      email: (r) => {
        this.lit("<" + r.text + ">");
      },
      url: (r) => {
        this.lit("<" + r.text + ">");
      },
      span: (r) => {
        this.lit("["), this.renderChildren(r.children), this.lit("]");
      },
      link: (r) => {
        this.lit("["), this.renderChildren(r.children), this.lit("]"), r.reference ? (this.lit("["), r.reference !== (0, Ar.getStringContent)(r) && this.lit(r.reference), this.lit("]")) : r.destination ? (this.lit("("), this.lit(r.destination), this.lit(")")) : this.lit("()");
      },
      image: (r) => {
        this.lit("!["), this.renderChildren(r.children), this.lit("]"), r.reference ? (this.lit("["), r.reference !== (0, Ar.getStringContent)(r) && this.lit(r.reference), this.lit("]")) : r.destination ? (this.lit("("), this.lit(r.destination), this.lit(")")) : this.lit("()");
      },
      raw_inline: (r) => {
        this.verbatimNode(r), this.lit("{=" + r.format + "}");
      },
      verbatim: (r) => {
        this.verbatimNode(r);
      },
      inline_math: (r) => {
        this.lit("$"), this.verbatimNode(r);
      },
      display_math: (r) => {
        this.lit("$$"), this.verbatimNode(r);
      }
    }, this.doc = e, this.wrapWidth = (n == null ? void 0 : n.wrapWidth) || 0;
  }
  escape(e) {
    return e = e.replace(/([~`'"${}[\]^<>\\*_]|-(?=-)|!(=\[)|\.(?=\.))/g, "\\$1"), (this.column === 0 || this.column === this.endOfPrefix) && (e = e.replace(/^#/, "\\#")), e;
  }
  out(e) {
    this.lit(this.escape(e));
  }
  doBlankLines() {
    this.needsBlankLine && (this.cr(), this.newline(), this.needsBlankLine = false);
  }
  lit(e) {
    this.buffer.push(e), this.column += e.length, this.startOfLine = false;
  }
  blankline() {
    this.needsBlankLine = true;
  }
  newline() {
    if (this.endOfPrefix === this.column)
      for (; /  *$|^$/.test(this.buffer[this.buffer.length - 1]); )
        this.buffer[this.buffer.length - 1] = this.buffer[this.buffer.length - 1].replace(/  *$/, ""), this.buffer[this.buffer.length - 1] === "" && this.buffer.pop();
    if (this.endOfPrefix = 0, this.column = 0, this.buffer.push(`
`), this.prefixes.length > 0) {
      for (let e = 0, n = this.prefixes.length; e < n; e++)
        this.buffer.push(this.prefixes[e]), this.column += this.prefixes[e].length;
      this.endOfPrefix = this.column;
    }
    this.startOfLine = true;
  }
  cr() {
    this.startOfLine || this.newline();
  }
  wrap() {
    if (this.wrapWidth <= 0)
      return;
    let e = this.buffer.length - 1;
    if (!this.startOfLine && this.buffer.length > 0 && this.column > this.wrapWidth) {
      let n;
      for (; e >= 0 && (n = this.buffer[e], n !== " "); ) {
        if (/^[ \r\n]+$/.test(n))
          return;
        e--;
      }
    }
    if (e < this.buffer.length - 1) {
      const n = this.buffer.splice(e + 1);
      this.buffer[this.buffer.length - 1] === " " && this.buffer.pop(), this.newline(), this.startOfLine = true;
      for (let r = 0; r < n.length; r++)
        this.buffer.push(n[r]), this.column += n[r].length, this.startOfLine = false;
    }
  }
  space() {
    this.wrap(), this.lit(" ");
  }
  soft_break() {
    this.wrapWidth === 0 ? this.newline() : this.space();
  }
  needsBraces(e) {
    return Co(e) || To(e) || this.buffer.length > 0 && /\w$/.test(this.buffer[this.buffer.length - 1]);
  }
  noWrap(e) {
    const n = this.wrapWidth;
    this.wrapWidth = -1, e(), this.wrapWidth = n;
  }
  inlineContainer(e, n) {
    const r = this;
    return function(s) {
      n = n || r.needsBraces(s), n && r.lit("{"), r.lit(e), r.renderChildren(s.children), r.lit(e), n && r.lit("}");
    };
  }
  litlines(e) {
    const n = e.split(/\r?\n/);
    n[n.length - 1] === "" && n.pop();
    for (const r of n)
      this.lit(r), this.cr();
  }
  verbatimNode(e) {
    const n = Ke(e, 1);
    this.lit(n), /^`/.test(e.text) && this.lit(" "), this.lit(e.text), /`$/.test(e.text) && this.lit(" "), this.lit(n);
  }
  renderChildren(e) {
    for (let n = 0, r = e.length; n < r; n++)
      this.renderNode(e[n]);
    e[0] && !(0, Bt.isBlock)(e[0]) && this.wrap();
  }
  renderNode(e) {
    this.doBlankLines();
    const n = this.handlers[e.tag];
    if (n)
      e.attributes && (0, Bt.isBlock)(e) && (this.renderAttributes(e), this.cr()), n(e), e.attributes && (0, Bt.isInline)(e) && this.renderAttributes(e);
    else
      throw new Error("No renderer defined for node type " + e.tag);
  }
  renderAttributes(e) {
    if (!e.attributes || Object.keys(e.attributes).length === 0)
      return;
    const n = e.attributes;
    this.lit("{");
    let r = true;
    (0, Bt.isBlock)(e) && this.prefixes.push(" ");
    for (const s in n) {
      if (r || this.space(), s === "id")
        this.lit("#"), this.lit(n[s]);
      else if (s === "class") {
        const a = n[s].split(/  */);
        for (let l = 0; l < a.length; l++)
          l > 0 && this.space(), this.lit("."), this.lit(a[l]);
      } else
        this.lit(s), this.lit('="'), this.out(n[s]), this.lit('"');
      r = false;
    }
    (0, Bt.isBlock)(e) && this.prefixes.pop(), this.lit("}");
  }
  render() {
    return this.renderNode(this.doc), this.buffer.join("");
  }
};
var Oo = function(t, e = {}) {
  return new Mo(t, e).render();
};
Oe.renderDjot = Oo;
var Ee = {};
Object.defineProperty(Ee, "__esModule", { value: true });
Ee.version = void 0;
Ee.version = "0.3.1";
(function(t) {
  Object.defineProperty(t, "__esModule", { value: true }), t.isInline = t.isBlock = t.version = t.renderDjot = t.toPandoc = t.fromPandoc = t.applyFilter = t.HTMLRenderer = t.renderHTML = t.parseEvents = t.renderAST = t.parse = void 0;
  var e = Te;
  Object.defineProperty(t, "parse", { enumerable: true, get: function() {
    return e.parse;
  } }), Object.defineProperty(t, "renderAST", { enumerable: true, get: function() {
    return e.renderAST;
  } });
  var n = re;
  Object.defineProperty(t, "parseEvents", { enumerable: true, get: function() {
    return n.parseEvents;
  } });
  var r = Rt;
  Object.defineProperty(t, "renderHTML", { enumerable: true, get: function() {
    return r.renderHTML;
  } }), Object.defineProperty(t, "HTMLRenderer", { enumerable: true, get: function() {
    return r.HTMLRenderer;
  } });
  var s = Me;
  Object.defineProperty(t, "applyFilter", { enumerable: true, get: function() {
    return s.applyFilter;
  } });
  var a = Ut;
  Object.defineProperty(t, "fromPandoc", { enumerable: true, get: function() {
    return a.fromPandoc;
  } }), Object.defineProperty(t, "toPandoc", { enumerable: true, get: function() {
    return a.toPandoc;
  } });
  var l = Oe;
  Object.defineProperty(t, "renderDjot", { enumerable: true, get: function() {
    return l.renderDjot;
  } });
  var u = Ee;
  Object.defineProperty(t, "version", { enumerable: true, get: function() {
    return u.version;
  } });
  var c = xt;
  Object.defineProperty(t, "isBlock", { enumerable: true, get: function() {
    return c.isBlock;
  } }), Object.defineProperty(t, "isInline", { enumerable: true, get: function() {
    return c.isInline;
  } });
})(rn);
var vn = {};
var kn = {};
var _n = {};
var $t = {};
function Do(t) {
  kn = t.temmlOptions ?? {}, $t = t.djotHTMLRenderOptions ?? {}, vn = t.djotParseOptions ?? {}, _n = t.overrides ?? {};
}
function Po() {
  $t = {}, vn = {}, kn = {}, _n = {};
}
function Bo(t, ...e) {
  const n = fs(t, ...e).replace(
    new RegExp("(?<!\\$)(\\$\\`)([^`]+)\\`([.,])", "g"),
    "$1$2$3`"
  ), r = rn.parse(n, vn), s = {
    ...la(kn),
    ..._n,
    ...$t == null ? void 0 : $t.overrides
  };
  return $t = { ...$t, overrides: s }, rn.renderHTML(r, { ...$t });
}
function Lo(t, e) {
  return ve.renderToString(t, e);
}
function An(t, e) {
  return ve.renderToString(t, { ...e, displayMode: true });
}
function Fo(t, e) {
  return Wt("align", t, e);
}
function zo(t, e) {
  return Wt("align*", t, e);
}
function jo(t, e, n) {
  return An(`\\begin{alignat}{${e}}${t}\\end{alignat}`, n);
}
function Go(t, e, n) {
  return An(`\\begin{alignat*}{${e}}${t}\\end{alignat*}`, n);
}
function Ro(t, e) {
  return Wt("gather", t, e);
}
function Uo(t, e) {
  return Wt("gather*", t, e);
}
function Eo(t, e) {
  return Wt("equation", t, e);
}
function $o(t, e) {
  return Wt("equation*", t, e);
}
var Wo = Eo;
var Vo = $o;
function Wt(t, e, n) {
  return An(`\\begin{${t}}${e}\\end{${t}}`, n);
}
export {
  Fo as align,
  zo as alignStar,
  jo as alignat,
  Go as alignatStar,
  An as display,
  Wo as eqn,
  Vo as eqnStar,
  Eo as equation,
  $o as equationStar,
  Ro as gather,
  Uo as gatherStar,
  Lo as math,
  Bo as mathlifier,
  fs as mathlifierDj,
  us as mathlifierFactory,
  ps as mathlifierTex,
  Po as resetOptions,
  Do as setOptions
};
//# sourceMappingURL=mathlifier.js.map
